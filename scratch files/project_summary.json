[
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/xero_auth.py",
        "functions": [
            {
                "name": "index",
                "args": [],
                "decorators": [
                    "app.route('/')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def index():\n    return \"<h2>Welcome to the Xero Auth Demo!</h2><p><a href='/start_xero_auth'>Click here to reauthorize Xero tokens</a></p>\""
            },
            {
                "name": "start_xero_auth",
                "args": [],
                "decorators": [
                    "app.route('/start_xero_auth')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def start_xero_auth():\n    credentials = OAuth2Credentials(client_id=CLIENT_ID, client_secret=CLIENT_SECRET, callback_uri=CALLBACK_URI, scope=DEFAULT_SCOPES)\n    authorization_url = credentials.generate_url()\n    session['xero_creds_state'] = credentials.state\n    logger.info('Redirecting user to Xero authorization URL.')\n    return redirect(authorization_url)"
            },
            {
                "name": "xero_callback",
                "args": [],
                "decorators": [
                    "app.route('/xero_callback')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def xero_callback():\n    cred_state = session.get('xero_creds_state')\n    if not cred_state:\n        return make_response('No Xero credential state found. Please start auth again.', 400)\n    credentials = OAuth2Credentials(**cred_state)\n    full_request_uri = request.url\n    credentials.verify(full_request_uri)\n    logger.info('Successfully verified tokens with Xero.')\n    credentials.set_default_tenant()\n    session['xero_creds_state'] = credentials.state\n    token_data = credentials.token\n    logger.info('Saving tokens to .env file...')\n    set_key('../.env', 'XERO_ACCESS_TOKEN', token_data.get('access_token', ''))\n    set_key('../.env', 'XERO_REFRESH_TOKEN', token_data.get('refresh_token', ''))\n    logger.info('Tenant set. Tokens verified, stored in .env, and ready to use!')\n    return '<h2>Authorization Successful!</h2><p>Your tokens are now saved in .env. You can now make Xero API calls with fresh tokens.</p>'"
            },
            {
                "name": "xero_api",
                "args": [],
                "decorators": [
                    "app.route('/xero_api')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def xero_api():\n    cred_state = session.get('xero_creds_state')\n    if not cred_state:\n        return make_response('No Xero creds. Please reauthorize first!', 400)\n    credentials = OAuth2Credentials(**cred_state)\n    if credentials.expired():\n        logger.debug('Token expired; refreshing now...')\n        credentials.refresh()\n        session['xero_creds_state'] = credentials.state\n        token_data = credentials.token\n        logger.info('Refreshed tokens. Saving to .env file...')\n        set_key('../.env', 'XERO_ACCESS_TOKEN', token_data.get('access_token', ''))\n        set_key('../.env', 'XERO_REFRESH_TOKEN', token_data.get('refresh_token', ''))\n    else:\n        logger.info('CREDENTIALS ARE FINE')\n    xero_client = Xero(credentials)\n    return '<h2>Authorization Successful!</h2><p>Your tokens are now saved in .env. You can now make Xero API calls with fresh tokens.</p>'"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('xero_logger')"
            },
            {
                "name": "app",
                "value": "Flask(__name__)"
            },
            {
                "name": "CLIENT_ID",
                "value": "os.getenv('XERO_CLIENT_ID', 'YOUR_CLIENT_ID')"
            },
            {
                "name": "CLIENT_SECRET",
                "value": "os.getenv('XERO_CLIENT_SECRET', 'YOUR_CLIENT_SECRET')"
            },
            {
                "name": "CALLBACK_URI",
                "value": "'http://localhost:5002/xero_callback'"
            },
            {
                "name": "DEFAULT_SCOPES",
                "value": "[XeroScopes.OFFLINE_ACCESS, XeroScopes.ACCOUNTING_TRANSACTIONS, XeroScopes.ACCOUNTING_SETTINGS, XeroScopes.ACCOUNTING_CONTACTS]"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/xero_api.py",
        "functions": [],
        "classes": [
            {
                "name": "XeroAPI",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": "Initialize the XeroAPI client:\n  - Load environment variables\n  - Build OAuth2 credentials\n  - Create Xero client\n  - Refresh token if needed",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        Initialize the XeroAPI client:\n          - Load environment variables\n          - Build OAuth2 credentials\n          - Create Xero client\n          - Refresh token if needed\n        \"\"\"\n        try:\n            env_path = os.path.join(os.path.dirname(__file__), '..', '.env')\n            load_dotenv(env_path)\n        except Exception as e:\n            logging.getLogger('xero_logger').warning(\n                f'\ud83d\udea8 Could not load .env: {e}'\n            )\n\n        # Retrieve config from env\n        self.client_id = os.getenv('XERO_CLIENT_ID')\n        self.client_secret = os.getenv('XERO_CLIENT_SECRET')\n        self.access_token = os.getenv('XERO_ACCESS_TOKEN')\n        self.refresh_token = os.getenv('XERO_REFRESH_TOKEN')\n        self.tenant_id = os.getenv('XERO_TENANT_ID')\n        self.scope = (\n            os.getenv('XERO_SCOPE') or\n            'accounting.contacts accounting.settings accounting.transactions offline_access'\n        )\n\n        # Logger for Xero operations\n        self.logger = logging.getLogger('xero_logger')\n\n        # Prepare a default token dict\n        current_time = time.time()\n        default_expires_in = 1800  # 30 minutes\n        token_dict = {\n            'access_token': self.access_token,\n            'refresh_token': self.refresh_token,\n            'expires_in': default_expires_in,\n            'expires_at': current_time + default_expires_in,\n            'token_type': 'Bearer',\n            'scope': self.scope.split()\n        }\n\n        # Create OAuth2 credentials & Xero client\n        self.credentials = OAuth2Credentials(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scope=self.scope.split(),\n            token=token_dict\n        )\n        if self.tenant_id:\n            self.credentials.tenant_id = self.tenant_id\n\n        from xero import Xero  # Re-import for clarity\n        self.xero = Xero(self.credentials)\n        self._refresh_token_if_needed()\n\n        self.logger.info('\ud83d\ude80 - XeroAPI initialized.')\n        self._initialized = True"
                    },
                    {
                        "name": "_refresh_token_if_needed",
                        "args": [
                            "self",
                            "force"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _refresh_token_if_needed(self, force=False):\n        # If not forced and token isn't expired, skip\n        if not force and not self.credentials.expired():\n            self.logger.debug('[XeroAPI] Token still valid, no refresh needed.')\n            return\n\n        self.logger.debug('[XeroAPI] \ud83d\udd11 Refreshing token...')\n        try:"
                    },
                    {
                        "name": "_retry_on_unauthorized",
                        "args": [
                            "self",
                            "func"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": "Retry logic for certain Xero exceptions (Unauthorized, RateLimit, etc.).",
                        "function_body": "    def _retry_on_unauthorized(self, func, *args, **kwargs):\n        \"\"\"\n        Retry logic for certain Xero exceptions (Unauthorized, RateLimit, etc.).\n        \"\"\"\n        max_retries = 3\n        for attempt in range(1, max_retries + 1):\n            try:\n                self.logger.debug(f'[XeroAPI] Attempt {attempt} => {func.__name__}')\n                return func(*args, **kwargs)\n            except XeroUnauthorized:\n                self.logger.warning('[XeroAPI] \u26a0\ufe0f Unauthorized, attempting force-refresh.')\n                self._refresh_token_if_needed(force=True)\n            except XeroRateLimitExceeded:\n                self.logger.warning(f'[XeroAPI] \ud83d\udd03 Rate limit on attempt {attempt}, sleeping 65s...')\n                time.sleep(65)\n            except XeroException as e:\n                self.logger.error(f'[XeroAPI] \u274c XeroException: {e}')\n                raise e\n\n        self.logger.error('[XeroAPI] \u274c Failed Xero API call after max retries.')\n        return None"
                    },
                    {
                        "name": "_get_tax_code_for_detail_item",
                        "args": [
                            "self",
                            "session",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _get_tax_code_for_detail_item(self, session, detail_item: DetailItem) -> str:\n        tax_code = 'TAX001'\n        try:\n            from database.models import AccountCode  # local import to avoid cyclical references\n            acct_code = session.query(AccountCode).filter_by(\n                id=detail_item.account_code_id\n            ).first()\n            if acct_code and acct_code.tax_account:\n                tax_code = acct_code.tax_account.tax_code\n        except Exception as e:\n            self.logger.warning(\n                f'[_get_tax_code_for_detail_item] [XeroAPI - detail_item {detail_item.id}] \u26a0\ufe0f - Error retrieving tax code: {str(e)}'\n            )\n        return tax_code"
                    },
                    {
                        "name": "_convert_detail_item_to_line_item",
                        "args": [
                            "self",
                            "session",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "_get_tax_code_for_detail_item"
                        ],
                        "docstring": null,
                        "function_body": "    def _convert_detail_item_to_line_item(self, session, detail_item: DetailItem) -> dict:\n        try:"
                    },
                    {
                        "name": "get_contact_by_name",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def get_contact_by_name(self, name: str):\n        self._refresh_token_if_needed()\n        function_name = 'get_contact_by_name'\n        self.logger.info(f'[{function_name}] [XeroAPI - contact {name}] \ud83d\udd0e - Searching by name...')\n        try:"
                    },
                    {
                        "name": "get_all_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def get_all_contacts(self):\n        self._refresh_token_if_needed()\n        function_name = 'get_all_contacts'\n        self.logger.info(f'[{function_name}] [XeroAPI] \ud83d\udcc7 - Fetching all contacts...')\n        try:"
                    },
                    {
                        "name": "create_contact",
                        "args": [
                            "self",
                            "contact_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def create_contact(self, contact_data: dict):\n        self._refresh_token_if_needed()\n        function_name = 'create_contact'\n        self.logger.info(f'[{function_name}] [XeroAPI] \ud83d\udc64 - Creating new contact: {contact_data}')\n        try:"
                    },
                    {
                        "name": "update_contact",
                        "args": [
                            "self",
                            "contact_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def update_contact(self, contact_data: dict):\n        function_name = 'update_contact'\n        cid = contact_data.get('ContactID')\n        self.logger.info(f'[{function_name}] [XeroAPI - contactID {cid}] \ud83d\udd04 - Updating contact...')\n        self._refresh_token_if_needed()\n        try:"
                    },
                    {
                        "name": "update_contact_with_retry",
                        "args": [
                            "self",
                            "contact_data",
                            "max_retries"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": null,
                        "function_body": "    def update_contact_with_retry(self, contact_data, max_retries=3):\n        function_name = 'update_contact_with_retry'\n        cid = contact_data.get('ContactID')\n        self.logger.info(\n            f'[{function_name}] [XeroAPI - contactID {cid}] \ud83d\udd04 - Updating with up to {max_retries} retries.')\n        self._refresh_token_if_needed()\n        for attempt in range(1, max_retries + 1):\n            try:\n                updated = self.xero.contacts.save(contact_data)\n                return updated\n            except XeroRateLimitExceeded:\n                self.logger.warning(\n                    f'[{function_name}] [XeroAPI - contactID {cid}] \ud83d\udd03 - Rate limit. Attempt {attempt} of {max_retries}.')\n                time.sleep(65)\n            except XeroException as xe:\n                self.logger.error(f'[{function_name}] [XeroAPI - contactID {cid}] \u274c - XeroException: {xe}')\n                return None\n            except Exception as e:\n                self.logger.error(f'[{function_name}] [XeroAPI - contactID {cid}] \ud83d\udca5 - Unexpected: {str(e)}')\n                return None\n        self.logger.error(f'[{function_name}] [XeroAPI - contactID {cid}] \u274c - Failed after multiple retries.')\n        return None"
                    },
                    {
                        "name": "update_contacts_with_retry",
                        "args": [
                            "self",
                            "contacts_data",
                            "max_retries"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": null,
                        "function_body": "    def update_contacts_with_retry(self, contacts_data: list[dict], max_retries=3):\n        function_name = 'update_contacts_with_retry'\n        self.logger.info(f'[{function_name}] [XeroAPI] \ud83d\udd04 - Batch update of {len(contacts_data)} contact(s)...')\n        self._refresh_token_if_needed()\n        for attempt in range(1, max_retries + 1):\n            try:\n                updated = self.xero.contacts.save(contacts_data)\n                return updated\n            except XeroRateLimitExceeded:\n                self.logger.warning(\n                    f'[{function_name}] [XeroAPI] \ud83d\udd03 - Rate limit on attempt {attempt}. Sleeping 65s...')\n                time.sleep(65)\n            except XeroException as xe:\n                self.logger.error(f'[{function_name}] [XeroAPI] \u274c - XeroException in batch contact update: {xe}')\n                return None\n            except Exception as e:\n                self.logger.error(f'[{function_name}] [XeroAPI] \ud83d\udca5 - Unexpected: {str(e)}')\n                return None\n        self.logger.error(f'[{function_name}] [XeroAPI] \u274c - Failed after multiple retries.')\n        return None"
                    },
                    {
                        "name": "create_invoice",
                        "args": [
                            "self",
                            "payload"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def create_invoice(self, payload: dict):\n        self._refresh_token_if_needed()\n        self.logger.info('[create_invoice] - Creating ACCPAY invoice in Xero.')\n        try:"
                    },
                    {
                        "name": "update_invoice",
                        "args": [
                            "self",
                            "xero_id",
                            "changes"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def update_invoice(self, xero_id: str, changes: dict):\n        self._refresh_token_if_needed()\n        self.logger.info(f'[update_invoice] - Updating invoice {xero_id} with {changes}')\n        try:"
                    },
                    {
                        "name": "delete_invoice",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def delete_invoice(self, invoice_id: str):\n        self._refresh_token_if_needed()\n        self.logger.info(f'[delete_invoice] - Attempting to delete (InvoiceID={invoice_id}).')\n        try:"
                    },
                    {
                        "name": "get_invoice_details",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def get_invoice_details(self, invoice_id: str):\n        self._refresh_token_if_needed()\n        self.logger.debug(f'[get_invoice_details] - Fetching invoice {invoice_id}')\n        try:"
                    },
                    {
                        "name": "add_line_item_to_invoice",
                        "args": [
                            "self",
                            "invoice_id",
                            "line_item_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def add_line_item_to_invoice(self, invoice_id: str, line_item_data: dict) -> dict:\n        self._refresh_token_if_needed()\n        try:"
                    },
                    {
                        "name": "update_line_item_in_invoice",
                        "args": [
                            "self",
                            "invoice_id",
                            "line_item_id",
                            "new_line_item_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def update_line_item_in_invoice(self, invoice_id: str, line_item_id: str, new_line_item_data: dict) -> dict:\n        self._refresh_token_if_needed()\n        try:"
                    },
                    {
                        "name": "create_bill",
                        "args": [
                            "self",
                            "session",
                            "project_id",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_convert_detail_item_to_line_item",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def create_bill(self, session, project_id: int, po_number: int, detail_number: int):\n        self._refresh_token_if_needed()\n        function_name = 'create_bill'\n        try:\n            detail_items = session.query(DetailItem).filter(DetailItem.line_number == detail_number).all()\n        except Exception as e:\n            self.logger.error(\n                f'[{function_name}] [XeroAPI - detail_number {detail_number}] \u274c - DB error: {str(e)}'\n            )\n            detail_items = []\n        if not detail_items:\n            self.logger.warning(\n                f'[{function_name}] [XeroAPI - detail_number {detail_number}] \u26a0\ufe0f - No detail items found; creating empty Bill.'\n            )\n            detail_items = []\n        xero_line_items = []\n        for di in detail_items:\n            try:\n                xero_line_items.append(self._convert_detail_item_to_line_item(session, di))\n            except Exception as ex:\n                self.logger.error(\n                    f'[{function_name}] [XeroAPI - detail_item {di.id}] \ud83d\udca5 - Conversion error: {str(ex)}'\n                )\n        states = {di.state for di in detail_items}\n        if len(states) == 1:\n            only_state = list(states)[0]\n            if only_state == 'SUBMITTED':\n                xero_status = 'DRAFT'\n            elif only_state == 'RTP':\n                xero_status = 'SUBMITTED'\n            elif only_state == 'PAID':\n                xero_status = 'PAID'\n            else:\n                xero_status = 'DRAFT'\n        else:\n            xero_status = 'DRAFT'\n        contact_xero_id_from_db = None\n        if detail_items and hasattr(detail_items[0], \"contact_id\"):\n            contact_id = detail_items[0].contact_id\n            if contact_id:\n                self.logger.debug(f'[{function_name}] [XeroAPI] \ud83d\udd0e - Searching contact_id={contact_id}')\n                found_contact = self._retry_on_unauthorized(self.xero.contacts.filter, ContactID=contact_id)\n        reference = f'{project_id}_{po_number}_{detail_number}'\n        new_invoice = {\n            'Type': 'ACCPAY',\n            'Contact': {'ContactID': contact_xero_id_from_db or '11111111-2222-3333-4444-555555555555'},\n            'LineItems': xero_line_items,\n            'InvoiceNumber': reference,\n            'Status': xero_status\n        }\n        self.logger.info(f'[{function_name}] [XeroAPI - reference {reference}] \ud83d\udcbc - Creating Xero bill...')\n        try:"
                    },
                    {
                        "name": "update_bill_status",
                        "args": [
                            "self",
                            "invoice_id",
                            "new_status"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def update_bill_status(self, invoice_id: str, new_status: str):\n        self._refresh_token_if_needed()\n        function_name = 'update_bill_status'\n        self.logger.info(f'[{function_name}] [XeroAPI - invoice_id {invoice_id}] \ud83d\udd04 - Updating to {new_status}...')\n        try:"
                    },
                    {
                        "name": "get_bills_by_reference",
                        "args": [
                            "self",
                            "reference_str"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def get_bills_by_reference(self, reference_str: str):\n        self._refresh_token_if_needed()\n        function_name = 'get_bills_by_reference'\n        self.logger.info(f'[{function_name}] - Searching for ACCPAY invoices using Reference=\"{reference_str}\"')\n        try:"
                    },
                    {
                        "name": "get_all_bills",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def get_all_bills(self):\n        self._refresh_token_if_needed()\n        function_name = 'get_all_bills'\n        self.logger.info(f'[{function_name}] [XeroAPI] \ud83d\udcc4 - Retrieving all ACCPAY invoices...')\n        all_invoices_summary = []\n        page_number = 1\n        page_size = 100\n        while True:\n            self.logger.debug(f'[{function_name}] [XeroAPI] \ud83d\udd0e - Fetching ACCPAY page {page_number}...')\n            filter_str = 'Type==\"ACCPAY\"'\n            invoices_page = self._retry_on_unauthorized(self.xero.invoices.filter, raw=filter_str, page=page_number)\n            if not invoices_page:\n                self.logger.debug(f'[{function_name}] [XeroAPI] \u23f9\ufe0f - No invoices on page {page_number}.')\n                break\n            all_invoices_summary.extend(invoices_page)\n            if len(invoices_page) < page_size:\n                break\n            page_number += 1\n        if not all_invoices_summary:\n            self.logger.info(f'[{function_name}] [XeroAPI] \u2139\ufe0f - No ACCPAY invoices found.')\n            return []\n        self.logger.info(\n            f'[{function_name}] [XeroAPI] \ud83d\udd0e - Fetched {len(all_invoices_summary)} summaries, now retrieving full details...')\n        detailed_invoices = []\n        for summary_inv in all_invoices_summary:\n            if summary_inv.get('Status') == 'DELETED':\n                continue\n            invoice_id = summary_inv.get('InvoiceID')\n            if not invoice_id:\n                continue\n            full_inv_list = self._retry_on_unauthorized(self.xero.invoices.get, invoice_id)\n            if not full_inv_list:\n                continue\n            detailed_inv = full_inv_list[0]\n            if detailed_inv.get('Status') == 'DELETED':\n                continue\n            detailed_invoices.append(detailed_inv)\n        self.logger.info(\n            f'[{function_name}] [XeroAPI] \u2705 - Retrieved {len(detailed_invoices)} detailed ACCPAY invoices.')\n        return detailed_invoices"
                    },
                    {
                        "name": "get_acpay_invoices_summary_by_ref",
                        "args": [
                            "self",
                            "reference_substring"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def get_acpay_invoices_summary_by_ref(self, reference_substring: str) -> list:\n        self._refresh_token_if_needed()\n        function_name = 'get_acpay_invoices_summary_by_ref'\n        raw_filter = (\n            'Type==\"ACCPAY\" AND InvoiceNumber!=null '\n            f'&& InvoiceNumber.Contains(\"{reference_substring}\")'\n        )\n        self.logger.info(f'[{function_name}] [XeroAPI] \ud83d\udd0e - Searching ACCPAY with substring: {reference_substring}')\n        page_number = 1\n        page_size = 100\n        all_summaries = []\n        while True:\n            self.logger.debug(f'[{function_name}] [XeroAPI] \ud83d\udd0d - Page {page_number}, filter: {raw_filter}')\n            current_page = self._retry_on_unauthorized(self.xero.invoices.filter, raw=raw_filter, page=page_number)\n            if not current_page:\n                break\n            filtered_page = [inv for inv in current_page if inv.get('Status') != 'DELETED']\n            all_summaries.extend(filtered_page)\n            if len(current_page) < page_size:\n                break\n            page_number += 1\n        self.logger.info(f'[{function_name}] [XeroAPI] \u2705 - Found {len(all_summaries)} invoice summaries.')\n        return all_summaries"
                    },
                    {
                        "name": "create_spend_money",
                        "args": [
                            "self",
                            "session",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_create_voided_spend_money",
                            "_convert_detail_item_to_line_item",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def create_spend_money(self, session, detail_item_id: int):\n        self._refresh_token_if_needed()\n        function_name = 'create_spend_money'\n        detail_item = None\n        try:\n            detail_item = session.query(DetailItem).get(detail_item_id)\n        except Exception as e:\n            self.logger.error(\n                f'[{function_name}] [XeroAPI - detail_item {detail_item_id}] \u274c - DB error retrieving DetailItem: {str(e)}'\n            )\n        if not detail_item:\n            self.logger.info(\n                f'[{function_name}] [XeroAPI - detail_item {detail_item_id}] \ud83d\uddd2\ufe0f - No DetailItem found => creating VOIDED spend money.'\n            )\n            return self._create_voided_spend_money()\n        if detail_item.state == 'SUBMITTED':\n            xero_status = 'DRAFT'\n        elif detail_item.state == 'REVIEWED':\n            xero_status = 'AUTHORISED'\n        else:\n            xero_status = 'VOIDED'\n        try:"
                    },
                    {
                        "name": "create_spend_money_in_xero",
                        "args": [
                            "self",
                            "spend_money_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def create_spend_money_in_xero(self, spend_money_record: dict):\n        self._refresh_token_if_needed()\n        self.logger.info('[create_spend_money_in_xero] Creating spend money from a SpendMoney dict...')\n        xero_status = (spend_money_record.get('state') or 'DRAFT').upper()\n        new_tx = {\n            'Type': 'SPEND',\n            'Contact': {'Name': spend_money_record.get('vendor', 'Unknown Vendor')},\n            'LineItems': [{\n                'Description': spend_money_record.get('description', 'No description'),\n                'Quantity': 1,\n                'UnitAmount': float(spend_money_record.get('amount', 0.0)),\n                'TaxType': 'NONE'\n            }],\n            'Status': xero_status\n        }\n        try:"
                    },
                    {
                        "name": "create_spend_money_via_detail_id",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def create_spend_money_via_detail_id(self, detail_item_id: int):\n        self.logger.info(f'[create_spend_money_via_detail_id] => detail_item_id={detail_item_id}')"
                    },
                    {
                        "name": "update_spend_money",
                        "args": [
                            "self",
                            "xero_spend_money_id",
                            "new_state"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def update_spend_money(self, xero_spend_money_id: str, new_state: str):\n        self._refresh_token_if_needed()\n        function_name = 'update_spend_money'\n        self.logger.info(\n            f'[{function_name}] [XeroAPI - spend_money {xero_spend_money_id}] \ud83d\udd04 - Updating to {new_state}...')\n        try:"
                    },
                    {
                        "name": "update_spend_transaction_status",
                        "args": [
                            "self",
                            "xero_spend_money_id",
                            "new_state"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_spend_money"
                        ],
                        "docstring": null,
                        "function_body": "    def update_spend_transaction_status(self, xero_spend_money_id: str, new_state: str) -> dict:\n        return self.update_spend_money(xero_spend_money_id, new_state)"
                    },
                    {
                        "name": "_create_voided_spend_money",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_retry_on_unauthorized"
                        ],
                        "docstring": null,
                        "function_body": "    def _create_voided_spend_money(self):\n        function_name = '_create_voided_spend_money'\n        voided_tx = {\n            'Type': 'SPEND',\n            'Contact': {'Name': 'Unknown Vendor'},\n            'LineItems': [],\n            'Status': 'VOIDED'\n        }\n        try:"
                    },
                    {
                        "name": "create_spend_money_in_batch",
                        "args": [
                            "self",
                            "session",
                            "detail_item_ids"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def create_spend_money_in_batch(self, session, detail_item_ids: list[int]):\n        function_name = 'create_spend_money_in_batch'\n        self.logger.info(f'[{function_name}] [XeroAPI] \ud83c\udfce - Creating spend money for detail_item_ids={detail_item_ids}')\n        futures = []\n        results = []\n        with ThreadPoolExecutor(max_workers=5) as executor:\n            for detail_item_id in detail_item_ids:\n                futures.append(executor.submit(self.create_spend_money, session, detail_item_id))\n            for future in as_completed(futures):\n                try:\n                    result = future.result()\n                    results.append(result)\n                except Exception as e:\n                    self.logger.error(f'[{function_name}] [XeroAPI] \ud83d\udca5 - Thread exception: {str(e)}')\n        self.logger.info(f'[{function_name}] [XeroAPI] \u2705 - Batch completed with {len(results)} result(s).')\n        return results"
                    },
                    {
                        "name": "upsert_contacts_batch",
                        "args": [
                            "self",
                            "contacts"
                        ],
                        "decorators": [],
                        "calls": [
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Attempts to upsert a batch of contacts in Xero (update if xero_id present,\notherwise create). Before creating new contacts, checks Xero for any\nexisting contacts by name and avoids double creation for those found.",
                        "function_body": "    def upsert_contacts_batch(self, contacts: list[dict]):\n        \"\"\"\n        Attempts to upsert a batch of contacts in Xero (update if xero_id present,\n        otherwise create). Before creating new contacts, checks Xero for any\n        existing contacts by name and avoids double creation for those found.\n        \"\"\"\n        results = []\n\n        update_contacts = []\n        create_contacts = []\n\n        # Separate contacts into update vs create\n        for contact in contacts:\n            try:\n                xid = contact[\"xero_id\"]\n                if xid:\n                    update_contacts.append(contact)\n                else:\n                    create_contacts.append(contact)\n            except KeyError as e:\n                self.logger.error(\n                    f\"\u26d4 Skipping contact because 'xero_id' key is missing: {contact}. Error: {e}\"\n                )\n                raise\n            except Exception as e:\n                self.logger.error(\n                    f\"\u26d4 Unexpected error while parsing contact for upsert: {contact}. Error: {e}\"\n                )\n                raise\n\n        # -----------------------------\n        #  Update batch\n        # -----------------------------\n        if update_contacts:\n            self.logger.info(f\"\ud83c\udf00 Updating {len(update_contacts)} existing contacts in Xero.\")\n            try:\n                updated_list = self._retry_on_unauthorized(\n                    self.xero.contacts.put,\n                    update_contacts\n                )\n                if updated_list:\n                    self.logger.info(f\"\ud83c\udf00 Successfully updated {len(updated_list)} contacts.\")\n                    results.extend(updated_list)\n            except KeyError as e:\n                self.logger.error(f\"\u26d4 KeyError during update batch: {update_contacts}. Error: {e}\")\n            except Exception as e:\n                self.logger.error(\n                    f\"\u26d4 Unexpected exception while updating contacts in Xero. Error: {e}\"\n                )\n\n        # -----------------------------\n        #  Create batch\n        # -----------------------------\n        if create_contacts:\n            self.logger.info(f\"\ud83c\udf00 Preparing to create {len(create_contacts)} new contacts in Xero.\")\n\n            # 1) Check Xero for each contact name before creating\n            existing_contacts = []\n            to_create_contacts = []\n\n            for contact in create_contacts:\n                try:\n                    contact_name = contact[\"Name\"]\n                except KeyError as e:\n                    self.logger.error(\n                        f\"\u26d4 Contact is missing 'Name' key and cannot be created: {contact}. Error: {e}\"\n                    )\n                    raise\n                except Exception as e:\n                    self.logger.error(\n                        f\"\u26d4 Unexpected error reading contact name for creation: {contact}. Error: {e}\"\n                    )\n                    raise\n\n                # Use filter instead of all(..., where=...) to query by name.\n                try:\n                    found = self.xero.contacts.filter(Name=contact_name)\n                except Exception as e:\n                    self.logger.error(\n                        f\"\u26d4 Error querying Xero for existing contact by name='{contact_name}'. Error: {e}\"\n                    )\n                    raise\n\n                if found:\n                    self.logger.info(\n                        f\"\ud83c\udf00 Found existing Xero contact for '{contact_name}'. Skipping creation.\"\n                    )\n                    existing_contacts.extend(found)\n                else:\n                    to_create_contacts.append(contact)\n\n            if existing_contacts:\n                self.logger.info(\n                    f\"\ud83c\udf00 {len(existing_contacts)} contacts already exist in Xero. They will be added to the results without creation.\"\n                )\n                results.extend(existing_contacts)\n\n            if to_create_contacts:\n                self.logger.info(\n                    f\"\ud83c\udf00 Creating {len(to_create_contacts)} new contacts in Xero.\"\n                )\n                try:\n                    created_list = self._retry_on_unauthorized(\n                        self.xero.contacts.put,\n                        to_create_contacts\n                    )\n                    if created_list:\n                        self.logger.info(\n                            f\"\ud83c\udf00 Successfully created {len(created_list)} new contacts.\"\n                        )\n                        results.extend(created_list)\n                except KeyError as e:\n                    self.logger.error(\n                        f\"\u26d4 KeyError during create batch: {to_create_contacts}. Error: {e}\"\n                    )\n                except Exception as e:\n                    self.logger.error(\n                        f\"\u26d4 Unexpected exception while creating contacts in Xero. Error: {e}\"\n                    )\n            else:\n                self.logger.info(\"\ud83c\udf00 No new contacts to create in Xero.\")\n        else:\n            self.logger.info(\"\ud83c\udf00 No contacts to create in Xero.\")\n\n        return results"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "xero_api",
                "value": "XeroAPI()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/xero_services.py",
        "functions": [],
        "classes": [
            {
                "name": "XeroServices",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger('xero_logger')\n        self.logger.setLevel(logging.DEBUG)\n        self.xero_api = xero_api\n\n        # We'll store staged contacts here until we do a batch upsert.\n        # Each item is a local DB dict (has at least 'id', 'name', optional 'xero_id').\n        self.contact_upsert_queue = []\n        self.db_ops = DatabaseOperations()  # if that's how you reference DB ops\n        self.logger.info(\"XeroServices initialized.\")"
                    },
                    {
                        "name": "handle_spend_money_create",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_spend_money",
                            "search_spend_money",
                            "create_spend_money_via_detail_id",
                            "create_spend_money_in_xero"
                        ],
                        "docstring": null,
                        "function_body": "    def handle_spend_money_create(self, spend_money_id:int):\n        self.logger.info(f'handle_spend_money_create => spend_money_id={spend_money_id}')\n        sm = self.db_ops.search_spend_money([\"id\"], [spend_money_id])\n        if not sm:\n            self.logger.warning(\"No SpendMoney record found to create in Xero.\")\n            return\n        if isinstance(sm, list):\n            sm = sm[0]\n        if (sm.get('state') or '').upper() == \"RECONCILED\":\n            self.logger.info(\"Already RECONCILED => no Xero update needed.\")\n            return\n        # 1) Pull data from SpendMoney record\n        detail_item_id = sm.get('detail_item_id')\n        if not detail_item_id:\n            self.logger.info(\"SpendMoney row lacks detail_item_id; we\u2019ll do a minimal create.\")\n            created = self.xero_api.create_spend_money_in_xero(sm)\n        else:\n            # If you store a reference to detail_item_id, pass that to xero_api\n            self.logger.info(f\"Creating SPEND money in Xero referencing detail_item_id={detail_item_id}...\")\n            created = self.xero_api.create_spend_money_via_detail_id(detail_item_id)\n        if created and isinstance(created, list):\n            created = created[0]\n        if created and created.get('xero_spend_money_id'):"
                    },
                    {
                        "name": "handle_spend_money_update",
                        "args": [
                            "self",
                            "spend_money_id",
                            "new_state"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_spend_money",
                            "search_spend_money",
                            "update_spend_transaction_status",
                            "handle_spend_money_create"
                        ],
                        "docstring": "Example method that tries to update an existing Xero SPEND transaction\nto a new status (e.g., 'AUTHORISED', 'VOIDED', or 'RECONCILED').",
                        "function_body": "    def handle_spend_money_update(self, spend_money_id:int, new_state:str):\n        \"\"\"\n        Example method that tries to update an existing Xero SPEND transaction\n        to a new status (e.g., 'AUTHORISED', 'VOIDED', or 'RECONCILED').\n        \"\"\"\n        self.logger.info(f'handle_spend_money_update => spend_money_id={spend_money_id}, new_state={new_state}')\n        sm = self.db_ops.search_spend_money([\"id\"], [spend_money_id])\n        if not sm:\n            self.logger.warning(\"No SpendMoney record found for update.\")\n            return\n        if isinstance(sm, list):\n            sm = sm[0]\n        existing_xero_id = sm.get('xero_id')\n        if not existing_xero_id:\n            self.logger.info(\"This SpendMoney has no xero_id => calling handle_spend_money_create first.\")\n            self.handle_spend_money_create(spend_money_id)\n            return\n        # 2) Actually call xero_api to update the status\n        updated = self.xero_api.update_spend_transaction_status(existing_xero_id, new_state)\n        if updated and isinstance(updated, list):\n            updated = updated[0]\n        if updated and updated.get('Status'):"
                    },
                    {
                        "name": "create_xero_bill_in_xero",
                        "args": [
                            "self",
                            "xero_bill"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_invoice",
                            "search_purchase_orders",
                            "get_bills_by_reference",
                            "search_contacts",
                            "update_xero_bill"
                        ],
                        "docstring": null,
                        "function_body": "    def create_xero_bill_in_xero(self, xero_bill: dict):\n        bill_id = xero_bill[\"id\"]\n        self.logger.info(f'[create_xero_bill_in_xero] => BillID={bill_id}')\n        if xero_bill.get('xero_id'):\n            self.logger.info(f'Already has xero_id={xero_bill[\"xero_id\"]}, skipping creation.')\n            return\n        reference = xero_bill[\"xero_reference_number\"]\n        self.logger.info(f'Checking Xero for existing invoice with InvoiceNumber={reference}...')\n        existing_invoices = self.xero_api.get_bills_by_reference(reference)\n        self.logger.debug(f'Found existing_invoices={existing_invoices}')\n        if existing_invoices:\n            existing_xero_id = existing_invoices[0].get('InvoiceID')\n            existing_link = f'https://go.xero.com/AccountsPayable/View.aspx?invoiceId={existing_xero_id}'\n            self.db_ops.update_xero_bill(bill_id, xero_id=existing_xero_id, xero_link=existing_link)\n            self.logger.info(\"Linked local Bill to existing Xero invoice.\")\n            return\n        po_number = xero_bill.get('po_number')\n        project_number = xero_bill.get('project_number')\n        purchase_orders = self.db_ops.search_purchase_orders(['project_number','po_number'], [project_number, po_number])\n        self.logger.debug(f'purchase_orders={purchase_orders}')\n        if not purchase_orders:\n            self.logger.warning(\"No PurchaseOrder for the Bill. Missing contact_id.\")\n            return\n        if isinstance(purchase_orders, list):\n            purchase_order = purchase_orders[0]\n        else:\n            purchase_order = purchase_orders\n        contact_id = purchase_order.get('contact_id')\n        if not contact_id:\n            self.logger.warning(\"PurchaseOrder has no contact_id => cannot create in Xero.\")\n            return\n        contact_record = self.db_ops.search_contacts(['id'], [contact_id])\n        self.logger.debug(f'contact_record={contact_record}')\n        if not contact_record:\n            self.logger.warning(\"No Contact found in DB => skipping Xero Bill creation.\")\n            return\n        if isinstance(contact_record, list):\n            contact_record = contact_record[0]\n        xero_contact_id = contact_record.get('xero_id')\n        if not xero_contact_id:\n            self.logger.warning(\"Contact missing xero_id => cannot create Xero Bill.\")\n            return\n        creation_payload = {\n            'Type': 'ACCPAY',\n            'InvoiceNumber': reference,\n            'Contact': {'ContactID': xero_contact_id}\n        }\n        if xero_bill.get('transaction_date'):\n            creation_payload['Date'] = xero_bill['transaction_date']\n        if xero_bill.get('due_date'):\n            creation_payload['DueDate'] = xero_bill['due_date']\n        self.logger.info(f'Sending invoice creation payload to Xero => {creation_payload}')\n        result = self.xero_api.create_invoice(creation_payload)\n        self.logger.debug(f'create_invoice => {result}')\n        if not result:\n            self.logger.error(\"Invoice creation in Xero failed.\")\n            return\n        try:"
                    },
                    {
                        "name": "update_xero_bill",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_invoice",
                            "search_xero_bill_line_items",
                            "search_xero_bills",
                            "search_detail_item_by_keys",
                            "create_xero_bill_in_xero",
                            "update_detail_item"
                        ],
                        "docstring": null,
                        "function_body": "    def update_xero_bill(self, bill_id:int):\n        self.logger.info(f'[update_xero_bill] => BillID={bill_id}')\n        xero_bill = self.db_ops.search_xero_bills(['id'], [bill_id])\n        self.logger.debug(f'xero_bill={xero_bill}')\n        if not xero_bill:\n            self.logger.warning(\"No XeroBill found => skipping.\")\n            return\n        if isinstance(xero_bill, list):\n            xero_bill = xero_bill[0]\n        if not xero_bill.get('xero_id'):\n            self.logger.info(\"No xero_id => calling create_xero_bill_in_xero.\")\n            self.create_xero_bill_in_xero(xero_bill)\n            self.logger.info(\"Done creating new xero bill => returning.\")\n            project_number = xero_bill.get('project_number')\n            po_number = xero_bill.get('po_number')\n            detail_number = xero_bill.get('detail_number')\n            if not(project_number and po_number and detail_number):\n                self.logger.warning(\"Missing keys => cannot update detail items.\")\n                return\n            detail_items = self.db_ops.search_detail_item_by_keys(project_number, po_number, detail_number)\n            self.logger.debug(f'Found detail_items => {detail_items}')\n            if isinstance(detail_items, dict):\n                detail_items = [detail_items]\n            if detail_items:\n                for di in detail_items:\n                    if not di.get('parent_xero_id'):\n                        xero_bill_line_items = self.db_ops.search_xero_bill_line_items(\n                            ['description','parent_id','xero_bill_line_id'],\n                            [di['description'],bill_id,None]\n                        )\n                        if xero_bill_line_items:\n                            if isinstance(xero_bill_line_items, list):\n                                xero_bill_line_item = xero_bill_line_items[0]\n                            else:\n                                xero_bill_line_item = xero_bill_line_items\n                            xero_line_id = xero_bill_line_item.get('xero_bill_line_id')\n                            if xero_line_id:\n                                self.logger.info(f'Updating DetailItem={di[\"id\"]} => parent_xero_id={xero_line_id}')\n                                self.db_ops.update_detail_item(di['id'], parent_xero_id=xero_line_id)\n                        else:\n                            self.logger.warning(f'No XeroBillLineItem found matching detail_item={di[\"id\"]}')\n            return\n        changes = {}\n        self.logger.debug(f'Potential changes => {changes}')\n        if not changes:\n            self.logger.info(\"No changes to push => done.\")\n            return\n        self.logger.info(f'Pushing changes => {changes}')\n        updated = self.xero_api.update_invoice(xero_bill['xero_id'], changes)\n        self.logger.debug(f'update_invoice => {updated}')\n        if updated:"
                    },
                    {
                        "name": "delete_xero_bill",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_xero_bills",
                            "delete_invoice"
                        ],
                        "docstring": null,
                        "function_body": "    def delete_xero_bill(self, bill_id:int):\n        self.logger.info(f'[delete_xero_bill] => BillID={bill_id}')\n        xero_bill = self.db_ops.search_xero_bills(['id'], [bill_id])\n        self.logger.debug(f'Fetched xero_bill => {xero_bill}')\n        if xero_bill:\n            if isinstance(xero_bill, list):\n                xero_bill = xero_bill[0]\n            xero_id = xero_bill.get('xero_id')\n        else:\n            self.logger.warning(\"No local record => skipping.\")\n            return\n        if not xero_id:\n            self.logger.warning(\"Bill has no xero_id => cannot delete in Xero.\")\n            return\n        self.logger.info(f'Setting invoice {xero_id} => DELETED in Xero.')\n        delete_resp = self.xero_api.delete_invoice(xero_id)\n        self.logger.debug(f'delete_invoice => {delete_resp}')\n        if delete_resp:"
                    },
                    {
                        "name": "load_spend_money_transactions",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_spend_money"
                        ],
                        "docstring": null,
                        "function_body": "    def load_spend_money_transactions(self, project_id:int=None, po_number:int=None, detail_number:int=None):\n        self.logger.info(f'load_spend_money_transactions => project={project_id}, po={po_number}, detail={detail_number}')\n        self.logger.info('Retrieving SPEND transactions from Xero...')\n        xero_spend_transactions = self.xero_api.get_spend_money_by_reference(\n            project_id=project_id,\n            po_number=po_number,\n            detail_number=detail_number\n        )\n        self.logger.debug(f'get_spend_money_by_reference => {xero_spend_transactions}')\n        if not xero_spend_transactions:\n            self.logger.info('No SPEND transactions returned from Xero.')\n            return\n        for tx in xero_spend_transactions:"
                    },
                    {
                        "name": "populate_xero_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_contact",
                            "search_contacts",
                            "get_all_contacts"
                        ],
                        "docstring": null,
                        "function_body": "    def populate_xero_contacts(self):\n        self.logger.info('populate_xero_contacts => retrieving local DB and Xero contacts...')\n        db_contacts = self.db_ops.search_contacts()\n        self.logger.info(f'Found {len(db_contacts)} contacts locally.')\n        self.logger.info('Retrieving all contacts from Xero...')\n        try:\n            all_xero_contacts = self.xero_api.get_all_contacts()\n            self.logger.debug(f'get_all_contacts => {len(all_xero_contacts)} contacts')\n        except Exception as xe:\n            self.logger.error(f'Failed to retrieve contacts from Xero => {xe}')\n            return\n        xero_contacts_dict = {\n            c['Name'].strip().lower(): c for c in all_xero_contacts if c.get('Name')\n        }\n        for db_contact in db_contacts:"
                    },
                    {
                        "name": "validate_xero_data",
                        "args": [
                            "self",
                            "db_contact"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def validate_xero_data(self, db_contact):\n        self.logger.debug(f'Validating db_contact => {db_contact[\"name\"]}')\n        errors = []\n\n        # 1) Validate Name (still considered \"required\" in your system)\n        name = db_contact.get('name', '').strip()\n        if not name:\n            errors.append('\u2757 Missing or empty name.')\n\n        # 2) Validate Address Line 1 length\n        address_line_1 = db_contact.get('address_line_1', '')\n        if address_line_1 and len(address_line_1) > 255:\n            errors.append('\u2757 address_line_1 exceeds char limit.')\n\n        # 3) Validate Email format\n        email = db_contact.get('email', '')\n        if email and '@' not in email:\n            errors.append('\u2757 Invalid email format.')\n\n        # 4) Validate Phone length\n        phone = db_contact.get('phone', '')\n        if phone and len(phone) > 50:\n            errors.append('\u2757 Phone number exceeds character limit.')\n\n        # 5) Validate xero_id as a proper GUID\n        xero_id = (db_contact.get('xero_id') or '').strip()\n        if xero_id:\n            guid_no_dashes = xero_id.replace('-', '')\n            if len(guid_no_dashes) == 32 and re.match(r'^[0-9A-Fa-f]{32}$', guid_no_dashes):\n                # If original xero_id was missing dashes, auto-correct\n                if '-' not in xero_id:\n                    corrected = (\n                        guid_no_dashes[0:8] + '-' +\n                        guid_no_dashes[8:12] + '-' +\n                        guid_no_dashes[12:16] + '-' +\n                        guid_no_dashes[16:20] + '-' +\n                        guid_no_dashes[20:]\n                    )\n                    db_contact['xero_id'] = corrected\n                    self.logger.warning(\n                        f\"Auto-corrected XeroID from '{xero_id}' to '{corrected}' (missing dashes).\"\n                    )\n            else:\n                errors.append(\n                    f\"\u2757 Xero ID '{xero_id}' is invalid; must be 32 hex digits \"\n                    \"with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\"\n                )\n\n        return errors"
                    },
                    {
                        "name": "buffered_upsert_contact",
                        "args": [
                            "self",
                            "contact_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "validate_xero_data"
                        ],
                        "docstring": "Stage a single local 'contact_record' for eventual batch upsert in Xero.\nWe'll do the actual creation/update in 'execute_batch_upsert_contacts'\nto minimize repeated calls.",
                        "function_body": "    def buffered_upsert_contact(self, contact_record: dict):\n        \"\"\"\n        Stage a single local 'contact_record' for eventual batch upsert in Xero.\n        We'll do the actual creation/update in 'execute_batch_upsert_contacts'\n        to minimize repeated calls.\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Attempting to stage a contact for batch upsert in Xero.\")\n        contact_val_errors = self.validate_xero_data(contact_record)\n        if contact_val_errors:"
                    },
                    {
                        "name": "execute_batch_upsert_contacts",
                        "args": [
                            "self",
                            "contacts",
                            "chunk_size"
                        ],
                        "decorators": [],
                        "calls": [
                            "process_chunk"
                        ],
                        "docstring": "Executes a batched 'upsert' (create or update) of contacts in Xero.\n- Splits into create vs. update lists\n- Optionally processes in chunks if lists are large\n- Logs success/failure counts",
                        "function_body": "    def execute_batch_upsert_contacts(self, contacts: list[dict], chunk_size: int = 50) -> None:\n        \"\"\"\n        Executes a batched 'upsert' (create or update) of contacts in Xero.\n        - Splits into create vs. update lists\n        - Optionally processes in chunks if lists are large\n        - Logs success/failure counts\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Performing batched Xero contact upserts...\")\n\n        total_contacts = len(contacts)\n        if total_contacts == 0:\n            self.logger.info(\"\ud83c\udf00 No contacts provided => nothing to process.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success] No contacts upserted.\")\n            return\n\n        # Separate into create vs. update\n        create_list = []\n        update_list = []\n        for c in contacts:\n            try:\n                if c.get(\"xero_id\"):\n                    update_list.append(c)\n                else:\n                    create_list.append(c)\n            except Exception as e:\n                self.logger.error(f\"\u26d4 Error sorting contact => {c}, Error: {e}\")\n\n        self.logger.info(\n            f\"\ud83c\udf00 Split {total_contacts} staged contacts => create_list={len(create_list)}, update_list={len(update_list)}.\"\n        )\n\n        success_count = 0\n        fail_count = 0\n\n        # CREATE\n        if create_list:\n            for i in range(0, len(create_list), chunk_size):\n                subset = create_list[i : i + chunk_size]\n                chunk_success = self.process_chunk(\"create\", subset)\n                success_count += chunk_success\n                fail_count += (len(subset) - chunk_success)\n        else:\n            self.logger.info(\"\ud83c\udf00 No contacts to create in Xero.\")\n\n        # UPDATE\n        if update_list:\n            for i in range(0, len(update_list), chunk_size):\n                subset = update_list[i : i + chunk_size]\n                chunk_success = self.process_chunk(\"update\", subset)\n                success_count += chunk_success\n                fail_count += (len(subset) - chunk_success)\n        else:\n            self.logger.info(\"\ud83c\udf00 No contacts to update in Xero.\")\n\n        # Summary\n        self.logger.info(f\"\ud83c\udf00 Upsert summary => success={success_count}, fails={fail_count}, total={total_contacts}\")\n\n        status_str = \"Success\"\n        if fail_count == total_contacts:\n            status_str = \"Fail\"\n        elif fail_count > 0:\n            status_str = \"PartialFail\"\n\n        self.logger.info("
                    },
                    {
                        "name": "_convert_contact_to_xero_schema",
                        "args": [
                            "self",
                            "db_contact"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "For new contacts (no xero_id): We supply a non-empty Name + a unique AccountNumber\nFor existing contacts (has xero_id): We omit Name + AccountNumber so we don't collide or rename.",
                        "function_body": "    def _convert_contact_to_xero_schema(self, db_contact: dict) -> dict:\n        \"\"\"\n        For new contacts (no xero_id): We supply a non-empty Name + a unique AccountNumber\n        For existing contacts (has xero_id): We omit Name + AccountNumber so we don't collide or rename.\n        \"\"\"\n        xero_contact = {}\n\n        # Pull existing or missing Xero ID\n        x_id = (db_contact.get(\"xero_id\") or \"\").strip()\n        if x_id:\n            xero_contact[\"ContactID\"] = x_id\n\n        # If no xero_id => This is a brand-new contact => must send Name (non-empty).\n        # Also ensure AccountNumber is unique if used.\n        if not x_id:\n            raw_name = (db_contact.get(\"name\") or \"\").strip()\n            if not raw_name:\n                raw_name = \"Unnamed Contact\"\n            xero_contact[\"Name\"] = raw_name\n\n            # If you still want to store something in AccountNumber, ensure it's unique\n            # so \"Account number already exists\" doesn't blow up your batch.\n            vendor_status = (db_contact.get(\"vendor_status\") or \"\").strip()\n            vendor_type = (db_contact.get(\"vendor_type\") or \"\").strip()\n            local_id = str(db_contact.get(\"id\") or \"\")  # or \"pulse_id\"\n            if vendor_status or vendor_type or local_id:\n                # e.g. \"VENDOR-PENDING-4611\" => ensures uniqueness\n                xero_contact[\"AccountNumber\"] = f\"{vendor_type}-{vendor_status}-{local_id}\"\n\n        # If xero_id is present => partial update => omit \"Name\" & \"AccountNumber\"\n        # So we avoid duplicate name or \"Account number already exists.\"\n\n        # Fields that are safe to update whether new or existing:\n        email = (db_contact.get(\"email\") or \"\").strip()\n        if email:\n            xero_contact[\"EmailAddress\"] = email\n\n        phone = (db_contact.get(\"phone\") or \"\").strip()\n        if phone:\n            xero_contact[\"Phones\"] = [\n                {\"PhoneType\": \"DEFAULT\", \"PhoneNumber\": phone}\n            ]\n\n        # Minimal \"Addresses\" structure\n        xero_contact[\"Addresses\"] = [{\"AddressType\": \"STREET\"}]\n        if db_contact.get(\"address_line_1\"):\n            xero_contact[\"Addresses\"][0][\"AddressLine1\"] = db_contact[\"address_line_1\"].strip()\n        if db_contact.get(\"address_line_2\"):\n            xero_contact[\"Addresses\"][0][\"AddressLine2\"] = db_contact[\"address_line_2\"].strip()\n        if db_contact.get(\"city\"):\n            xero_contact[\"Addresses\"][0][\"City\"] = db_contact[\"city\"].strip()\n        if db_contact.get(\"region\"):\n            xero_contact[\"Addresses\"][0][\"Region\"] = db_contact[\"region\"].strip()\n        if db_contact.get(\"zip\"):\n            xero_contact[\"Addresses\"][0][\"PostalCode\"] = db_contact[\"zip\"].strip()\n        if db_contact.get(\"country\"):\n            xero_contact[\"Addresses\"][0][\"Country\"] = db_contact[\"country\"].strip()\n\n        # If needed, store a tax_number\n        tax_num = (db_contact.get(\"tax_number\") or \"\").strip()\n        if tax_num:\n            xero_contact[\"TaxNumber\"] = tax_num\n\n        return xero_contact"
                    },
                    {
                        "name": "process_chunk",
                        "args": [
                            "self",
                            "mode",
                            "data_chunk"
                        ],
                        "decorators": [],
                        "calls": [
                            "_convert_contact_to_xero_schema",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "mode='create' => xero.contacts.put(...) (requires Name, unique AccountNumber)\nmode='update' => xero.contacts.save(...) partial update, skipping Name + AccountNumber",
                        "function_body": "    def process_chunk(self, mode: str, data_chunk: list[dict]) -> int:\n        \"\"\"\n        mode='create' => xero.contacts.put(...) (requires Name, unique AccountNumber)\n        mode='update' => xero.contacts.save(...) partial update, skipping Name + AccountNumber\n        \"\"\"\n        # Transform each contact from your DB format -> Xero format\n        xero_contacts = [self._convert_contact_to_xero_schema(c) for c in data_chunk]\n\n        chunk_success = 0\n        self.logger.info(\n            f\"\ud83c\udf00 Sending {len(xero_contacts)} contacts to Xero in one '{mode}' batch call...\"\n        )\n\n        try:\n            if mode == \"create\":\n                result = self.xero_api._retry_on_unauthorized(\n                    self.xero_api.xero.contacts.put,\n                    xero_contacts\n                )\n            else:  # mode == 'update'\n                result = self.xero_api._retry_on_unauthorized(\n                    self.xero_api.xero.contacts.save,\n                    xero_contacts\n                )\n\n            if result:\n                chunk_success = len(result)\n                self.logger.info(\n                    f\"\ud83c\udf00 Successfully completed '{mode}' => {chunk_success} upserted.\"\n                )\n        except Exception as e:\n            self.logger.error(f\"\u26d4 Exception during '{mode}' batch => {e}\")\n\n        return chunk_success"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "xero_services",
                "value": "XeroServices()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_webhook_handler.py",
        "functions": [
            {
                "name": "dropbox_webhook",
                "args": [],
                "decorators": [
                    "dropbox_blueprint.route('/')"
                ],
                "calls": [
                    "handle_dropbox_event"
                ],
                "docstring": null,
                "function_body": "def dropbox_webhook():\n    if request.method == 'GET':"
            }
        ],
        "classes": [
            {
                "name": "DropboxWebhookHandler",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "handle_dropbox_event",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [
                            "process_event_data"
                        ],
                        "docstring": "Handle incoming Dropbox webhook event.",
                        "function_body": "    def handle_dropbox_event(self, event):\n        \"\"\"Handle incoming Dropbox webhook event.\"\"\"\n        self.logger.info('[handle_dropbox_event] - Received Dropbox event.')\n        self.process_event_data(event)\n        return (jsonify({'message': 'Dropbox event processed'}), 200)"
                    },
                    {
                        "name": "process_event_data",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "determine_file_type",
                            "list_folder_changes",
                            "load_cursor",
                            "list_root_folder",
                            "save_cursor"
                        ],
                        "docstring": "Processes the event data received from Dropbox webhook.\nFetches the latest changes since the last cursor,\ncategorizes them by folder/file and event type (added, deleted),\nlogs the changes, and ensures duplicate events with the same cursor are ignored.",
                        "function_body": "    def process_event_data(self, event_data):\n        \"\"\"\n        Processes the event data received from Dropbox webhook.\n        Fetches the latest changes since the last cursor,\n        categorizes them by folder/file and event type (added, deleted),\n        logs the changes, and ensures duplicate events with the same cursor are ignored.\n        \"\"\"\n        self.logger.info('[process_event_data] - Starting to process event data...')\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('dropbox')"
            },
            {
                "name": "dropbox_blueprint",
                "value": "Blueprint('files_dropbox', __name__)"
            },
            {
                "name": "dropbox_webhook_handler",
                "value": "DropboxWebhookHandler()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_service.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Initializes the DropboxService singleton, setting up logging, external\nAPIs, and the new DatabaseOperations object for DB interactions.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        Initializes the DropboxService singleton, setting up logging, external\n        APIs, and the new DatabaseOperations object for DB interactions.\n        \"\"\"\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "determine_file_type",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [
                            "process_budget",
                            "po_log_orchestrator",
                            "process_invoice",
                            "process_receipt",
                            "process_tax_form",
                            "get_last_path_component_generic"
                        ],
                        "docstring": "Determine the file type by matching patterns in its name,\nthen route the file to the appropriate process_* handler.",
                        "function_body": "    def determine_file_type(self, path: str):\n        \"\"\"\n        Determine the file type by matching patterns in its name,\n        then route the file to the appropriate process_* handler.\n        \"\"\"\n        file_component = self.dropbox_util.get_last_path_component_generic(path)\n        self.logger.info(f'[determine_file_type] - \ud83d\udd0d Evaluating dropbox file: {file_component}')\n        filename = os.path.basename(path)\n\n        try:"
                    },
                    {
                        "name": "po_log_orchestrator",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_project_number",
                            "add_po_data_to_db",
                            "create_po_log",
                            "download_file_from_dropbox",
                            "extract_data_from_po_log"
                        ],
                        "docstring": "Process a PO log file from Dropbox, parse it, then store the results in the DB.\nIncludes adding Contacts, PurchaseOrders, and DetailItems.",
                        "function_body": "    def po_log_orchestrator(self, path: str = None):\n        \"\"\"\n        Process a PO log file from Dropbox, parse it, then store the results in the DB.\n        Includes adding Contacts, PurchaseOrders, and DetailItems.\n        \"\"\"\n        if path:\n            self.logger.info(f'\ud83d\udcdd Received a PO Log file from Dropbox: {path}')\n        else:\n            self.logger.warning(f'\ud83d\udcdd TEST PO LOG - GRABBING LAST FILE FROM TEMP FOLDER')\n\n        temp_file_path = f'./temp_files/{os.path.basename(path)}'\n        project_number = self.extract_project_number(temp_file_path)\n        self.PROJECT_NUMBER = project_number\n\n        self.database_util.create_po_log(\n            project_number=project_number,\n            db_path=path,\n            status='STARTED'\n        )\n\n        if path:\n            self.logger.info('\ud83d\udee0 Attempting direct download from Dropbox...')\n            if not self.download_file_from_dropbox(path, temp_file_path):\n                return\n\n        main_items, detail_items, contacts = self.extract_data_from_po_log(temp_file_path, project_number)\n        self.logger.info('[po_log_orchestrator] - \ud83d\udd27 Passing parsed PO log data to DB aggregator...')\n        self.add_po_data_to_db(main_items, detail_items, contacts, project_number)\n        self.logger.info('[po_log_orchestrator] - \u2705 PO Log orchestration complete!')"
                    },
                    {
                        "name": "extract_data_from_po_log",
                        "args": [
                            "self",
                            "temp_file_path",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse the local PO log file to extract main_items, detail_items, and contacts.",
                        "function_body": "    def extract_data_from_po_log(self, temp_file_path: str, project_number: str):\n        \"\"\"\n        Parse the local PO log file to extract main_items, detail_items, and contacts.\n        \"\"\"\n        self.logger.info(\n            f'[extract_data_from_po_log] - \ud83d\udd0e Parsing PO log for project {project_number} at {temp_file_path}'\n        )\n        try:"
                    },
                    {
                        "name": "add_po_data_to_db",
                        "args": [
                            "self",
                            "main_items",
                            "detail_items",
                            "contacts",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_find_or_create_contact_in_db",
                            "update_purchase_order_by_keys",
                            "update_detail_item_by_keys",
                            "create_detail_item_by_keys",
                            "search_purchase_orders",
                            "create_purchase_order_by_keys",
                            "search_detail_items",
                            "search_contacts"
                        ],
                        "docstring": "\ud83d\ude80 DB Processing Method\n----------------------\n*New Batch Logic*:\n1) Convert project_number to int.\n2) Fetch existing POs for that project_number in one shot.\n3) For each main_item, decide if it's new or existing in DB; update or create.\n4) Fetch all existing DetailItems for that project_number.\n5) For each detail_item, decide if new or existing; link to DB.\n6) Link contact if needed (fuzzy or direct create).",
                        "function_body": "    def add_po_data_to_db(self, main_items, detail_items, contacts, project_number: str):\n        \"\"\"\n        \ud83d\ude80 DB Processing Method\n        ----------------------\n        *New Batch Logic*:\n        1) Convert project_number to int.\n        2) Fetch existing POs for that project_number in one shot.\n        3) For each main_item, decide if it's new or existing in DB; update or create.\n        4) Fetch all existing DetailItems for that project_number.\n        5) For each detail_item, decide if new or existing; link to DB.\n        6) Link contact if needed (fuzzy or direct create).\n        \"\"\"\n        self.logger.info(\n            f' \ud83d\ude80 Kicking off aggregator for PO log data, project_number={project_number}'\n        )\n        pn_int = int(project_number)\n\n        # Preload all DB Contacts (for fuzzy match)\n        all_db_contacts = self.database_util.search_contacts() or []\n        self.logger.info(' \ud83e\udd1d Loaded existing contacts from the DB.')\n\n        # Fetch existing PurchaseOrders for this project_number\n        existing_pos = self.database_util.search_purchase_orders(column_names=['project_number'], values=[pn_int])\n        if existing_pos is None:\n            existing_pos = []\n        elif isinstance(existing_pos, dict):\n            existing_pos = [existing_pos]\n\n        pos_by_number = {po['po_number']: po for po in existing_pos}\n        self.logger.info(\n            f' \ud83d\udcc4 Found {len(pos_by_number)} existing POs in DB for project {pn_int}.'\n        )\n\n        # --- Process main_items => PurchaseOrders\n        for main_item in main_items:\n            po_number = int(main_item.get('po_number', 0) or 0)\n            vendor_name = main_item.get('vendor_name', '')\n            description = main_item.get('description', '')\n            po_type = main_item.get('po_type', 'INV')\n\n            self.logger.info(f\" \ud83d\udcdd Checking PO {po_number} for existence in DB...\")\n            existing_po = pos_by_number.get(po_number)\n\n            if existing_po:\n                changed = False\n                if (existing_po.get('description') or '') != description:\n                    changed = True\n                if (existing_po.get('po_type') or '') != po_type:\n                    changed = True\n                if (existing_po.get('vendor_name') or '') != vendor_name:\n                    changed = True\n                    contact_id = self._find_or_create_contact_in_db(vendor_name, all_db_contacts)\n                else:\n                    contact_id = existing_po.get('contact_id')\n\n                if changed:\n                    self.logger.info(f\"\ud83d\udd04 Updating existing PO => {po_number} with new data from aggregator.\")\n                    updated_po = self.database_util.update_purchase_order_by_keys(\n                        project_number=pn_int,\n                        po_number=po_number,\n                        vendor_name=vendor_name,\n                        description=description,\n                        po_type=po_type,\n                        contact_id=contact_id\n                    )\n                    if updated_po:\n                        pos_by_number[po_number] = updated_po\n                else:\n                    self.logger.debug(f\"\u23ed No changes detected for existing PO {po_number}; skipping update.\")\n            else:\n                self.logger.info(f\"\ud83c\udd95 Creating new PO => po_number={po_number}, project={pn_int}\")\n                contact_id = self._find_or_create_contact_in_db(vendor_name, all_db_contacts)\n                new_po = self.database_util.create_purchase_order_by_keys(\n                    project_number=pn_int,\n                    po_number=po_number,\n                    description=description,\n                    vendor_name=vendor_name,\n                    po_type=po_type,\n                    contact_id=contact_id\n                )\n                if new_po:\n                    pos_by_number[po_number] = new_po\n\n        # --- Process detail_items => DetailItems\n        existing_details = self.database_util.search_detail_items(['project_number'], [pn_int])\n        if existing_details is None:\n            existing_details = []\n        elif isinstance(existing_details, dict):\n            existing_details = [existing_details]\n\n        detail_dict = {}\n        for d in existing_details:\n            key = (d['po_number'], d['detail_number'], d.get('line_number', 1))\n            detail_dict[key] = d\n        self.logger.info(\n            f' \ud83e\uddf1 Found {len(detail_dict)} existing detail items for project {pn_int}.'\n        )\n\n        for detail_entry in detail_items:\n            di_po_number = int(detail_entry.get('po_number', 0) or 0)\n            di_detail_number = int(detail_entry.get('detail_item_id', 0) or 0)\n            di_line_number = int(detail_entry.get('line_number', 1) or 1)\n            key = (di_po_number, di_detail_number, di_line_number)\n\n            self.logger.debug(f\"\ud83d\udd0d Checking detail item => {key}\")\n            existing_di = detail_dict.get(key)\n\n            if existing_di:\n                changed = False\n                if (existing_di.get('vendor') or '') != detail_entry.get('vendor_name', ''):\n                    changed = True\n                if float(existing_di.get('sub_total', 0.0)) != float(detail_entry.get('sub_total', 0.0)):\n                    changed = True\n\n                if changed:\n                    self.logger.info(f\"\ud83d\udd04 Updating existing DetailItem => {key}\")\n                    updated_di = self.database_util.update_detail_item_by_keys(\n                        project_number=pn_int,\n                        po_number=di_po_number,\n                        detail_number=di_detail_number,\n                        line_number=di_line_number,\n                        vendor=detail_entry.get(\"vendor\"),\n                        transaction_date=detail_entry.get(\"date\"),\n                        due_date=detail_entry.get(\"due date\"),\n                        quantity=detail_entry.get(\"quantity\"),\n                        rate=detail_entry.get(\"rate\"),\n                        detail_entry=detail_entry.get(\"description\"),\n                        state=detail_entry.get(\"state\"),\n                        account_code=detail_entry.get(\"account\"),\n                        payment_type=detail_entry.get('payment_type'),\n                        ot=detail_entry.get(\"ot\"),\n                        fringes=detail_entry.get(\"fringes\"),\n                    )\n                    if updated_di:\n                        detail_dict[key] = updated_di\n                else:\n                    self.logger.debug(f\"\u23ed No changes for DetailItem => {key}. Skipping update.\")\n            else:\n                self.logger.info(f\"\ud83c\udd95 Creating new DetailItem => {key}\")\n                created_di = self.database_util.create_detail_item_by_keys(\n                    project_number=pn_int,\n                    po_number=di_po_number,\n                    detail_number=di_detail_number,\n                    line_number=di_line_number,\n                    vendor=detail_entry.get(\"vendor\"),\n                    transaction_date=detail_entry.get(\"date\"),\n                    due_date=detail_entry.get(\"due date\"),\n                    quantity=detail_entry.get(\"quantity\"),\n                    rate=detail_entry.get(\"rate\"),\n                    detail_entry=detail_entry.get(\"description\"),\n                    state=detail_entry.get(\"state\"),\n                    account_code=detail_entry.get(\"account\"),\n                    payment_type=detail_entry.get('payment_type'),\n                    ot=detail_entry.get(\"ot\"),\n                    fringes=detail_entry.get(\"fringes\"),\n                )\n                if created_di:\n                    detail_dict[key] = created_di\n\n        self.logger.info(\" \u2705 Finished processing aggregator data for main_items & detail_items.\")"
                    },
                    {
                        "name": "process_budget",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handle .mbb (Showbiz) budgets from Dropbox.\n(Original logic remains here.)",
                        "function_body": "    def process_budget(self, dropbox_path: str):\n        \"\"\"\n        Handle .mbb (Showbiz) budgets from Dropbox.\n        (Original logic remains here.)\n        \"\"\"\n        self.logger.info(f'[process_budget] - \ud83d\udcbc Handling Showbiz budget file from dropbox: {dropbox_path}')\n        filename = os.path.basename(dropbox_path)\n\n        try:\n            # Basic checks on file extension\n            if not filename.endswith('.mbb') or filename.endswith('.mbb.lck'):\n                self.logger.info('[process_budget] - \u274c Invalid .mbb or lock file encountered. Skipping.')\n                return\n        except Exception:\n            self.logger.exception('[process_budget] - \ud83d\udca5 Error checking the .mbb extension.', exc_info=True)\n            return\n\n        try:\n            segments = dropbox_path.strip('/').split('/')\n            if len(segments) < 4:\n                self.logger.info('[process_budget] - \u274c Folder structure is too short to be recognized as a budget path.')\n                return\n\n            project_folder = segments[0]\n            budget_folder = segments[1]\n            phase_folder = segments[2]\n\n            if budget_folder != '5. Budget' or phase_folder not in ['1.2 Working', '1.3 Actuals']:\n                self.logger.info('[process_budget] - \u274c Budget file not in a recognized \"5. Budget\" folder.')\n                return\n\n            project_number_match = re.match(r'^\\d{4}', project_folder)\n            if not project_number_match:\n                self.logger.info(\"[process_budget] - \u274c Could not derive project number from budget file path.\")\n                return\n            project_number = project_number_match.group()\n            self.logger.info(f'[process_budget] - \ud83d\udd11 Found project folder reference: {project_number}')\n        except Exception:\n            self.logger.exception('[process_budget] - \ud83d\udca5 Error parsing budget folder.', exc_info=True)\n            return\n\n        try:\n            budget_root = '/'.join(segments[0:3])\n            po_logs_path = f'/{budget_root}/1.5 PO Logs'\n            self.logger.info(f'[process_budget] - \ud83d\uddc2 Potential PO Logs reference path: {po_logs_path}')\n        except Exception:\n            self.logger.exception('[process_budget] - \ud83d\udca5 Could not form PO Logs path.', exc_info=True)\n            return\n\n        import requests\n        server_url = 'http://localhost:5004/enqueue'\n        self.logger.info('[process_budget] - \ud83d\udda8 Sending request to external ShowbizPoLogPrinter service...')\n\n        try:\n            response = requests.post(\n                server_url, \n                json={'project_number': project_number, 'file_path': dropbox_path},\n                timeout=10\n            )\n            if response.status_code == 200:\n                job_id = response.json().get('job_id')\n                self.logger.info(f'[process_budget] - \ud83c\udf89 External service triggered successfully. job_id: {job_id}')\n            else:\n                self.logger.error(\n                    f'[process_budget] - \u274c External printer service error: {response.status_code}, {response.text}'\n                )\n                return\n        except Exception:\n            self.logger.exception(\n                '[process_budget] - \ud83d\udca5 Connection error with external ShowbizPoLogPrinter.',\n                exc_info=True\n            )\n            return\n\n        self.logger.info('[process_budget] - \u2705 Budget file processing complete. External PO log printing triggered!')"
                    },
                    {
                        "name": "process_invoice",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_file_link",
                            "search_invoice_by_keys",
                            "update_invoice",
                            "download_file_from_dropbox",
                            "create_invoice",
                            "extract_text",
                            "cleanup_temp_file",
                            "extract_info_with_openai"
                        ],
                        "docstring": "Insert or update an 'invoice' record in the DB (plus a share link).\nOther logic (detail item linking, sum checks, etc.) is handled by triggers.",
                        "function_body": "    def process_invoice(self, dropbox_path: str):\n        \"\"\"\n        Insert or update an 'invoice' record in the DB (plus a share link).\n        Other logic (detail item linking, sum checks, etc.) is handled by triggers.\n        \"\"\"\n        self.logger.info(f'[process_invoice] - \ud83d\udcc4 Recognized invoice file from dropbox: {dropbox_path}')\n        filename = os.path.basename(dropbox_path)\n\n        try:\n            match = re.match(r'^(\\d{4})_(\\d{1,2})(?:_(\\d{1,2}))?', filename)\n            if not match:\n                self.logger.warning(\n                    f\"[process_invoice] - \u26a0\ufe0f Invoice filename '{filename}' not recognized by the pattern. Skipping.\"\n                )\n                return\n\n            project_number_str = match.group(1)\n            po_number_str = match.group(2)\n            invoice_number_str = match.group(3) or '1'\n            project_number = int(project_number_str)\n            po_number = int(po_number_str)\n            invoice_number = int(invoice_number_str)\n            self.logger.info(\n                f'[process_invoice] - \ud83e\udde9 Parsed invoice => project={project_number}, po={po_number}, invoice={invoice_number}'\n            )\n        except Exception:\n            self.logger.exception(\n                f\"[process_invoice] - \ud83d\udca5 Error parsing invoice filename '{filename}'.\",\n                exc_info=True\n            )\n            return\n\n        try:\n            file_share_link = self.dropbox_util.get_file_link(dropbox_path)\n            self.logger.info(f'[process_invoice] - \ud83d\udd17 Dropbox share link obtained: {file_share_link}')\n        except Exception:\n            self.logger.exception('[process_invoice] - \ud83d\udca5 Error getting share link for invoice.', exc_info=True)\n            file_share_link = None\n\n        temp_file_path = f'./temp_files/{filename}'\n        self.logger.info('[process_invoice] - \ud83d\ude80 Attempting to download the invoice from dropbox...')\n        if not self.download_file_from_dropbox(dropbox_path, temp_file_path):\n            self.logger.error(\n                f'[process_invoice] - \u274c Could not download invoice from dropbox path: {dropbox_path}'\n            )\n            return\n\n        transaction_date, term, total = None, 30, 0.0\n        try:\n            self.logger.info('[process_invoice] - \ud83d\udd0e Extracting invoice details using OCR + OpenAI analysis...')\n            extracted_text = self.ocr_service.extract_text(temp_file_path)\n            (info, err) = self.ocr_service.extract_info_with_openai(extracted_text)\n\n            if err or not info:\n                self.logger.warning(f'[process_invoice] - \u274c OCR/AI extraction failed. Using default fallback. Error: {err}')\n            else:\n                # Attempt to parse date, total, term\n                date_str = info.get('invoice_date')\n                if date_str:\n                    try:\n                        transaction_date = datetime.strptime(date_str, '%Y-%m-%d')\n                    except (ValueError, TypeError):\n                        transaction_date = None\n\n                total_str = info.get('total_amount')\n                try:\n                    total = float(total_str) if total_str else 0.0\n                except (ValueError, TypeError):\n                    total = 0.0\n\n                term_str = info.get('payment_term')\n                if term_str:\n                    digits_only = re.sub('[^0-9]', '', term_str)\n                    try:\n                        t_val = int(digits_only) if digits_only else 30\n                        if 7 <= t_val <= 60:\n                            term = t_val\n                    except Exception:\n                        term = 30\n        except Exception:\n            self.logger.exception('[process_invoice] - \ud83d\udca5 Error during OCR/AI extraction.', exc_info=True)\n\n        try:\n            self.logger.info(\n                f'[process_invoice] - \ud83e\udd16 Sending invoice references (#{invoice_number}) to DB aggregator...'\n            )\n            existing_invoice = self.database_util.search_invoice_by_keys(\n                project_number=str(project_number),\n                po_number=str(po_number),\n                invoice_number=str(invoice_number)\n            )\n\n            if existing_invoice is None:\n                self.logger.info(f'[process_invoice] - \ud83c\udd95 Creating a new invoice record: #{invoice_number}')\n                new_invoice = self.database_util.create_invoice(\n                    project_number=project_number,\n                    po_number=po_number,\n                    invoice_number=invoice_number,\n                    transaction_date=transaction_date,\n                    term=term,\n                    total=total,\n                    file_link=file_share_link\n                )\n                invoice_id = new_invoice['id'] if new_invoice else None\n            else:\n                if isinstance(existing_invoice, list):\n                    invoice_id = existing_invoice[0]['id']\n                else:\n                    invoice_id = existing_invoice['id']\n\n                self.logger.info(f'[process_invoice] - \ud83d\udd04 Updating invoice record: #{invoice_number}')\n                self.database_util.update_invoice(\n                    invoice_id=invoice_id,\n                    transaction_date=transaction_date,\n                    term=term,\n                    total=total,\n                    file_link=file_share_link\n                )\n        except Exception:\n            self.logger.exception(\n                f'[process_invoice] - \ud83d\udca5 Error updating invoice #{invoice_number} in DB.',\n                exc_info=True\n            )\n            self.cleanup_temp_file(temp_file_path)\n            return\n\n        self.cleanup_temp_file(temp_file_path)\n        self.logger.info(f'[process_invoice] - \u2705 Finished invoice processing for dropbox file: {dropbox_path}')"
                    },
                    {
                        "name": "process_tax_form",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Stub function for processing a tax form from Dropbox.",
                        "function_body": "    def process_tax_form(self, dropbox_path: str):\n        \"\"\"\n        Stub function for processing a tax form from Dropbox.\n        \"\"\"\n        self.logger.info(f'[process_tax_form] - \ud83d\uddc2 Recognized a tax form file in dropbox: {dropbox_path}')\n        # Could add more specific handling here if desired\n        pass"
                    },
                    {
                        "name": "process_receipt",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_receipt_by_keys",
                            "create_receipt",
                            "get_file_link",
                            "download_file_from_dropbox",
                            "update_detail_item_by_keys",
                            "_extract_text_from_pdf",
                            "search_receipts",
                            "extract_receipt_info_with_openai",
                            "search_detail_item_by_keys",
                            "cleanup_temp_file",
                            "_extract_text_via_ocr",
                            "_extract_text_from_pdf_with_ocr"
                        ],
                        "docstring": "\ud83e\uddfe process_receipt\n-----------------\n1) Parse file name (project_number, po_number, detail_number, vendor_name).\n2) Download the receipt file from Dropbox.\n3) If PDF, try text extraction via PyPDF2. If that fails (or not a PDF), do OCR.\n4) Use OCRService's 'extract_receipt_info_with_openai' to parse total, date, description.\n5) Generate file link in Dropbox.\n6) Create or update the 'receipt' table, linking to the appropriate detail item.\n7) Update the corresponding subitem in Monday with the link.\n8) After creation/update, link `receipt_id` to the relevant detail item.",
                        "function_body": "    def process_receipt(self, dropbox_path: str):\n        \"\"\"\n        \ud83e\uddfe process_receipt\n        -----------------\n        1) Parse file name (project_number, po_number, detail_number, vendor_name).\n        2) Download the receipt file from Dropbox.\n        3) If PDF, try text extraction via PyPDF2. If that fails (or not a PDF), do OCR.\n        4) Use OCRService's 'extract_receipt_info_with_openai' to parse total, date, description.\n        5) Generate file link in Dropbox.\n        6) Create or update the 'receipt' table, linking to the appropriate detail item.\n        7) Update the corresponding subitem in Monday with the link.\n        8) After creation/update, link `receipt_id` to the relevant detail item.\n        \"\"\"\n        self.logger.info(f'[process_receipt] - \ud83e\uddfe Recognized a receipt file from dropbox: {dropbox_path}')\n        temp_file_path = f'./temp_files/{os.path.basename(dropbox_path)}'\n        filename = os.path.basename(dropbox_path)\n\n        is_petty_cash = (\n            '3. Petty Cash' in dropbox_path \n            or 'Crew PC Folders' in dropbox_path \n            or filename.startswith('PC_')\n        )\n        pattern = r'^(?:PC_)?(\\d{4})_(\\d{2})_(\\d{2})\\s+(.*?)\\s+Receipt\\.(pdf|jpe?g|png)$'\n        match = re.match(pattern, filename, re.IGNORECASE)\n\n        if not match:\n            self.logger.warning(\n                f\"[process_receipt] - \u274c Receipt filename '{filename}' doesn't match a recognized pattern. Skipping.\"\n            )\n            return\n\n        project_number_str = match.group(1)\n        group2_str = match.group(2).lstrip('0')\n        group3_str = match.group(3).lstrip('0')\n        vendor_name = match.group(4)\n        file_ext = match.group(5).lower()\n\n        if is_petty_cash:\n            po_number_str = '1'\n            detail_item_str = group2_str\n            line_number_str = group3_str\n        else:\n            po_number_str = group2_str\n            detail_item_str = group3_str\n            line_number_str = '1'\n\n        project_number = int(project_number_str)\n        po_number = int(po_number_str)\n        detail_number = int(detail_item_str)\n        line_number_number = int(line_number_str)\n\n        self.logger.info('[process_receipt] - \ud83d\ude80 Attempting to download the receipt file from dropbox...')\n        success = self.download_file_from_dropbox(dropbox_path, temp_file_path)\n        if not success:\n            self.logger.warning(f'[process_receipt] - \ud83d\uded1 Download failure for receipt: {filename}')\n            return\n\n        try:"
                    },
                    {
                        "name": "find_or_create_vendor_contact",
                        "args": [
                            "self",
                            "po_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_contacts",
                            "find_contact_close_match",
                            "create_contact"
                        ],
                        "docstring": "If the PO record has no contact_id or vendor_name, attempt to find\nan existing contact by vendor_name. If none found, create one.\nReturns contact_id or None.",
                        "function_body": "    def find_or_create_vendor_contact(self, po_record: dict):\n        \"\"\"\n        If the PO record has no contact_id or vendor_name, attempt to find\n        an existing contact by vendor_name. If none found, create one.\n        Returns contact_id or None.\n        \"\"\"\n        vendor_name = (po_record.get('vendor_name') or '').strip()\n        if not vendor_name:\n            self.logger.warning(\"\ud83d\udd0e No vendor_name on PO record. Skipping contact creation.\")\n            return None\n\n        self.logger.info(f\"\ud83c\udf10 Looking up or creating contact for vendor '{vendor_name}'...\")\n        all_contacts = self.database_util.search_contacts()\n        if not all_contacts:\n            all_contacts = []\n\n        fuzzy_matches = self.database_util.find_contact_close_match(vendor_name, all_contacts)\n        if fuzzy_matches:"
                    },
                    {
                        "name": "_find_or_create_contact_in_db",
                        "args": [
                            "self",
                            "vendor_name",
                            "all_db_contacts"
                        ],
                        "decorators": [],
                        "calls": [
                            "find_contact_close_match",
                            "create_contact"
                        ],
                        "docstring": "Helper method to do a quick fuzzy search for an existing contact,\nor create a new contact if no match. Returns contact_id or None.",
                        "function_body": "    def _find_or_create_contact_in_db(self, vendor_name: str, all_db_contacts: list) -> Optional[int]:\n        \"\"\"\n        Helper method to do a quick fuzzy search for an existing contact,\n        or create a new contact if no match. Returns contact_id or None.\n        \"\"\"\n        if not vendor_name:\n            return None\n\n        fuzzy_matches = self.database_util.find_contact_close_match(vendor_name, all_db_contacts)\n        if fuzzy_matches:"
                    },
                    {
                        "name": "match_receipt_for_detail",
                        "args": [
                            "self",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_receipt_by_keys"
                        ],
                        "docstring": "Attempt to match a receipt in DB to see if there's a total matching detail_item['sub_total'].\nReturn a dict like {'total': float, 'path': str} if found, else None.",
                        "function_body": "    def match_receipt_for_detail(self, detail_item: dict):\n        \"\"\"\n        Attempt to match a receipt in DB to see if there's a total matching detail_item['sub_total'].\n        Return a dict like {'total': float, 'path': str} if found, else None.\n        \"\"\"\n        sub_total = float(detail_item.get('sub_total') or 0.0)\n        project_number = detail_item.get('project_number')\n        po_number = detail_item.get('po_number')\n        detail_number = detail_item.get('detail_number')\n        line_number = detail_item.get('line_number')\n\n        try:"
                    },
                    {
                        "name": "find_po_folder_link",
                        "args": [
                            "self",
                            "po_record"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Check Dropbox for a folder associated with this PO, e.g. by project_number + po_number.\nReturn a shareable link or None if not found.",
                        "function_body": "    def find_po_folder_link(self, po_record: dict):\n        \"\"\"\n        Check Dropbox for a folder associated with this PO, e.g. by project_number + po_number.\n        Return a shareable link or None if not found.\n        \"\"\"\n        project_number = po_record.get('project_number')\n        po_number = po_record.get('po_number')\n        if not project_number or not po_number:\n            self.logger.warning(\"\ud83d\uddc2 Missing project_number or po_number => cannot find PO folder link.\")\n            return None\n\n        # Simulated logic for demonstration\n        simulated_link = f\"https://www.dropbox.com/sh/example_{project_number}_{po_number}\"\n        self.logger.info(f\"\ud83d\udd17 Simulated folder link => {simulated_link}\")\n        return simulated_link"
                    },
                    {
                        "name": "download_file_from_dropbox",
                        "args": [
                            "self",
                            "path",
                            "temp_file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Download a file from Dropbox to a local temp_file_path.",
                        "function_body": "    def download_file_from_dropbox(self, path: str, temp_file_path: str) -> bool:\n        \"\"\"\n        Download a file from Dropbox to a local temp_file_path.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "cleanup_temp_file",
                        "args": [
                            "self",
                            "temp_file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Attempt to remove a temporary file.",
                        "function_body": "    def cleanup_temp_file(self, temp_file_path: str):\n        \"\"\"\n        Attempt to remove a temporary file.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "extract_project_number",
                        "args": [
                            "self",
                            "file_name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Extract the first 4-digit sequence from a file name\nto interpret as the project number.",
                        "function_body": "    def extract_project_number(self, file_name: str) -> str:\n        \"\"\"\n        Extract the first 4-digit sequence from a file name\n        to interpret as the project number.\n        \"\"\"\n        digit_sequences = re.findall(r'\\d+', file_name)\n        if not digit_sequences:\n            raise ValueError(f\"\u2757 No digits found in file name: '{file_name}' \u2757\")\n\n        all_digits = ''.join(digit_sequences)\n        if len(all_digits) < 4:\n            raise ValueError(\n                f\"\u2757 File name '{file_name}' does not contain at least four digits for project_id. \u2757\"\n            )\n        project_number = all_digits[:4]\n        return project_number"
                    },
                    {
                        "name": "_extract_text_from_pdf",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_extract_text_via_ocr",
                            "extract_text"
                        ],
                        "docstring": "Attempt direct text extraction with PyPDF2, then fallback to PyMuPDF-based\nimage extraction if minimal text is found.",
                        "function_body": "    def _extract_text_from_pdf(self, file_data: bytes) -> str:\n        \"\"\"\n        Attempt direct text extraction with PyPDF2, then fallback to PyMuPDF-based\n        image extraction if minimal text is found.\n        \"\"\"\n        import PyPDF2\n        import fitz\n        from io import BytesIO\n        from PIL import Image\n        Image.MAX_IMAGE_PIXELS = 200000000\n\n        self.logger.debug('[_extract_text_from_pdf] - Trying PyPDF2 direct extraction...')\n        extracted_text = ''\n        try:"
                    },
                    {
                        "name": "_extract_text_from_pdf_with_ocr",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_extract_text_via_ocr"
                        ],
                        "docstring": "A direct OCR approach if PyPDF2 text extraction yields nothing.\nReuses _extract_text_via_ocr for convenience.",
                        "function_body": "    def _extract_text_from_pdf_with_ocr(self, file_data: bytes) -> str:\n        \"\"\"\n        A direct OCR approach if PyPDF2 text extraction yields nothing.\n        Reuses _extract_text_via_ocr for convenience.\n        \"\"\"\n        return self._extract_text_via_ocr(file_data)"
                    },
                    {
                        "name": "_extract_text_via_ocr",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_receipt"
                        ],
                        "docstring": "Use the OCRService to extract text from the provided file data.",
                        "function_body": "    def _extract_text_via_ocr(self, file_data: bytes) -> str:\n        \"\"\"\n        Use the OCRService to extract text from the provided file data.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "folder_tax_conact_trigger",
                        "args": [
                            "self",
                            "fut"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_po_tax_form_links",
                            "create_pos_in_monday",
                            "update_po_folder_link"
                        ],
                        "docstring": "Callback for DB process completion. Possibly triggers Monday or Dropbox tasks next.",
                        "function_body": "    def folder_tax_conact_trigger(self, fut):\n        \"\"\"\n        Callback for DB process completion. Possibly triggers Monday or Dropbox tasks next.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "update_po_folder_link",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_project_po_folders_with_link",
                            "update_purchase_order",
                            "search_purchase_order_by_keys"
                        ],
                        "docstring": "Check and update the dropbox folder references for the specified PO.",
                        "function_body": "    def update_po_folder_link(self, project_number, po_number):\n        \"\"\"\n        Check and update the dropbox folder references for the specified PO.\n        \"\"\"\n        self.logger.info(\n            f'[update_po_folder_link] - \ud83d\ude80 Checking dropbox folder references for PO {project_number}_{str(po_number).zfill(2)}'\n        )\n        try:"
                    },
                    {
                        "name": "update_po_tax_form_links",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_contact",
                            "get_po_tax_form_link",
                            "search_purchase_order_by_keys"
                        ],
                        "docstring": "Update or set the tax_form_link for a PurchaseOrder in Dropbox if needed.",
                        "function_body": "    def update_po_tax_form_links(self, project_number, po_number):\n        \"\"\"\n        Update or set the tax_form_link for a PurchaseOrder in Dropbox if needed.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "create_pos_in_monday",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_batch_create_subitems",
                            "search_purchase_order_by_keys",
                            "extract_subitem_identifiers",
                            "subitem_column_values_formatter",
                            "batch_create_or_update_items",
                            "update_purchase_order_by_keys",
                            "update_detail_item_by_keys",
                            "update_purchase_order",
                            "get_items_in_project",
                            "po_column_values_formatter",
                            "search_receipts",
                            "get_subitems_in_board",
                            "is_sub_item_different",
                            "_batch_update_subitems",
                            "search_invoices",
                            "search_account_codes",
                            "is_main_item_different",
                            "search_detail_item_by_keys",
                            "search_contacts"
                        ],
                        "docstring": "Demonstrates how to fetch all subitems once from Monday,\nthen process them locally to avoid multiple queries.",
                        "function_body": "    def create_pos_in_monday(self, project_number):\n        \"\"\"\n        Demonstrates how to fetch all subitems once from Monday,\n        then process them locally to avoid multiple queries.\n        \"\"\"\n        self.logger.info('[create_pos_in_monday] - \ud83c\udf10 Creating/Updating PO records in Monday.com...')\n        monday_items = self.monday_api.get_items_in_project(project_id=project_number)\n        processed_items = self.database_util.search_purchase_order_by_keys(project_number=project_number)\n        monday_items_map = {}\n\n        # Build Monday items map\n        for mi in monday_items:\n            pid = mi['column_values'].get(self.monday_util.PO_PROJECT_ID_COLUMN)['text']\n            pono = mi['column_values'].get(self.monday_util.PO_NUMBER_COLUMN)['text']\n            if pid and pono:\n                monday_items_map[int(pid), int(pono)] = mi\n\n        all_subitems = self.monday_api.get_subitems_in_board(project_number=project_number)\n        global_subitem_map = {}\n        for msub in all_subitems:\n            identifiers = self.monday_util.extract_subitem_identifiers(msub)\n            if identifiers is not None:\n                global_subitem_map[identifiers] = msub\n\n        items_to_create = []\n        items_to_update = []\n\n        import json\n        for db_item in processed_items:\n            contact_item = self.database_util.search_contacts(['id'], [db_item['contact_id']])\n            db_item['contact_pulse_id'] = contact_item['pulse_id']\n            db_item['contact_name'] = contact_item['name']\n            db_item['project_number'] = project_number\n\n            p_id = project_number\n            po_no = int(db_item['po_number'])\n\n            column_values_str = self.monday_util.po_column_values_formatter(\n                project_id=str(project_number),\n                po_number=db_item['po_number'],\n                description=db_item.get('description'),\n                contact_pulse_id=db_item['contact_pulse_id'],\n                folder_link=db_item.get('folder_link'),\n                producer_id=None,\n                name=db_item['contact_name']\n            )\n            new_vals = json.loads(column_values_str)\n            key = (p_id, po_no)\n\n            if key in monday_items_map:\n                monday_item = monday_items_map[key]\n                differences = self.monday_util.is_main_item_different(db_item, monday_item)\n                if differences:\n                    self.logger.debug(\n                        f'[create_pos_in_monday] - Main item differs for PO {po_no}, scheduling update...'\n                    )\n                    items_to_update.append({\n                        'db_item': db_item,\n                        'column_values': new_vals,\n                        'monday_item_id': monday_item['id']\n                    })\n                else:\n                    self.logger.debug(\n                        f'[create_pos_in_monday] - No changes for PO {po_no}, skipping.'\n                    )\n            else:\n                items_to_create.append({'db_item': db_item, 'column_values': new_vals, 'monday_item_id': None})\n\n        if items_to_create:\n            self.logger.info(\n                f'[create_pos_in_monday] - \ud83c\udd95 Creating {len(items_to_create)} new main items in Monday...'\n            )\n            created_mapping = self.monday_api.batch_create_or_update_items(\n                items_to_create,\n                project_id=project_number,\n                create=True\n            )\n            for itm in created_mapping:\n                db_item = itm['db_item']\n                monday_item_id = itm['monday_item_id']\n                self.database_util.update_purchase_order(db_item['id'], pulse_id=monday_item_id)\n                db_item['pulse_id'] = monday_item_id\n                po = int(db_item['po_number'])\n                monday_items_map[p_id, po] = {\n                    'id': monday_item_id,\n                    'name': f'PO #{po}',\n                    'column_values': itm['column_values']\n                }\n\n        if items_to_update:\n            self.logger.info(\n                f'[create_pos_in_monday] - \u270f\ufe0f Updating {len(items_to_update)} main items in Monday...'\n            )\n            updated_mapping = self.monday_api.batch_create_or_update_items(\n                items_to_update,\n                project_id=project_number,\n                create=False\n            )\n            for itm in updated_mapping:\n                db_item = itm['db_item']\n                monday_item_id = itm['monday_item_id']\n                self.database_util.update_purchase_order_by_keys(\n                    project_number, \n                    db_item['po_number'], \n                    pulse_id=monday_item_id\n                )\n                db_item['pulse_id'] = monday_item_id\n                po = int(db_item['po_number'])\n                monday_items_map[p_id, po]['column_values'] = itm['column_values']\n\n        # Subitems sync\n        for db_item in processed_items:\n            p_id = project_number\n            po_no = int(db_item['po_number'])\n            main_monday_item = monday_items_map.get((p_id, po_no))\n            if not main_monday_item:\n                self.logger.warning(\n                    f'[create_pos_in_monday] - \u274c No main Monday reference for PO {po_no}, skipping subitems.'\n                )\n                continue\n\n            main_monday_id = main_monday_item['id']\n            sub_items_db = self.database_util.search_detail_item_by_keys(p_id, db_item['po_number'])\n            if isinstance(sub_items_db, dict):\n                sub_items_db = [sub_items_db]\n\n            subitems_to_create = []\n            subitems_to_update = []\n\n            if not sub_items_db:\n                continue\n\n            for sdb in sub_items_db:\n                if sdb.get('account_code_id'):\n                    account_row = self.database_util.search_account_codes(['id'], [sdb['account_code_id']])\n                    sdb['account_code'] = account_row['code'] if account_row else None\n                else:\n                    sdb['account_code'] = None\n\n                file_link_for_subitem = ''\n                if db_item['po_type'] in ['PC', 'CC']:\n                    receipt_id = sdb.get('receipt_id')\n                    if receipt_id:\n                        existing_receipt = self.database_util.search_receipts(['id'], [receipt_id])\n                        if existing_receipt and existing_receipt.get('file_link'):\n                            file_link_for_subitem = existing_receipt['file_link']\n                    else:\n                        existing_receipts = self.database_util.search_receipts(\n                            ['project_number', 'po_number', 'detail_number', 'line_number'],\n                            [p_id, po_no, sdb['detail_number'], sdb['line_number']]\n                        )\n                        if existing_receipts:\n                            first_receipt = (\n                                existing_receipts[0]\n                                if isinstance(existing_receipts, list)\n                                else existing_receipts\n                            )\n                            file_link_for_subitem = first_receipt.get('file_link', '')\n                            rid = first_receipt.get('id')\n                            self.database_util.update_detail_item_by_keys(\n                                project_number=p_id,\n                                po_number=db_item['po_number'],\n                                detail_number=sdb['detail_number'],\n                                line_number=sdb['line_number'],\n                                receipt_id=rid\n                            )\n                            sdb['receipt_id'] = rid\n                elif db_item['po_type'] in ['INV', 'PROJ']:\n                    invoice_id = sdb.get('invoice_id')\n                    if invoice_id:\n                        existing_invoice = self.database_util.search_invoices(['id'], [invoice_id])\n                        if existing_invoice and existing_invoice.get('file_link'):\n                            file_link_for_subitem = existing_invoice['file_link']\n                    else:\n                        existing_invoices = self.database_util.search_invoices(\n                            ['project_number', 'po_number', 'invoice_number'],\n                            [p_id, po_no, sdb['detail_number']]\n                        )\n                        if existing_invoices:\n                            first_invoice = (\n                                existing_invoices[0] \n                                if isinstance(existing_invoices, list) \n                                else existing_invoices\n                            )\n                            file_link_for_subitem = first_invoice.get('file_link', '')\n                            inv_id = first_invoice.get('id')\n                            self.database_util.update_detail_item_by_keys(\n                                project_number=p_id,\n                                po_number=str(po_no),\n                                detail_number=sdb['detail_number'],\n                                line_number=sdb['line_number'],\n                                invoice_id=inv_id\n                            )\n                            sdb['invoice_id'] = inv_id\n\n                sub_col_values_str = self.monday_util.subitem_column_values_formatter(\n                    project_id=p_id,\n                    po_number=db_item['po_number'],\n                    detail_number=sdb['detail_number'],\n                    line_number=sdb['line_number'],\n                    status=sdb.get('state'),\n                    description=sdb.get('description'),\n                    quantity=sdb.get('quantity'),\n                    rate=sdb.get('rate'),\n                    date=sdb.get('transaction_date'),\n                    due_date=sdb.get('due_date'),\n                    account_number=sdb['account_code'],\n                    link=file_link_for_subitem,\n                    OT=sdb.get('ot'),\n                    fringes=sdb.get('fringes')\n                )\n                new_sub_vals = json.loads(sub_col_values_str)\n                sub_key = (p_id, db_item['po_number'], sdb['detail_number'], sdb['line_number'])\n\n                if sub_key in global_subitem_map:\n                    msub = global_subitem_map[sub_key]\n                    differences = self.monday_util.is_sub_item_different(sdb, msub)\n\n                    if differences:\n                        self.logger.debug(\n                            f'[create_pos_in_monday] - Sub-item differs for detail #{sdb[\"detail_number\"]}; scheduling update...'\n                        )\n                        subitems_to_update.append({\n                            'db_sub_item': sdb,\n                            'column_values': new_sub_vals,\n                            'parent_id': main_monday_id,\n                            'monday_item_id': msub['id']\n                        })\n                    else:\n                        sub_pulse_id = msub['id']\n                        current_pulse_id = sdb.get('pulse_id')\n                        current_parent_id = sdb.get('parent_pulse_id')\n\n                        if current_pulse_id != int(sub_pulse_id) or current_parent_id != int(main_monday_id):\n                            self.logger.debug(\n                                '[create_pos_in_monday] - Subitem pulse mismatch, updating DB references...'\n                            )\n                            self.database_util.update_detail_item_by_keys(\n                                project_number=p_id,\n                                po_number=db_item['po_number'],\n                                detail_number=sdb['detail_number'],\n                                line_number=sdb['line_number'],\n                                pulse_id=sub_pulse_id,\n                                parent_pulse_id=main_monday_id\n                            )\n                            sdb['pulse_id'] = sub_pulse_id\n                            sdb['parent_pulse_id'] = main_monday_id\n                else:\n                    subitems_to_create.append({\n                        'db_sub_item': sdb,\n                        'column_values': new_sub_vals,\n                        'parent_id': main_monday_id\n                    })\n\n            if subitems_to_create:\n                self.logger.info(\n                    f'[create_pos_in_monday] - \ud83c\udd95 Creating {len(subitems_to_create)} new sub-items for PO {po_no}...'\n                )\n                self._batch_create_subitems(subitems_to_create, main_monday_id, p_id, db_item)\n\n            if subitems_to_update:\n                self.logger.info(\n                    f'[create_pos_in_monday] - \u270f\ufe0f Updating {len(subitems_to_update)} existing sub-items for PO {po_no}...'\n                )\n                self._batch_update_subitems(subitems_to_update, main_monday_id, p_id, db_item)\n\n        self.logger.info('[create_pos_in_monday] - \u2705 Completed Monday.com integration for all processed PO data.')"
                    },
                    {
                        "name": "_batch_create_subitems",
                        "args": [
                            "self",
                            "subitems_to_create",
                            "parent_item_id",
                            "project_number",
                            "db_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item_by_keys"
                        ],
                        "docstring": null,
                        "function_body": "    def _batch_create_subitems(self, subitems_to_create, parent_item_id, project_number, db_item):\n        from concurrent.futures import ThreadPoolExecutor, as_completed\n        chunk_size = 10\n        create_chunks = [\n            subitems_to_create[i:i + chunk_size] \n            for i in range(0, len(subitems_to_create), chunk_size)\n        ]\n        all_created_subs = []\n\n        with ThreadPoolExecutor() as executor:\n            future_to_index = {}\n            for idx, chunk in enumerate(create_chunks):\n                future = executor.submit(\n                    self.monday_api.batch_create_or_update_subitems,\n                    chunk,\n                    parent_item_id=parent_item_id,\n                    create=True\n                )\n                future_to_index[future] = idx\n\n            for future in as_completed(future_to_index):\n                idx = future_to_index[future]\n                try:\n                    chunk_result = future.result()\n                    self.logger.debug(\n                        f'[_batch_create_subitems] - Subitem create-chunk #{idx + 1} completed.'\n                    )\n                    all_created_subs.extend(chunk_result)\n                except Exception:\n                    self.logger.exception(\n                        f'[_batch_create_subitems] - \u274c Error creating subitems in chunk {idx + 1}.',\n                        exc_info=True\n                    )\n                    raise\n\n        for csub in all_created_subs:"
                    },
                    {
                        "name": "_batch_update_subitems",
                        "args": [
                            "self",
                            "subitems_to_update",
                            "parent_item_id",
                            "project_number",
                            "db_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item_by_keys"
                        ],
                        "docstring": null,
                        "function_body": "    def _batch_update_subitems(self, subitems_to_update, parent_item_id, project_number, db_item):\n        from concurrent.futures import ThreadPoolExecutor, as_completed\n        chunk_size = 10\n        update_chunks = [\n            subitems_to_update[i:i + chunk_size] \n            for i in range(0, len(subitems_to_update), chunk_size)\n        ]\n        all_updated_subs = []\n\n        with ThreadPoolExecutor() as executor:\n            future_to_index = {}\n            for idx, chunk in enumerate(update_chunks):\n                future = executor.submit(\n                    self.monday_api.batch_create_or_update_subitems,\n                    chunk,\n                    parent_item_id=parent_item_id,\n                    create=False\n                )\n                future_to_index[future] = idx\n\n            for future in as_completed(future_to_index):\n                idx = future_to_index[future]\n                try:\n                    chunk_result = future.result()\n                    self.logger.debug(\n                        f'[_batch_update_subitems] - Subitem update-chunk #{idx + 1} completed.'\n                    )\n                    all_updated_subs.extend(chunk_result)\n                except Exception:\n                    self.logger.exception(\n                        f'[_batch_update_subitems] - \u274c Error updating subitems in chunk {idx + 1}.',\n                        exc_info=True\n                    )\n                    raise\n\n        for usub in all_updated_subs:"
                    },
                    {
                        "name": "scan_project_receipts",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_scan_and_process_receipts_in_folder",
                            "find_project_folder"
                        ],
                        "docstring": "Scans credit-card/vendor receipt folders (1. Purchase Orders) and\npetty-cash receipt folders (3. Petty Cash/1. Crew PC Folders) for the project.",
                        "function_body": "    def scan_project_receipts(self, project_number: str):\n        \"\"\"\n        Scans credit-card/vendor receipt folders (1. Purchase Orders) and\n        petty-cash receipt folders (3. Petty Cash/1. Crew PC Folders) for the project.\n        \"\"\"\n        self.logger.info(\n            f'[scan_project_receipts] - \ud83d\udd0e Initiating dropbox scan for receipts, project={project_number}...'\n        )\n        project_folder_path = self.dropbox_api.find_project_folder(project_number, namespace='2024')\n        if not project_folder_path:\n            self.logger.warning(\n                f\"[scan_project_receipts] - \u274c No matching project folder in dropbox for '{project_number}' under 2024.\"\n            )\n            return\n\n        self.logger.info(\n            f'[scan_project_receipts] - \ud83d\udcc2 Resolved project folder path: {project_folder_path}'\n        )\n        purchase_orders_path = f'{project_folder_path}/1. Purchase Orders'\n        petty_cash_path = f'{project_folder_path}/3. Petty Cash/1. Crew PC Folders'\n\n        self._scan_and_process_receipts_in_folder(purchase_orders_path, project_number)\n        self._scan_and_process_receipts_in_folder(petty_cash_path, project_number)\n        self.logger.info("
                    },
                    {
                        "name": "_scan_and_process_receipts_in_folder",
                        "args": [
                            "self",
                            "folder_path",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "process_receipt",
                            "_list_folder_recursive"
                        ],
                        "docstring": null,
                        "function_body": "    def _scan_and_process_receipts_in_folder(self, folder_path: str, project_number: str):\n        entries = self._list_folder_recursive(folder_path)\n        if not entries:\n            self.logger.debug(\n                f\"[_scan_and_process_receipts_in_folder] - No entries found in dropbox folder '{folder_path}'.\"\n            )\n            return\n\n        for entry in entries:"
                    },
                    {
                        "name": "_list_folder_recursive",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _list_folder_recursive(self, folder_path: str):\n        from dropbox import files\n        results = []\n\n        try:\n            dbx = self.dropbox_client.dbx\n            self.logger.info(\n                f'[_list_folder_recursive] - \ud83d\udcc1 Recursively listing dropbox folder: {folder_path}'\n            )\n            res = dbx.files_list_folder(folder_path, recursive=True)\n            entries = res.entries\n\n            while res.has_more:\n                res = dbx.files_list_folder_continue(res.cursor)\n                entries.extend(res.entries)\n\n            for e in entries:\n                if isinstance(e, files.FolderMetadata):\n                    results.append({\n                        'name': e.name,\n                        'path_lower': e.path_lower,\n                        'path_display': e.path_display,\n                        'is_folder': True\n                    })\n                elif isinstance(e, files.FileMetadata):\n                    results.append({\n                        'name': e.name,\n                        'path_lower': e.path_lower,\n                        'path_display': e.path_display,\n                        'is_folder': False\n                    })\n        except Exception:\n            self.logger.exception(\n                f'[_list_folder_recursive] - \u26a0\ufe0f Could not list folder recursively for {folder_path}.',\n                exc_info=True\n            )\n        return results"
                    },
                    {
                        "name": "_scan_po_folder_for_invoices",
                        "args": [
                            "self",
                            "folder_path",
                            "project_number",
                            "folder_po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_list_folder_recursive",
                            "process_invoice"
                        ],
                        "docstring": null,
                        "function_body": "    def _scan_po_folder_for_invoices(self, folder_path: str, project_number: str, folder_po_number: str):\n        entries = self._list_folder_recursive(folder_path)\n        if not entries:\n            return\n\n        for entry in entries:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('dropbox')"
            },
            {
                "name": "dropbox_service",
                "value": "DropboxService()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_util.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "parse_file_name",
                        "args": [
                            "self",
                            "file_name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse the file name to extract metadata.",
                        "function_body": "    def parse_file_name(self, file_name: str) -> Dict[str, str]:\n        \"\"\"Parse the file name to extract metadata.\"\"\"\n        parts = file_name.split('_')\n        if len(parts) < 4:\n            raise ValueError('Invalid file name format.')\n        po_number = parts[0]\n        file_type = parts[-1].split('.')[0]\n        return {'po_number': po_number, 'file_type': file_type}"
                    },
                    {
                        "name": "is_po_folder",
                        "args": [
                            "self",
                            "local_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Determines if the specified folder path is a valid PO folder within the correct project structure.\n\nExpected structure:\n    .../<Project Folder>/1. Purchase Orders/<PO Folder>\n\nArgs:\n    local_path (str): The path to the folder or file to check.\n\nReturns:\n    bool: True if the folder is a PO folder within the correct project structure, False otherwise.",
                        "function_body": "    def is_po_folder(self, local_path):\n        \"\"\"\n        Determines if the specified folder path is a valid PO folder within the correct project structure.\n\n        Expected structure:\n            .../<Project Folder>/1. Purchase Orders/<PO Folder>\n\n        Args:\n            local_path (str): The path to the folder or file to check.\n\n        Returns:\n            bool: True if the folder is a PO folder within the correct project structure, False otherwise.\n        \"\"\"\n        normalized_path = local_path.replace('\\\\', '/')\n        path_parts = normalized_path.strip('/').split('/')\n        if '.' in path_parts[-1]:\n            folder_path = os.path.dirname(normalized_path)\n            path_parts = folder_path.strip('/').split('/')\n            self.logger.debug('[is_po_folder] - Detected file path. Extracted parent folder path.')\n        else:\n            folder_path = normalized_path\n        self.logger.debug(f'[is_po_folder] - Normalized Path Parts: {path_parts}')\n        if len(path_parts) < 3:\n            self.logger.debug(f\"[is_po_folder] - Path '{local_path}' does not have enough parts to be a valid PO folder.\")\n            return False\n        folder_name = path_parts[-1]\n        purchase_orders_folder = path_parts[-2]\n        project_folder = path_parts[-3]\n        self.logger.debug(f\"[is_po_folder] - Checking PO folder: Project='{project_folder}', Purchase Orders='{purchase_orders_folder}', PO Folder='{folder_name}'\")\n        po_folder_pattern = '^(\\\\d+)[_-](\\\\d+)\\\\s+.*$'\n        if not re.match(po_folder_pattern, folder_name):\n            self.logger.debug(f\"[is_po_folder] - Folder name '{folder_name}' does not match PO folder pattern.\")\n            return False\n        if purchase_orders_folder.lower() != '1. purchase orders':\n            self.logger.debug(f\"[is_po_folder] - Expected '1. Purchase Orders', but found '{purchase_orders_folder}'.\")\n            return False\n        project_pattern = '^\\\\d+\\\\s*[-_]\\\\s*.*'\n        if not re.match(project_pattern, project_folder):\n            self.logger.debug(f\"[is_po_folder] - Project folder '{project_folder}' does not match project pattern.\")\n            return False\n        self.logger.debug(f\"[is_po_folder] - Path '{local_path}' is a valid PO folder.\")\n        return True"
                    },
                    {
                        "name": "parse_folder_path",
                        "args": [
                            "self",
                            "local_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parses the folder path to extract the Project ID, PO Number, Vendor Name,\nand PO Type (vendor or cc).\n\nExpected folder structure: .../2024/Project Folder/Purchase Order Folder/...\nExample: '/Users/.../2024/2416 - Whop Keynote/1. Purchase Orders/2416_02 AMEX 8738/\n\nReturns:\n    Tuple (project_id, po_number, vendor_name, po_type) if found, else (None, None, None, None)",
                        "function_body": "    def parse_folder_path(self, local_path):\n        \"\"\"\n        Parses the folder path to extract the Project ID, PO Number, Vendor Name,\n        and PO Type (vendor or cc).\n\n        Expected folder structure: .../2024/Project Folder/Purchase Order Folder/...\n        Example: '/Users/.../2024/2416 - Whop Keynote/1. Purchase Orders/2416_02 AMEX 8738/\n\n        Returns:\n            Tuple (project_id, po_number, vendor_name, po_type) if found, else (None, None, None, None)\n        \"\"\"\n        path_parts = local_path.split(os.sep)\n        self.logger.debug(f'[parse_folder_path] - Path parts for parsing: {path_parts}')\n        path_parts_reversed = path_parts[::-1]\n        project_id = None\n        po_number = None\n        vendor_name = None\n        po_type = 'vendor'\n        self.logger.debug(f'[parse_folder_path] - Parsing folder path: {local_path}')\n        for part in path_parts_reversed:\n            self.logger.debug(f\"[parse_folder_path] - Checking folder part: '{part}'\")\n            po_match = re.match('^(\\\\d+)[_-](\\\\d+)\\\\s+(.*?)(\\\\d{4})?$', part)\n            if po_match:\n                po_number = po_match.group(2)\n                credit_card_digits = po_match.group(4)\n                vendor_name = po_match.group(3).strip()\n                if credit_card_digits:\n                    po_type = 'cc'\n                    vendor_name += ' ' + credit_card_digits\n                self.logger.debug(f\"[parse_folder_path] - Found PO Number: '{po_number}', Vendor Name: '{vendor_name}', PO Type: '{po_type}' in folder part: '{part}'\")\n                continue\n            project_match = re.match('^(\\\\d+)\\\\s*[-_]\\\\s*.*', part)\n            if project_match:\n                project_id = project_match.group(1)\n                self.logger.debug(f\"[parse_folder_path] - Found Project ID: '{project_id}' in folder part: '{part}'\")\n                continue\n            if project_id and po_number:\n                break\n        if project_id and po_number:"
                    },
                    {
                        "name": "parse_filename",
                        "args": [
                            "self",
                            "filename"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parses the filename to extract project_id, po_number, receipt_number (optional), vendor_name, file_type, and invoice_number.\nExpected filename formats:\n- '2417_10 Vendor Name Invoice.pdf'\n- '2417_10 Vendor Name Invoice 3.pdf'\n- '2417_10_03 Citibank Receipt.pdf'",
                        "function_body": "    def parse_filename(self, filename):\n        \"\"\"\n        Parses the filename to extract project_id, po_number, receipt_number (optional), vendor_name, file_type, and invoice_number.\n        Expected filename formats:\n        - '2417_10 Vendor Name Invoice.pdf'\n        - '2417_10 Vendor Name Invoice 3.pdf'\n        - '2417_10_03 Citibank Receipt.pdf'\n        \"\"\"\n        pattern = '(?i)^(\\\\d+)_(\\\\d+)(?:_(\\\\d+))?\\\\s+(.+?)\\\\s+(Invoice|W9|Receipt|W8-BEN|W8-BEN-E)(?:\\\\s*(\\\\d+))?\\\\.(pdf|png|jpg|jpeg|tiff|bmp|heic)$'\n        match = re.match(pattern, filename, re.IGNORECASE)\n        if match:"
                    },
                    {
                        "name": "get_parent_path",
                        "args": [
                            "self",
                            "path_display"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Extracts the parent directory path from a given Dropbox path.\n\nArgs:\n    path_display (str): The full Dropbox path to a file or folder.\n\nReturns:\n    str: The parent directory path. Returns an empty string if no parent exists.",
                        "function_body": "    def get_parent_path(self, path_display):\n        \"\"\"\n        Extracts the parent directory path from a given Dropbox path.\n\n        Args:\n            path_display (str): The full Dropbox path to a file or folder.\n\n        Returns:\n            str: The parent directory path. Returns an empty string if no parent exists.\n        \"\"\"\n        if not path_display:\n            self.logger.error('[get_parent_path] - Empty path_display provided to get_parent_path.')\n            return ''\n        normalized_path = path_display.replace('\\\\', '/').rstrip('/')\n        path_parts = normalized_path.split('/')\n        if len(path_parts) <= 1:\n            self.logger.debug(f\"[get_parent_path] - No parent directory for path: '{path_display}'. Returning empty string.\")\n            return ''\n        parent_path = '/'.join(path_parts[:-1])\n        self.logger.debug(f\"[get_parent_path] - Extracted parent path: '{parent_path}' from path: '{path_display}'\")\n        return parent_path"
                    },
                    {
                        "name": "get_last_path_component_generic",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_last_path_component_generic(self, path):\n        return Path(path).parts[-1]"
                    },
                    {
                        "name": "get_file_link",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "retrieve_existing_shared_link"
                        ],
                        "docstring": null,
                        "function_body": "    def get_file_link(self, dropbox_path: str) -> str:\n        dbx = dropbox_client.dbx\n        try:"
                    },
                    {
                        "name": "retrieve_existing_shared_link",
                        "args": [
                            "self",
                            "dbx",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieve an existing shared link for the specified file.",
                        "function_body": "    def retrieve_existing_shared_link(self, dbx, dropbox_path: str) -> str:\n        \"\"\"\n        Retrieve an existing shared link for the specified file.\n        \"\"\"\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_util",
                "value": "DropboxUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_database_util.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxDatabaseUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger('dropbox')\n        self.dropbox_util = dropbox_util\n        self.logger.info('\ud83d\udce6 Dropbox Database Util initialized \ud83c\udf1f')"
                    },
                    {
                        "name": "add_invoice_link_to_detail_items",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "invoice_number",
                            "file_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def add_invoice_link_to_detail_items(self, project_id: str, po_number: str, invoice_number: int, file_link: str):\n        with get_db_session() as session:"
                    },
                    {
                        "name": "create_or_update_invoice",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "invoice_number",
                            "transaction_date",
                            "term",
                            "total",
                            "file_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def create_or_update_invoice(self, project_id: str, po_number: str, invoice_number: int, transaction_date: str, term: int, total: float, file_link: str):\n        tx_date = None\n        if transaction_date:\n            try:\n                tx_date = datetime.strptime(transaction_date, '%Y-%m-%d')\n            except ValueError:\n                self.logger.warning(f\"[create_or_update_invoice] - Transaction date '{transaction_date}' not in expected format YYYY-MM-DD.\")\n        with get_db_session() as session:"
                    },
                    {
                        "name": "get_detail_item_pulse_ids_for_invoice",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "invoice_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def get_detail_item_pulse_ids_for_invoice(self, project_id: str, po_number: str, invoice_number: int):\n        with get_db_session() as session:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_database_util",
                "value": "DropboxDatabaseUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_client.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxClient",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_access_token",
                            "start_token_refresher"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):\n            self.logger = logging.getLogger('dropbox')\n            self.OAUTH_TOKEN_URL = 'https://api.dropboxapi.com/oauth2/token'\n            self.DROPBOX_REFRESH_TOKEN = os.getenv('DROPBOX_REFRESH_TOKEN')\n            self.DROPBOX_APP_KEY = os.getenv('DROPBOX_APP_KEY')\n            self.DROPBOX_APP_SECRET = os.getenv('DROPBOX_APP_SECRET')\n            self.MY_EMAIL = os.getenv('MY_EMAIL')\n            self.NAMESPACE_NAME = os.getenv('NAMESPACE_NAME')\n            self.CURSOR_DIR = '../cursors'\n            os.makedirs(self.CURSOR_DIR, exist_ok=True)\n            self._internal_lock = threading.Lock()\n            self.access_token = self.get_access_token()\n            self.logger.info('Dropbox Client Initialized')\n        try:\n            self.dbx_team = DropboxTeam(oauth2_access_token=self.access_token, oauth2_refresh_token=self.DROPBOX_REFRESH_TOKEN, app_key=self.DROPBOX_APP_KEY, app_secret=self.DROPBOX_APP_SECRET)\n            members = self.dbx_team.team_members_list().members\n            self.member_id = None\n            for member in members:\n                if member.profile.email == self.MY_EMAIL:\n                    self.member_id = member.profile.team_member_id\n                    break\n            if not self.member_id:\n                self.logger.error(f\"Member with email '{self.MY_EMAIL}' not found in the team.\")\n                raise Exception('Member not found.')\n            self.dbx = self.dbx_team.as_user(self.member_id)\n            self.logger.info(f\"Impersonated user '{self.MY_EMAIL}' with member ID '{self.member_id}'.\")\n            namespaces = self.dbx_team.team_namespaces_list().namespaces\n            self.namespace_id = None\n            for ns in namespaces:\n                if ns.name == self.NAMESPACE_NAME:\n                    self.namespace_id = ns.namespace_id\n                    break\n            if self.namespace_id:\n                self.logger.info(f\"Found namespace '{self.NAMESPACE_NAME}' with ID '{self.namespace_id}'. Setting path root.\")\n                path_root = common.PathRoot.namespace_id(self.namespace_id)\n                self.dbx = self.dbx.with_path_root(path_root)\n                self.logger.debug(f\"Path root set to namespace ID '{self.namespace_id}'.\")\n            else:\n                self.logger.warning(f\"Namespace '{self.NAMESPACE_NAME}' not found. Using default path root.\")\n            self.start_token_refresher()\n        except Exception as e:\n            self.logger.error(f'An error occurred while creating Dropbox client: {e}', exc_info=True)\n            raise e\n        self._initialized = True"
                    },
                    {
                        "name": "get_new_access_token",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "save_access_token"
                        ],
                        "docstring": "Use the refresh token to get a new access token.",
                        "function_body": "    def get_new_access_token(self):\n        \"\"\"\n        Use the refresh token to get a new access token.\n        \"\"\"\n        data = {'grant_type': 'refresh_token', 'refresh_token': self.DROPBOX_REFRESH_TOKEN, 'client_id': self.DROPBOX_APP_KEY, 'client_secret': self.DROPBOX_APP_SECRET}\n        response = requests.post(self.OAUTH_TOKEN_URL, data=data)\n        if response.status_code == 200:"
                    },
                    {
                        "name": "save_access_token",
                        "args": [
                            "self",
                            "access_token",
                            "expires_in"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Store the access token and its expiration time.",
                        "function_body": "    def save_access_token(self, access_token, expires_in):\n        \"\"\"\n        Store the access token and its expiration time.\n        \"\"\"\n        self.token_expiry_time = time.time() + expires_in\n        token_data = {'access_token': access_token, 'expires_at': self.token_expiry_time}\n        with open('../token.json', 'w') as token_file:"
                    },
                    {
                        "name": "load_access_token",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Load the access token from storage.",
                        "function_body": "    def load_access_token(self):\n        \"\"\"\n        Load the access token from storage.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "get_access_token",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "load_access_token",
                            "get_new_access_token"
                        ],
                        "docstring": "Get the valid access token, refreshing it if necessary.",
                        "function_body": "    def get_access_token(self):\n        \"\"\"\n        Get the valid access token, refreshing it if necessary.\n        \"\"\"\n        access_token = self.load_access_token()\n        if not access_token:\n            self.logger.info('[get_access_token] - Refreshing access token.')\n            access_token = self.get_new_access_token()\n        return access_token"
                    },
                    {
                        "name": "list_root_folder",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists the contents of the root folder to verify connection.",
                        "function_body": "    def list_root_folder(self):\n        \"\"\"\n        Lists the contents of the root folder to verify connection.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "list_folder_changes",
                        "args": [
                            "self",
                            "cursor"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists changes in the specified folder using the provided cursor.\nReturns a tuple of (changes, new_cursor).",
                        "function_body": "    def list_folder_changes(self, cursor):\n        \"\"\"\n        Lists changes in the specified folder using the provided cursor.\n        Returns a tuple of (changes, new_cursor).\n        \"\"\"\n        with self._internal_lock:"
                    },
                    {
                        "name": "load_cursor",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_cursor_file_path"
                        ],
                        "docstring": "Load the cursor for the member.",
                        "function_body": "    def load_cursor(self):\n        \"\"\"\n        Load the cursor for the member.\n        \"\"\"\n        cursor_file = self.get_cursor_file_path()\n        if not os.path.exists(cursor_file):\n            self.logger.info(f'[load_cursor] - No cursor file found for member ID {self.member_id}. Initializing cursor.')\n            return None\n        try:"
                    },
                    {
                        "name": "save_cursor",
                        "args": [
                            "self",
                            "cursor"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_cursor_file_path"
                        ],
                        "docstring": "Save the cursor for the member.",
                        "function_body": "    def save_cursor(self, cursor):\n        \"\"\"\n        Save the cursor for the member.\n        \"\"\"\n        cursor_file = self.get_cursor_file_path()\n        (temp_fd, temp_path) = tempfile.mkstemp()\n        try:"
                    },
                    {
                        "name": "get_cursor_file_path",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Get the file path for storing the cursor.",
                        "function_body": "    def get_cursor_file_path(self):\n        \"\"\"\n        Get the file path for storing the cursor.\n        \"\"\"\n        safe_member_id = self.member_id.replace(':', '_')\n        return os.path.join(self.CURSOR_DIR, f'cursor_{safe_member_id}.json')"
                    },
                    {
                        "name": "start_token_refresher",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Starts a background thread to refresh the access token before it expires.",
                        "function_body": "    def start_token_refresher(self):\n        \"\"\"\n        Starts a background thread to refresh the access token before it expires.\n        \"\"\"\n        refresher_thread = threading.Thread(target=self.token_refresher, daemon=True)\n        refresher_thread.start()\n        self.logger.info('[start_token_refresher] - Token refresher thread started.')"
                    },
                    {
                        "name": "token_refresher",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_new_access_token"
                        ],
                        "docstring": "Refreshes the access token periodically before it expires.",
                        "function_body": "    def token_refresher(self):\n        \"\"\"\n        Refreshes the access token periodically before it expires.\n        \"\"\"\n        while True:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_client",
                "value": "DropboxClient()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/ocr_service.py",
        "functions": [],
        "classes": [
            {
                "name": "OCRService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "extract_text_from_file",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Extract text from a file (invoice, receipt, or W-9).",
                        "function_body": "    def extract_text_from_file(self, file_data: bytes) -> str:\n        \"\"\"Extract text from a file (invoice, receipt, or W-9).\"\"\"\n        try:"
                    },
                    {
                        "name": "extract_text_from_invoice",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_file"
                        ],
                        "docstring": "Extract text specifically from an invoice file.",
                        "function_body": "    def extract_text_from_invoice(self, file_data: bytes) -> str:\n        \"\"\"Extract text specifically from an invoice file.\"\"\"\n        return self.extract_text_from_file(file_data)"
                    },
                    {
                        "name": "parse_invoice_details",
                        "args": [
                            "self",
                            "text_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse invoice details from extracted text.",
                        "function_body": "    def parse_invoice_details(self, text_data: str) -> dict:\n        \"\"\"Parse invoice details from extracted text.\"\"\"\n        details = {}\n        lines = text_data.split('\\n')\n        for line in lines:\n            if 'Invoice Number:' in line:\n                details['invoice_number'] = line.split(':')[1].strip()\n            elif 'Total Amount:' in line:\n                details['total_amount'] = float(line.split(':')[1].strip().replace('$', ''))\n        return details"
                    },
                    {
                        "name": "extract_text_from_w9",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_file"
                        ],
                        "docstring": "Extract text from a W-9 form.",
                        "function_body": "    def extract_text_from_w9(self, file_data: bytes) -> str:\n        \"\"\"Extract text from a W-9 form.\"\"\"\n        return self.extract_text_from_file(file_data)"
                    },
                    {
                        "name": "parse_w9_details",
                        "args": [
                            "self",
                            "text_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse details from a W-9 form.",
                        "function_body": "    def parse_w9_details(self, text_data: str) -> dict:\n        \"\"\"Parse details from a W-9 form.\"\"\"\n        details = {}\n        lines = text_data.split('\\n')\n        for (i, line) in enumerate(lines):\n            if 'Name' in line:\n                details['name'] = lines[i + 1].strip()\n            if 'Tax ID' in line:\n                details['tax_id'] = lines[i + 1].strip()\n        return details"
                    },
                    {
                        "name": "extract_text_from_receipt",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_file"
                        ],
                        "docstring": "Extract text from a receipt.",
                        "function_body": "    def extract_text_from_receipt(self, file_data: bytes) -> str:\n        \"\"\"Extract text from a receipt.\"\"\"\n        return self.extract_text_from_file(file_data)"
                    },
                    {
                        "name": "parse_receipt_details",
                        "args": [
                            "self",
                            "text_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse receipt details from extracted text.",
                        "function_body": "    def parse_receipt_details(self, text_data: str) -> dict:\n        \"\"\"Parse receipt details from extracted text.\"\"\"\n        details = {}\n        return details"
                    },
                    {
                        "name": "extract_info_with_openai",
                        "args": [
                            "self",
                            "text"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_info_with_openai(self, text):\n        messages = [{'role': 'system', 'content': \"You are an AI assistant that extracts information from financial documents for a production company / digital creative studio. Extract the following details from the text:\\n                   Invoice Date (Formatted as YYYY-MM-DD),  Total Amount, Payment Term.\\n                   Respond with pure, parsable, JSON (no leading or trailing apostrophes) with keys: 'invoice_date', 'total_amount', 'payment_term' If any fields are empty make their value None\"}, {'role': 'user', 'content': text}]\n        response = self.client.chat.completions.create(model='gpt-3.5-turbo', messages=messages, max_tokens=1000, temperature=0)\n        extracted_info = response.choices[0].message.content.strip()\n        try:"
                    },
                    {
                        "name": "extract_receipt_info_with_openai",
                        "args": [
                            "self",
                            "text"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_receipt_info_with_openai(self, text):\n        messages = [{'role': 'system', 'content': \"You are an AI assistant that extracts information from receipts.\\n                    Extract the following details from the text: \\n                    Total Amount (numbers only, no symbols), \\n                    Date of purchase (format YYYY-MM-DD), and \\n                    generate a description (summarize to 20 characters maximum). \\n                    If the total is a refund then the value should be negative. \\n                    Provide the information in JSON format with keys: 'total_amount', 'description', 'date'.\"}, {'role': 'user', 'content': text}]\n        response = self.client.chat.completions.create(model='gpt-3.5-turbo', messages=messages, max_tokens=1000, temperature=0)\n        extracted_info = response.choices[0].message.content.strip()\n        extracted_info_clean = extracted_info.replace('```json', '').replace('```', '').strip()\n        try:"
                    },
                    {
                        "name": "extract_text",
                        "args": [
                            "self",
                            "local_file_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text"
                        ],
                        "docstring": "Extracts text from a PDF or image file using OCR or direct PDF text extraction.\n\n:param local_file_path: The local file path of the document or image.\n:return: A string containing all text extracted from the file.",
                        "function_body": "    def extract_text(self, local_file_path: str) -> str:\n        \"\"\"\n        Extracts text from a PDF or image file using OCR or direct PDF text extraction.\n\n        :param local_file_path: The local file path of the document or image.\n        :return: A string containing all text extracted from the file.\n        \"\"\"\n        (_, ext) = os.path.splitext(local_file_path.lower())\n        text_content = ''\n        try:\n            if ext == '.pdf':\n                logging.info(f'\ud83d\udd0e [OCRService] Processing PDF with pdfplumber: {local_file_path}')\n                with pdfplumber.open(local_file_path) as pdf:\n                    for page in pdf.pages:\n                        page_text = page.extract_text() or ''\n                        text_content += page_text + '\\n'\n            else:\n                logging.info(f'\ud83d\udd0e [OCRService] Processing image with pytesseract: {local_file_path}')\n                image = Image.open(local_file_path)\n                text_content = pytesseract.image_to_string(image)\n        except Exception as e:\n            logging.error(f'\u274c [OCRService] Failed to extract text from file {local_file_path}: {e}', exc_info=True)\n        return text_content.strip()"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('dropbox')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_api.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxAPI",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "upload_file",
                        "args": [
                            "self",
                            "file_path",
                            "destination_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Uploads a file to Dropbox.",
                        "function_body": "    def upload_file(self, file_path: str, destination_path: str):\n        \"\"\"Uploads a file to Dropbox.\"\"\"\n        with open(file_path, 'rb') as f:"
                    },
                    {
                        "name": "download_file",
                        "args": [
                            "self",
                            "file_path",
                            "local_destination"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Downloads a file from Dropbox.",
                        "function_body": "    def download_file(self, file_path: str, local_destination: str):\n        \"\"\"Downloads a file from Dropbox.\"\"\"\n        try:"
                    },
                    {
                        "name": "get_file_metadata",
                        "args": [
                            "self",
                            "file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves metadata for a file.",
                        "function_body": "    def get_file_metadata(self, file_path: str):\n        \"\"\"Retrieves metadata for a file.\"\"\"\n        try:"
                    },
                    {
                        "name": "list_folder_contents",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists the contents of a folder.",
                        "function_body": "    def list_folder_contents(self, folder_path: str):\n        \"\"\"Lists the contents of a folder.\"\"\"\n        try:"
                    },
                    {
                        "name": "create_folder",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a folder in Dropbox.",
                        "function_body": "    def create_folder(self, folder_path: str):\n        \"\"\"Creates a folder in Dropbox.\"\"\"\n        try:"
                    },
                    {
                        "name": "delete_file_or_folder",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Deletes a file or folder in Dropbox.",
                        "function_body": "    def delete_file_or_folder(self, path: str):\n        \"\"\"Deletes a file or folder in Dropbox.\"\"\"\n        try:"
                    },
                    {
                        "name": "list_files_in_folder",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists all files under the given folder_path and returns a list of dicts\ncontaining 'file_name' and 'file_link' for each file.",
                        "function_body": "    def list_files_in_folder(self, folder_path: str) -> list:\n        \"\"\"\n        Lists all files under the given folder_path and returns a list of dicts\n        containing 'file_name' and 'file_link' for each file.\n        \"\"\"\n        self.logger.debug(f\"[list_files_in_folder] - \ud83d\udcc2 Listing files under '{folder_path}'\")\n        files_data = []\n        try:\n            result = self.dbx.files_list_folder(path=folder_path, recursive=False)\n            entries = result.entries\n            while result.has_more:\n                result = self.dbx.files_list_folder_continue(result.cursor)\n                entries.extend(result.entries)\n            for entry in entries:\n                if isinstance(entry, FileMetadata):\n                    files_data.append({'file_name': entry.name})\n        except Exception as e:\n            self.logger.exception(f\"[list_files_in_folder] - \ud83d\udca5 Error listing files in '{folder_path}': {e}\", exc_info=True)\n        return files_data"
                    },
                    {
                        "name": "get_po_tax_form_link",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_share_link",
                            "list_files_in_folder",
                            "find_project_folder",
                            "list_all_projects",
                            "list_project_po_folders"
                        ],
                        "docstring": "Retrieves PO folders and their shared links based on provided parameters.\n\nArgs:\n    project_number (str, optional): The ID of the project. Defaults to None.\n    po_number (str, optional): The number of the PO. Defaults to None.\n\nReturns:\n    List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                            'po_folder_path', and 'po_folder_link'.",
                        "function_body": "    def get_po_tax_form_link(self, project_number: Optional[str]=None, po_number: Optional[str]=None) -> List[Dict[str, str]]:\n        \"\"\"\n        Retrieves PO folders and their shared links based on provided parameters.\n\n        Args:\n            project_number (str, optional): The ID of the project. Defaults to None.\n            po_number (str, optional): The number of the PO. Defaults to None.\n\n        Returns:\n            List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                                    'po_folder_path', and 'po_folder_link'.\n        \"\"\"\n        project_po_data = []\n        try:\n            if project_number is None:\n                self.logger.info(\"[get_po_tax_form_link] - \ud83d\udcc1 No project_number provided. Retrieving all PO folders under the '2024' namespace.\")\n                all_projects = self.list_all_projects(namespace='2024')\n                if not all_projects:\n                    self.logger.warning(\"[get_po_tax_form_link] - \u26a0\ufe0f No projects found under the '2024' namespace.\")\n                    return []\n                for project in all_projects:\n                    current_project_number = project['id']\n                    project_folder_path = project['path']\n                    po_base_path = f'{project_folder_path}/1. Purchase Orders'\n                    po_folders = self.list_project_po_folders(po_base_path)\n                    if not po_folders:\n                        self.logger.info(f\"[get_po_tax_form_link] - \u2139\ufe0f No PO folders found for project_number={current_project_number} at '{po_base_path}'\")\n                        continue\n                    for po_folder in po_folders:\n                        files = self.list_files_in_folder(po_folder['path'])\n                        tax_form_link = ''\n                        form_type = ''\n                        for file in files:\n                            match = re.search(self.TAX_FORM_REGEX, file['file_name'].lower(), re.IGNORECASE)\n                            if match:\n                                self.logger.info(f\"[get_po_tax_form_link] - \ud83d\udcbc Identified as tax form: {file['file_name']}\")\n                                tax_form_link = self.create_share_link(po_folder['path'])\n                                if match.group(1):\n                                    form_type = 'W-9'\n                                elif match.group(2):\n                                    form_type = 'W-8BEN'\n                                elif match.group(3):\n                                    form_type = 'W-8BEN-E'\n                                elif match.group(4):\n                                    form_type = 'W-8BEN-E'\n                                self.logger.info(f\"[get_po_tax_form_link] - \ud83d\udcbc Identified as tax form: {file['file_name']} ({form_type})\")\n                        project_po_data.append({'po_folder_name': po_folder['name'], 'po_folder_path': po_folder['path'], 'po_tax_form_link': tax_form_link, 'form_type': form_type})\n            elif project_number and po_number is None:\n                self.logger.info(f'[get_po_tax_form_link] - \ud83d\udcc1 Retrieving PO folders for project_number={project_number}')\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f'[get_po_tax_form_link] - \u26a0\ufe0f Unable to find project folder for project_number={project_number}')\n                    return []\n                po_base_path = f'{project_folder_path}/1. Purchase Orders'\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"[get_po_tax_form_link] - \u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n                for po_folder in po_folders:\n                    files = self.list_files_in_folder(po_folder['path'])\n                    tax_form_link = ''\n                    form_type = ''\n                    for file in files:\n                        match = re.search(self.TAX_FORM_REGEX, file['file_name'].lower(), re.IGNORECASE)\n                        if match:\n                            self.logger.info(f\"[get_po_tax_form_link] - \ud83d\udcbc Identified as tax form: {file['file_name']}\")\n                            tax_form_link = self.create_share_link(po_folder['path'])\n                            if match.group(1):\n                                form_type = 'W-9'\n                            elif match.group(2):\n                                form_type = 'W-8BEN'\n                            elif match.group(3):\n                                form_type = 'W-8BEN-E'\n                            elif match.group(4):\n                                form_type = 'W-8BEN-E'\n                            self.logger.info(f\"[get_po_tax_form_link] - \ud83d\udcbc Identified as tax form: {file['file_name']} ({form_type})\")\n                    project_po_data.append({'po_folder_name': po_folder['name'], 'po_folder_path': po_folder['path'], 'po_tax_form_link': tax_form_link, 'form_type': form_type})\n            elif project_number and po_number:\n                self.logger.info(f'[get_po_tax_form_link] - \ud83d\udcc1 Retrieving PO folder for project_number={project_number} and po_number={po_number}')\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f'[get_po_tax_form_link] - \u26a0\ufe0f Unable to find project folder for project_number={project_number}')\n                    return []\n                formatted_po_number = f'{int(po_number):02}'\n                self.logger.debug(f'[get_po_tax_form_link] - \ud83d\udccc Formatted po_number: {formatted_po_number}')\n                po_base_path = f'{project_folder_path}/1. Purchase Orders'\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"[get_po_tax_form_link] - \u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n                specific_po_folder = next((po for po in po_folders if po['name'].startswith(f'{project_number}_{formatted_po_number}')), None)\n                po_path = specific_po_folder['path'] + '/'\n                files = self.list_files_in_folder(po_path)\n                tax_form_link = ''\n                form_type = ''\n                for file in files:\n                    match = re.search(self.TAX_FORM_REGEX, file['file_name'], re.IGNORECASE)\n                    if match:\n                        self.logger.info(f\"[get_po_tax_form_link] - \ud83d\udcbc Identified as tax form: {file['file_name']}\")\n                        tax_form_link = self.create_share_link(po_path + file['file_name'])\n                        if match.group(1):\n                            form_type = 'W-9'\n                        elif match.group(2):\n                            form_type = 'W-8BEN'\n                        elif match.group(3):\n                            form_type = 'W-8BEN-E'\n                        elif match.group(4):\n                            form_type = 'W-8BEN-E'\n                        self.logger.info(f\"[get_po_tax_form_link] - \ud83d\udcbc Identified as tax form: {file['file_name']} ({form_type})\")\n                        continue\n                project_po_data.append({'po_folder_name': specific_po_folder['name'], 'po_folder_path': specific_po_folder['path'], 'po_tax_form_link': tax_form_link, 'form_type': form_type})\n            else:\n                self.logger.error('[get_po_tax_form_link] - \u2757 Invalid combination of parameters provided.')\n                return []\n        except Exception as e:\n            self.logger.exception(f'[get_po_tax_form_link] - \ud83d\udca5 An error occurred while retrieving PO folders: {e}')\n            return []\n        self.logger.info(f'[get_po_tax_form_link] - \u2705 Retrieved {len(project_po_data)} PO folders based on the provided parameters.')\n        return project_po_data"
                    },
                    {
                        "name": "get_project_po_folders_with_link",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "list_all_projects",
                            "create_share_link",
                            "list_project_po_folders",
                            "find_project_folder"
                        ],
                        "docstring": "Retrieves PO folders and their shared links based on provided parameters.\n\nArgs:\n    project_number (str, optional): The ID of the project. Defaults to None.\n    po_number (str, optional): The number of the PO. Defaults to None.\n\nReturns:\n    List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                            'po_folder_path', and 'po_folder_link'.",
                        "function_body": "    def get_project_po_folders_with_link(self, project_number: Optional[str]=None, po_number: Optional[str]=None) -> List[Dict[str, str]]:\n        \"\"\"\n        Retrieves PO folders and their shared links based on provided parameters.\n\n        Args:\n            project_number (str, optional): The ID of the project. Defaults to None.\n            po_number (str, optional): The number of the PO. Defaults to None.\n\n        Returns:\n            List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                                    'po_folder_path', and 'po_folder_link'.\n        \"\"\"\n        project_po_data = []\n        try:\n            if project_number is None:\n                self.logger.info(\"[get_project_po_folders_with_link] - \ud83d\udcc1 No project_number provided. Retrieving all PO folders under the '2024' namespace.\")\n                all_projects = self.list_all_projects(namespace='2024')\n                if not all_projects:\n                    self.logger.warning(\"[get_project_po_folders_with_link] - \u26a0\ufe0f No projects found under the '2024' namespace.\")\n                    return []\n                for project in all_projects:\n                    current_project_number = project['id']\n                    project_folder_path = project['path']\n                    po_base_path = f'{project_folder_path}/1. Purchase Orders'\n                    po_folders = self.list_project_po_folders(po_base_path)\n                    if not po_folders:\n                        self.logger.info(f\"[get_project_po_folders_with_link] - \u2139\ufe0f No PO folders found for project_number={current_project_number} at '{po_base_path}'\")\n                        continue\n                    for po_folder in po_folders:\n                        po_link = self.create_share_link(po_folder['path'])\n                        project_po_data.append({'po_folder_name': po_folder['name'], 'po_folder_path': po_folder['path'], 'po_folder_link': po_link})\n            elif project_number and po_number is None:\n                self.logger.info(f'[get_project_po_folders_with_link] - \ud83d\udcc1 Retrieving PO folders for project_number={project_number}')\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f'[get_project_po_folders_with_link] - \u26a0\ufe0f Unable to find project folder for project_number={project_number}')\n                    return []\n                po_base_path = f'{project_folder_path}/1. Purchase Orders'\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"[get_project_po_folders_with_link] - \u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n                for po_folder in po_folders:\n                    po_link = self.create_share_link(po_folder['path'])\n                    project_po_data.append({'po_folder_name': po_folder['name'], 'po_folder_path': po_folder['path'], 'po_folder_link': po_link})\n            elif project_number and po_number:\n                self.logger.info(f'[get_project_po_folders_with_link] - \ud83d\udcc1 Retrieving PO folder for project_number={project_number} and po_number={po_number}')\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f'[get_project_po_folders_with_link] - \u26a0\ufe0f Unable to find project folder for project_number={project_number}')\n                    return []\n                formatted_po_number = f'{int(po_number):02}'\n                self.logger.debug(f'[get_project_po_folders_with_link] - \ud83d\udccc Formatted po_number: {formatted_po_number}')\n                po_base_path = f'{project_folder_path}/1. Purchase Orders'\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"[get_project_po_folders_with_link] - \u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n                specific_po_folder = next((po for po in po_folders if po['name'].startswith(f'{project_number}_{formatted_po_number}')), None)\n                if specific_po_folder:\n                    po_link = self.create_share_link(specific_po_folder['path'])\n                    project_po_data.append({'po_folder_name': specific_po_folder['name'], 'po_folder_path': specific_po_folder['path'], 'po_folder_link': po_link})\n                else:\n                    self.logger.warning(f'[get_project_po_folders_with_link] - \u26a0\ufe0f PO folder with po_number={formatted_po_number} not found in project_number={project_number}')\n                    return []\n            else:\n                self.logger.error('[get_project_po_folders_with_link] - \u2757 Invalid combination of parameters provided.')\n                return []\n        except Exception as e:\n            self.logger.exception(f'[get_project_po_folders_with_link] - \ud83d\udca5 An error occurred while retrieving PO folders: {e}')\n            return []\n        self.logger.info(f'[get_project_po_folders_with_link] - \u2705 Retrieved {len(project_po_data)} PO folders based on the provided parameters.')\n        return project_po_data"
                    },
                    {
                        "name": "list_all_projects",
                        "args": [
                            "self",
                            "namespace"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists all project folders under the specified namespace.\n\nArgs:\n    namespace (str): The namespace (e.g., '2024') under which all projects reside.\n\nReturns:\n    List[Dict[str, str]]: A list of projects, each dict with 'id' and 'path'.",
                        "function_body": "    def list_all_projects(self, namespace: str) -> List[Dict[str, str]]:\n        \"\"\"\n        Lists all project folders under the specified namespace.\n\n        Args:\n            namespace (str): The namespace (e.g., '2024') under which all projects reside.\n\n        Returns:\n            List[Dict[str, str]]: A list of projects, each dict with 'id' and 'path'.\n        \"\"\"\n        dbx_namespaced = self.dbx.with_path_root(common.PathRoot.namespace_id(self.dbx_client.namespace_id))\n        base_path = ''\n        try:"
                    },
                    {
                        "name": "find_project_folder",
                        "args": [
                            "self",
                            "project_number",
                            "namespace"
                        ],
                        "decorators": [],
                        "calls": [
                            "list_all_projects"
                        ],
                        "docstring": "Searches for a folder whose name (or metadata) contains the given project_number under the specified namespace.\n\nArgs:\n    project_number (str): The ID of the project.\n    namespace (str): The namespace under which projects are stored. Defaults to '2024'.\n\nReturns:\n    Optional[str]: The path_lower of the matched project folder if found, else None.",
                        "function_body": "    def find_project_folder(self, project_number: str, namespace: str='2024') -> Optional[str]:\n        \"\"\"\n        Searches for a folder whose name (or metadata) contains the given project_number under the specified namespace.\n\n        Args:\n            project_number (str): The ID of the project.\n            namespace (str): The namespace under which projects are stored. Defaults to '2024'.\n\n        Returns:\n            Optional[str]: The path_lower of the matched project folder if found, else None.\n        \"\"\"\n        self.logger.info(f\"[find_project_folder] - \ud83d\udd0d Searching for project folder with project_number='{project_number}' in namespace='{namespace}'.\")\n        all_projects = self.list_all_projects(namespace=namespace)\n        if not all_projects:\n            self.logger.warning(f\"[find_project_folder] - \u26a0\ufe0f No projects found in namespace='{namespace}'.\")\n            return None\n        for project in all_projects:\n            if str(project_number) in project['id']:\n                self.logger.debug(f\"[find_project_folder] - \u2705 Found project folder: '{project['id']}' at '{project['path']}'\")\n                return project['path']\n        self.logger.warning(f\"[find_project_folder] - \u26a0\ufe0f Project folder with project_number='{project_number}' not found in namespace='{namespace}'.\")\n        return None"
                    },
                    {
                        "name": "create_share_link",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a shared link for the specified Dropbox path within the team namespace.\n\nArgs:\n    dropbox_path (str): The path in Dropbox for which to create a share link.\n\nReturns:\n    Optional[str]: The shared link if successful, else None.",
                        "function_body": "    def create_share_link(self, dropbox_path: str) -> Optional[str]:\n        \"\"\"\n        Creates a shared link for the specified Dropbox path within the team namespace.\n\n        Args:\n            dropbox_path (str): The path in Dropbox for which to create a share link.\n\n        Returns:\n            Optional[str]: The shared link if successful, else None.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "list_project_po_folders",
                        "args": [
                            "self",
                            "po_base_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists all PO folders under the given project's Purchase Orders directory.\nThis method was already provided, but in case it wasn't implemented, here is a sample implementation.\n\nArgs:\n    po_base_path (str): The path to the project's \"1. Purchase Orders\" directory in Dropbox.\n\nReturns:\n    list: A list of dictionaries representing PO folders, each dict containing 'name' and 'path'.",
                        "function_body": "    def list_project_po_folders(self, po_base_path: str) -> list:\n        \"\"\"\n        Lists all PO folders under the given project's Purchase Orders directory.\n        This method was already provided, but in case it wasn't implemented, here is a sample implementation.\n\n        Args:\n            po_base_path (str): The path to the project's \"1. Purchase Orders\" directory in Dropbox.\n\n        Returns:\n            list: A list of dictionaries representing PO folders, each dict containing 'name' and 'path'.\n        \"\"\"\n        self.logger.debug(f\"[list_project_po_folders] - \ud83d\udcc2 Listing PO folders under '{po_base_path}'\")\n        all_entries = []\n        dbx_namespaced = self.dbx.with_path_root(common.PathRoot.namespace_id(self.dbx_client.namespace_id))\n        try:\n            result = dbx_namespaced.files_list_folder(path=po_base_path, recursive=False)\n            all_entries.extend(result.entries)\n            while result.has_more:\n                result = dbx_namespaced.files_list_folder_continue(result.cursor)\n                all_entries.extend(result.entries)\n        except ApiError as e:\n            self.logger.exception(f'[list_project_po_folders] - \ud83d\udca5 Error listing PO folders in Dropbox under {po_base_path}: {e}', exc_info=True)\n            return []\n        except Exception as e:\n            self.logger.exception(f'[list_project_po_folders] - \ud83d\udca5 Unexpected error listing PO folders under {po_base_path}: {e}', exc_info=True)\n            return []\n        folders = []\n        for entry in all_entries:\n            if isinstance(entry, FolderMetadata):\n                folder_path = entry.path_lower if entry.path_lower else entry.path_display\n                folders.append({'name': entry.name, 'path': folder_path})\n        self.logger.debug(f\"[list_project_po_folders] - \u2705 Found {len(folders)} folders under '{po_base_path}'.\")\n        return folders"
                    },
                    {
                        "name": "_update_monday_tax_form_link",
                        "args": [
                            "self",
                            "pulse_id",
                            "new_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item"
                        ],
                        "docstring": "Update Monday contact's tax_form_link column with the new link.",
                        "function_body": "    def _update_monday_tax_form_link(self, pulse_id, new_link):\n        \"\"\"\n        Update Monday contact's tax_form_link column with the new link.\n        \"\"\"\n        if not pulse_id:\n            self.logger.warning('[_update_monday_tax_form_link] - No pulse_id to update Monday link.')\n            return\n        link_value = {'url': new_link, 'text': 'Tax Form'}\n        column_values = {'tax_form_link_column': json.dumps(link_value)}\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_api",
                "value": "DropboxAPI()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_util.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "retrieve_subitem_board_id"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, \"_initialized\"):"
                    },
                    {
                        "name": "SUBITEM_BOARD_ID",
                        "args": [
                            "self"
                        ],
                        "decorators": [
                            "property"
                        ],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def SUBITEM_BOARD_ID(self):\n        return self._subitem_board_id"
                    },
                    {
                        "name": "retrieve_subitem_board_id",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_subitems_column_id",
                            "get_subitem_board_id"
                        ],
                        "docstring": "Retrieves the subitem board ID by first fetching the subitems\ncolumn ID and then extracting the board ID from its settings.\n\nReturns:\n    str: The subitem board ID.\n\nRaises:\n    Exception: If unable to retrieve the subitem board ID.",
                        "function_body": "    def retrieve_subitem_board_id(self):\n        \"\"\"\n        Retrieves the subitem board ID by first fetching the subitems\n        column ID and then extracting the board ID from its settings.\n\n        Returns:\n            str: The subitem board ID.\n\n        Raises:\n            Exception: If unable to retrieve the subitem board ID.\n        \"\"\"\n        subitems_column_id = self.get_subitems_column_id(self.PO_BOARD_ID)\n        subitem_board_id = self.get_subitem_board_id(subitems_column_id)\n        return subitem_board_id"
                    },
                    {
                        "name": "get_subitems_column_id",
                        "args": [
                            "self",
                            "parent_board_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the column ID for subitems in a given board.\n\nArgs:\n    parent_board_id (str): The ID of the parent board.\n\nReturns:\n    str: The column ID for subitems.\n\nRaises:\n    Exception: If the subitems column is not found or the\n    API request fails.",
                        "function_body": "    def get_subitems_column_id(self, parent_board_id):\n        \"\"\"\n        Retrieves the column ID for subitems in a given board.\n\n        Args:\n            parent_board_id (str): The ID of the parent board.\n\n        Returns:\n            str: The column ID for subitems.\n\n        Raises:\n            Exception: If the subitems column is not found or the\n            API request fails.\n        \"\"\"\n        query = (\n            f\"\\n        query {{\\n            boards(ids: {parent_board_id}) \"\n            \"{\\n                columns {\\n                    id\\n                    \"\n            \"type\\n                }\\n            }\\n        }\\n        \"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL, headers=self.headers, json={\"query\": query}\n        )\n        data = response.json()\n\n        if response.status_code == 200 and \"data\" in data:"
                    },
                    {
                        "name": "get_subitem_board_id",
                        "args": [
                            "self",
                            "subitems_column_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the subitem board ID for a given subitems column ID.\n\nArgs:\n    subitems_column_id (str): The ID of the subitems column.\n\nReturns:\n    str: The subitem board ID.\n\nRaises:\n    Exception: If the subitem board ID cannot be retrieved.",
                        "function_body": "    def get_subitem_board_id(self, subitems_column_id):\n        \"\"\"\n        Retrieves the subitem board ID for a given subitems column ID.\n\n        Args:\n            subitems_column_id (str): The ID of the subitems column.\n\n        Returns:\n            str: The subitem board ID.\n\n        Raises:\n            Exception: If the subitem board ID cannot be retrieved.\n        \"\"\"\n        query = (\n            f\"\\n        query {{\\n            boards(ids: {self.PO_BOARD_ID}) \"\n            f'{{\\n                columns(ids: \"{subitems_column_id}\") '\n            \"{\\n                    settings_str\\n                }\\n            }\"\n            \"\\n        }\\n        \"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL, headers=self.headers, json={\"query\": query}\n        )\n        data = response.json()\n\n        if response.status_code == 200 and \"data\" in data:"
                    },
                    {
                        "name": "_handle_date_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Date handler for columns, extracting a single date.",
                        "function_body": "    def _handle_date_column(self, event):\n        \"\"\"\n        Date handler for columns, extracting a single date.\n        \"\"\"\n        return event.get(\"value\", {}).get(\"date\", {})"
                    },
                    {
                        "name": "_handle_link_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handles link column type and extracts URL.",
                        "function_body": "    def _handle_link_column(self, event):\n        \"\"\"\n        Handles link column type and extracts URL.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "_handle_dropdown_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handles dropdown column type and extracts chosen values.",
                        "function_body": "    def _handle_dropdown_column(self, event):\n        \"\"\"\n        Handles dropdown column type and extracts chosen values.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "_handle_default_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Default handler for columns, extracting a single text label.",
                        "function_body": "    def _handle_default_column(self, event):\n        \"\"\"\n        Default handler for columns, extracting a single text label.\n        \"\"\"\n        if not event or not event.get(\"value\"):\n            return None\n        return event[\"value\"].get(\"value\")"
                    },
                    {
                        "name": "_handle_status_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handles status column type and extracts the label text.",
                        "function_body": "    def _handle_status_column(self, event):\n        \"\"\"\n        Handles status column type and extracts the label text.\n        \"\"\"\n        return event.get(\"value\", {}).get(\"label\", {}).get(\"text\")"
                    },
                    {
                        "name": "get_column_handler",
                        "args": [
                            "self",
                            "column_type"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the appropriate handler method based on the column type.",
                        "function_body": "    def get_column_handler(self, column_type):\n        \"\"\"\n        Retrieves the appropriate handler method based on the column type.\n        \"\"\"\n        handler_name = self.COLUMN_TYPE_HANDLERS.get(\n            column_type, \"handle_default_column\"\n        )\n        return getattr(self, f\"_{handler_name}\")"
                    },
                    {
                        "name": "create_item",
                        "args": [
                            "self",
                            "group_id",
                            "item_name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a new item in Monday.com within the specified group.\n\nArgs:\n    group_id (str): The ID of the group where the item will be created.\n    item_name (str): The name of the new item.\n    column_values (dict): A dictionary of column IDs and their\n        corresponding values.\n\nReturns:\n    str or None: The ID of the created item if successful, else None.",
                        "function_body": "    def create_item(self, group_id, item_name, column_values):\n        \"\"\"\n        Creates a new item in Monday.com within the specified group.\n\n        Args:\n            group_id (str): The ID of the group where the item will be created.\n            item_name (str): The name of the new item.\n            column_values (dict): A dictionary of column IDs and their\n                corresponding values.\n\n        Returns:\n            str or None: The ID of the created item if successful, else None.\n        \"\"\"\n        query = (\n            \"\\n        mutation ($board_id: ID!, $group_id: String!, \"\n            \"$item_name: String!, $column_values: JSON!) {\\n            \"\n            \"create_item(\\n                board_id: $board_id,\\n\"\n            \"                group_id: $group_id,\\n                \"\n            \"item_name: $item_name,\\n                column_values: \"\n            \"$column_values\\n            ) {\\n                id\\n\"\n            \"                name\\n            }\\n        }\\n        \"\n        )\n        serialized_column_values = json.dumps(column_values)\n        variables = {\n            \"board_id\": self.PO_BOARD_ID,\n            \"group_id\": group_id,\n            \"item_name\": item_name,\n            \"column_values\": serialized_column_values,\n        }\n\n        self.logger.info(\n            f\"[create_item] - Creating item with variables: {variables}\"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL,\n            headers=self.headers,\n            json={\"query\": query, \"variables\": variables},\n        )\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "update_item_columns",
                        "args": [
                            "self",
                            "item_id",
                            "column_values",
                            "board"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Updates multiple columns of an item in Monday.com.\n\nArgs:\n    item_id (str): The ID of the item to update.\n    column_values (dict): A dictionary of column IDs and their\n        corresponding values.\n    board (str): Which board to update (e.g. 'po', 'contact',\n        or 'subitem').\n\nReturns:\n    bool: True if the update was successful, False otherwise.",
                        "function_body": "    def update_item_columns(self, item_id, column_values, board=\"po\"):\n        \"\"\"\n        Updates multiple columns of an item in Monday.com.\n\n        Args:\n            item_id (str): The ID of the item to update.\n            column_values (dict): A dictionary of column IDs and their\n                corresponding values.\n            board (str): Which board to update (e.g. 'po', 'contact',\n                or 'subitem').\n\n        Returns:\n            bool: True if the update was successful, False otherwise.\n        \"\"\"\n        column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n        if board == \"po\":\n            board_id = self.PO_BOARD_ID\n        elif board == \"contact\":\n            board_id = self.CONTACT_BOARD_ID\n        elif board == \"subitem\":\n            board_id = self.SUBITEM_BOARD_ID\n        else:\n            board_id = self.PO_BOARD_ID\n\n        query = (\n            f\"\\n        mutation {{\\n            \"\n            f\"change_multiple_column_values(\\n                board_id: \"\n            f\"{board_id},\\n                item_id: {item_id},\\n\"\n            f'                column_values: \"{column_values_json}\"\\n'\n            f\"            ) {{\\n                id\\n            }}\\n\"\n            f\"        }}\\n        \"\n        )\n\n        self.logger.info(\n            f\"[update_item_columns] - Updating item {item_id} with columns: \"\n            f\"{column_values}\"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL, headers=self.headers, json={\"query\": query}\n        )\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "po_column_values_formatter",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "tax_id",
                            "description",
                            "contact_pulse_id",
                            "folder_link",
                            "status",
                            "producer_id",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def po_column_values_formatter(\n            self,\n            project_id=None,\n            po_number=None,\n            tax_id=None,\n            description=None,\n            contact_pulse_id=None,\n            folder_link=None,\n            status=None,\n            producer_id=None,\n            name=None,\n    ):\n        column_values = {}\n\n        # Convert numeric values to strings\n        if project_id:\n            column_values[self.PO_PROJECT_ID_COLUMN] = str(project_id)\n        if name:\n            # Convert set to list if needed\n            column_values[\"name\"] = list(name) if isinstance(name, set) else name\n        if po_number:\n            column_values[self.PO_NUMBER_COLUMN] = str(po_number)\n        if tax_id:\n            column_values[self.PO_TAX_COLUMN_ID] = str(tax_id)\n        if description:\n            column_values[self.PO_DESCRIPTION_COLUMN_ID] = description\n        if contact_pulse_id:\n            # Correctly structure the linkedPulseIds as a list of objects with a pulseId key\n            column_values[self.PO_CONTACT_CONNECTION_COLUMN_ID] = {\n                 \"linkedPulseIds\": [{\"linkedPulseId\": contact_pulse_id}]\n            }\n        if folder_link:\n            column_values[self.PO_FOLDER_LINK_COLUMN_ID] = {\n                \"url\": folder_link,\n                \"text\": \"\ud83d\udce6\",\n            }\n        if producer_id:\n            column_values[self.PO_PRODUCER_COLUMN_ID] = {\n                \"personsAndTeams\": [{\"id\": str(producer_id), \"kind\": \"person\"}]\n            }\n\n        # Convert any set values to lists (if necessary)\n        for key, value in column_values.items():\n            if isinstance(value, set):\n                column_values[key] = list(value)\n\n        return json.dumps(column_values)"
                    },
                    {
                        "name": "prep_po_log_item_for_monday",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def prep_po_log_item_for_monday(self, item):\n        pass"
                    },
                    {
                        "name": "subitem_column_values_formatter",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "detail_number",
                            "line_number",
                            "notes",
                            "status",
                            "description",
                            "quantity",
                            "rate",
                            "date",
                            "due_date",
                            "account_number",
                            "link",
                            "OT",
                            "fringes",
                            "xero_link"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def subitem_column_values_formatter(\n            self,\n            project_id=None,\n            po_number=None,\n            detail_number=None,\n            line_number=None,\n            notes=None,\n            status=None,\n            description=None,\n            quantity=None,\n            rate=None,\n            date=None,\n            due_date=None,\n            account_number=None,\n            link=None,\n            OT=None,\n            fringes=None,\n            xero_link=None,\n    ):\n        column_values = {}\n\n        if notes:\n            column_values[self.SUBITEM_NOTES_COLUMN_ID] = notes\n        if status:\n            column_values[self.SUBITEM_STATUS_COLUMN_ID] = {\"label\": status}\n        if description:\n            column_values[self.SUBITEM_DESCRIPTION_COLUMN_ID] = description\n\n        if quantity is not None:\n            try:\n                cleaned_quantity = float(str(quantity).replace(\",\", \"\").strip())\n                # Convert to string for the numeric column\n                column_values[self.SUBITEM_QUANTITY_COLUMN_ID] = str(cleaned_quantity)\n            except ValueError as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Invalid quantity '{quantity}': {e}\"\n                )\n                column_values[self.SUBITEM_QUANTITY_COLUMN_ID] = None\n\n        if rate is not None:\n            try:\n                cleaned_rate = float(str(rate).replace(\",\", \"\").strip())\n                column_values[self.SUBITEM_RATE_COLUMN_ID] = str(cleaned_rate)\n            except ValueError as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Invalid rate '{rate}': {e}\"\n                )\n                column_values[self.SUBITEM_RATE_COLUMN_ID] = None\n\n        if OT is not None:\n            try:\n                cleaned_OT = float(str(OT).replace(\",\", \"\").strip())\n                column_values[self.SUBITEM_OT_COLUMN_ID] = str(cleaned_OT)\n            except ValueError as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Invalid OT '{OT}': {e}\"\n                )\n                column_values[self.SUBITEM_OT_COLUMN_ID] = None\n\n        if fringes is not None:\n            try:\n                cleaned_fringe = float(str(fringes).replace(\",\", \"\").strip())\n                column_values[self.SUBITEM_FRINGE_COLUMN_ID] = str(cleaned_fringe)\n            except ValueError as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Invalid fringes '{fringes}': {e}\"\n                )\n                column_values[self.SUBITEM_FRINGE_COLUMN_ID] = None\n\n        if date:\n            try:\n                if isinstance(date, str) and date.strip():\n                    parsed_date = parser.parse(date.strip())\n                elif isinstance(date, datetime):\n                    parsed_date = date\n                else:\n                    raise ValueError(\"Unsupported date format\")\n                column_values[self.SUBITEM_DATE_COLUMN_ID] = {\n                    \"date\": parsed_date.strftime(\"%Y-%m-%d\")\n                }\n            except Exception as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Error parsing date '{date}': {e}\"\n                )\n\n        if due_date:\n            try:\n                if isinstance(due_date, str) and due_date.strip():\n                    parsed_due_date = parser.parse(due_date.strip())\n                elif isinstance(due_date, datetime):\n                    parsed_due_date = due_date\n                else:\n                    raise ValueError(\"Unsupported due_date format\")\n                column_values[self.SUBITEM_DUE_DATE_COLUMN_ID] = {\n                    \"date\": parsed_due_date.strftime(\"%Y-%m-%d\")\n                }\n            except Exception as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Error parsing due_date '{due_date}': {e}\"\n                )\n                raise\n\n        if account_number:\n            try:\n                cleaned_account_number = re.sub(\"[^\\\\d]\", \"\", str(account_number).strip())\n                if cleaned_account_number:\n                    column_values[self.SUBITEM_ACCOUNT_NUMBER_COLUMN_ID] = str(\n                        int(cleaned_account_number)\n                    )\n                else:\n                    raise ValueError(\n                        f\"Account number '{account_number}' invalid after cleaning.\"\n                    )\n            except (ValueError, TypeError) as e:\n                self.logger.error(\n                    f\"[subitem_column_values_formatter] - Invalid account number '{account_number}': {e}\"\n                )\n                column_values[self.SUBITEM_ACCOUNT_NUMBER_COLUMN_ID] = None\n\n        if link:\n            column_values[self.SUBITEM_LINK_COLUMN_ID] = {\n                \"url\": link,\n                \"text\": \"\ud83e\uddfe\",\n            }\n\n        if xero_link:\n            column_values[self.SUBITEM_XERO_LINK_COLUMN_ID] = {\n                \"url\": xero_link,\n                \"text\": \"\ud83d\udcca\",\n            }\n\n        if po_number is not None:\n            column_values[self.SUBITEM_PO_COLUMN_ID] = po_number\n\n        if detail_number is not None:\n            column_values[self.SUBITEM_ID_COLUMN_ID] = detail_number\n\n        if line_number is not None:\n            column_values[self.SUBITEM_LINE_NUMBER_COLUMN_ID] = line_number\n\n        if project_id is not None:\n            column_values[self.SUBITEM_PROJECT_ID_COLUMN_ID] = project_id\n\n        for (key, value) in column_values.items():\n            if isinstance(value, set):\n                column_values[key] = list(value)\n\n        return json.dumps(column_values)"
                    },
                    {
                        "name": "create_subitem",
                        "args": [
                            "self",
                            "parent_item_id",
                            "subitem_name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a subitem in Monday.com under a given parent item.\n\nArgs:\n    parent_item_id (str): The ID of the parent item to attach\n        the subitem to.\n    subitem_name (str): The name of the subitem.\n    column_values (dict): A dictionary of column IDs and their\n        corresponding values.\n\nReturns:\n    str or None: The ID of the created subitem if successful,\n    else None.",
                        "function_body": "    def create_subitem(self, parent_item_id, subitem_name, column_values):\n        \"\"\"\n        Creates a subitem in Monday.com under a given parent item.\n\n        Args:\n            parent_item_id (str): The ID of the parent item to attach\n                the subitem to.\n            subitem_name (str): The name of the subitem.\n            column_values (dict): A dictionary of column IDs and their\n                corresponding values.\n\n        Returns:\n            str or None: The ID of the created subitem if successful,\n            else None.\n        \"\"\"\n        column_values = {\n            k: v for (k, v) in column_values.items() if v is not None\n        }\n        column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n        query = (\n            f'\\n        mutation {{\\n            create_subitem (\\n'\n            f'                parent_item_id: \"{parent_item_id}\",\\n'\n            f'                item_name: \"{subitem_name}\",\\n'\n            f'                column_values: \"{column_values_json}\"\\n'\n            f\"            ) {{\\n                id\\n            }}\\n\"\n            f\"        }}\\n        \"\n        )\n\n        self.logger.info(\n            f\"[create_subitem] - Creating subitem under parent \"\n            f\"{parent_item_id} with name '{subitem_name}'.\"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL, headers=self.headers, json={\"query\": query}\n        )\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "update_subitem_columns",
                        "args": [
                            "self",
                            "subitem_id",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Updates the specified columns of a subitem in Monday.com.\n\nArgs:\n    subitem_id (str): The ID of the subitem to update.\n    column_values (dict): A dictionary where keys are column IDs\n        and values are the new values for those columns.\n\nReturns:\n    bool: True if the update was successful, False otherwise.",
                        "function_body": "    def update_subitem_columns(self, subitem_id, column_values):\n        \"\"\"\n        Updates the specified columns of a subitem in Monday.com.\n\n        Args:\n            subitem_id (str): The ID of the subitem to update.\n            column_values (dict): A dictionary where keys are column IDs\n                and values are the new values for those columns.\n\n        Returns:\n            bool: True if the update was successful, False otherwise.\n        \"\"\"\n        column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n        mutation = (\n            f\"\\n        mutation {{\\n            \"\n            f\"change_multiple_column_values(\\n                board_id: \"\n            f\"{self.SUBITEM_BOARD_ID},\\n                item_id: {subitem_id},\\n\"\n            f'                column_values: \"{column_values_json}\"\\n'\n            f\"            ) {{\\n                id\\n            }}\\n\"\n            f\"        }}\\n        \"\n        )\n\n        self.logger.info(\n            f\"[update_subitem_columns] - Updating subitem {subitem_id} \"\n            f\"with columns: {column_values}\"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL, headers=self.headers, json={\"query\": mutation}\n        )\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "prep_po_log_detail_for_monday",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def prep_po_log_detail_for_monday(self, item):\n        pass"
                    },
                    {
                        "name": "link_contact_to_po_item",
                        "args": [
                            "self",
                            "po_item_id",
                            "contact_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Links a contact item from the Contacts board to a PO item\nin the PO board using the Connect Boards column.\n\nArgs:\n    po_item_id (str): The ID of the PO item in the PO board.\n    contact_item_id (str): The ID of the contact item in the\n        Contacts board.\n\nReturns:\n    bool: True if the link was successful, False otherwise.",
                        "function_body": "    def link_contact_to_po_item(self, po_item_id, contact_item_id):\n        \"\"\"\n        Links a contact item from the Contacts board to a PO item\n        in the PO board using the Connect Boards column.\n\n        Args:\n            po_item_id (str): The ID of the PO item in the PO board.\n            contact_item_id (str): The ID of the contact item in the\n                Contacts board.\n\n        Returns:\n            bool: True if the link was successful, False otherwise.\n        \"\"\"\n        connect_boards_column_id = self.PO_CONTACT_CONNECTION_COLUMN_ID\n        column_value = {\"linkedPulseIds\": [contact_item_id]}\n        column_value_json = json.dumps(column_value).replace('\"', '\\\\\"')\n\n        mutation = (\n            f\"\\n        mutation {{\\n            change_column_value(\\n\"\n            f\"                board_id: {self.PO_BOARD_ID},\\n\"\n            f\"                item_id: {po_item_id},\\n\"\n            f'                column_id: \"{connect_boards_column_id}\",\\n'\n            f'                value: \"{column_value_json}\"\\n'\n            f\"            ) {{\\n                id\\n            }}\\n\"\n            f\"        }}\\n        \"\n        )\n\n        self.logger.info(\n            f\"[link_contact_to_po_item] - Linking contact {contact_item_id} \"\n            f\"to PO item {po_item_id}.\"\n        )\n\n        response = requests.post(\n            self.MONDAY_API_URL, headers=self.headers, json={\"query\": mutation}\n        )\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "prep_po_log_contact_for_monday",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def prep_po_log_contact_for_monday(self, item):\n        pass"
                    },
                    {
                        "name": "validate_monday_request",
                        "args": [
                            "self",
                            "request_headers"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Validates incoming webhook requests from Monday.com\nusing the API token.\n\nArgs:\n    request_headers (dict): The headers from the incoming request.\n\nReturns:\n    bool: True if the request is valid, False otherwise.",
                        "function_body": "    def validate_monday_request(self, request_headers):\n        \"\"\"\n        Validates incoming webhook requests from Monday.com\n        using the API token.\n\n        Args:\n            request_headers (dict): The headers from the incoming request.\n\n        Returns:\n            bool: True if the request is valid, False otherwise.\n        \"\"\"\n        token = request_headers.get(\"Authorization\")\n\n        if not token:\n            self.logger.warning(\n                \"[validate_monday_request] - Missing 'Authorization' header.\"\n            )\n            return False\n\n        try:\n            received_token = token.split()[1]\n        except IndexError:\n            self.logger.warning(\n                \"[validate_monday_request] - Invalid 'Authorization' \"\n                \"header format.\"\n            )\n            return False\n\n        if received_token != self.monday_api_token:\n            self.logger.warning(\"[validate_monday_request] - Invalid API token.\")\n            return False\n\n        self.logger.info(\"[validate_monday_request] - Request validated successfully.\")\n        return True"
                    },
                    {
                        "name": "get_item_data",
                        "args": [
                            "self",
                            "monday_response"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_item_data(self, monday_response):\n        item_dict = monday_response[\"data\"][\"items\"][0]\n        columns_dict = {item[\"id\"]: item for item in item_dict[\"column_values\"]}\n        return item_dict, columns_dict"
                    },
                    {
                        "name": "get_contact_pulse_id",
                        "args": [
                            "self",
                            "columns_dict"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_contact_pulse_id(self, columns_dict):\n        parsed_value = json.loads(columns_dict[\"value\"])\n        linked_pulse_id = [\n            item[\"linkedPulseId\"]\n            for item in parsed_value.get(\"linkedPulseIds\", [])\n        ]\n        return linked_pulse_id"
                    },
                    {
                        "name": "is_main_item_different",
                        "args": [
                            "self",
                            "db_item",
                            "monday_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def is_main_item_different(self, db_item, monday_item):\n        differences = []\n        col_vals = monday_item[\"column_values\"]\n        linked_pulse_id = None\n\n        if \"connect_boards1\" in col_vals and col_vals[\"connect_boards1\"]:\n            if \"value\" in col_vals[\"connect_boards1\"]:\n                if json.loads(col_vals[\"connect_boards1\"][\"value\"]):\n                    if json.loads(col_vals[\"connect_boards1\"][\"value\"]).get(\n                        \"linkedPulseIds\"\n                    ):\n                        linked_pulse_id = (\n                            json.loads(\n                                col_vals[\"connect_boards1\"][\"value\"]\n                            ).get(\"linkedPulseIds\")[0][\"linkedPulseId\"]\n                        )\n\n        field_map = [\n            {\n                \"field\": \"project_number\",\n                \"db_value\": db_item.get(\"project_number\"),\n                \"monday_value\": col_vals.get(\"project_id\")[\"text\"],\n            },\n            {\n                \"field\": \"contact_name\",\n                \"db_value\": db_item.get(\"contact_name\"),\n                \"monday_value\": monday_item.get(\"name\"),\n            },\n            {\n                \"field\": \"PO\",\n                \"db_value\": str(db_item.get(\"po_number\")),\n                \"monday_value\": col_vals.get(\"numeric__1\")[\"text\"],\n            },\n            {\n                \"field\": \"description\",\n                \"db_value\": db_item.get(\"description\"),\n                \"monday_value\": col_vals.get(\"text6\")[\"text\"],\n            },\n            {\n                \"field\": \"Connected Contact\",\n                \"db_value\": db_item.get(\"contact_pulse_id\"),\n                \"monday_value\": linked_pulse_id,\n            },\n        ]\n\n        for f in field_map:\n            db_val = f[\"db_value\"] if f[\"db_value\"] is not None else \"\"\n            mon_val = f[\"monday_value\"] if f[\"monday_value\"] is not None else \"\"\n            db_str = str(db_val).strip()\n            mon_str = str(mon_val).strip()\n\n            if db_str != mon_str:\n                differences.append(\n                    {\n                        \"field\": f[\"field\"],\n                        \"db_value\": db_str,\n                        \"monday_value\": mon_str,\n                    }\n                )\n        return differences"
                    },
                    {
                        "name": "is_sub_item_different",
                        "args": [
                            "self",
                            "db_sub_item",
                            "monday_sub_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def is_sub_item_different(self, db_sub_item, monday_sub_item):\n        differences = []\n        col_vals = monday_sub_item[\"column_values\"]\n\n        def safe_str(val):\n            return str(val).strip() if val is not None else \"\"\n\n        def are_values_equal(db_val, monday_val):\n            try:\n                return float(db_val) == float(monday_val)\n            except ValueError:\n                return db_val == monday_val\n\n        field_map = [\n            {\n                \"field\": \"quantity\",\n                \"db_value\": safe_str(db_sub_item.get(\"quantity\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_QUANTITY_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"file_link\",\n                \"db_value\": safe_str(db_sub_item.get(\"file_link\")),\n                \"monday_value\": safe_str(\n                    json.loads(\n                        col_vals.get(self.SUBITEM_LINK_COLUMN_ID)[\"value\"]\n                        or \"{}\"\n                    ).get(\"url\")\n                ),\n            },\n            {\n                \"field\": \"detail_number\",\n                \"db_value\": safe_str(db_sub_item.get(\"detail_number\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_ID_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"line_number\",\n                \"db_value\": safe_str(db_sub_item.get(\"line_number\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_LINE_NUMBER_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"rate\",\n                \"db_value\": safe_str(db_sub_item.get(\"rate\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_RATE_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"account_code\",\n                \"db_value\": safe_str(db_sub_item.get(\"account_code\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_ACCOUNT_NUMBER_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"ot\",\n                \"db_value\": safe_str(db_sub_item.get(\"ot\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_OT_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"state\",\n                \"db_value\": safe_str(db_sub_item.get(\"state\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_STATUS_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"fringes\",\n                \"db_value\": safe_str(db_sub_item.get(\"fringes\")),\n                \"monday_value\": safe_str(\n                    col_vals.get(self.SUBITEM_FRINGE_COLUMN_ID)[\"text\"]\n                ),\n            },\n            {\n                \"field\": \"transaction_date\",\n                \"db_value\": safe_str(\n                    db_sub_item.get(\"transaction_date\")\n                ).split(\" \")[0]\n                if safe_str(db_sub_item.get(\"transaction_date\"))\n                else None,\n                \"monday_value\": safe_str(\n                    col_vals[self.SUBITEM_DATE_COLUMN_ID][\"text\"]\n                ),\n            },\n            {\n                \"field\": \"due_date\",\n                \"db_value\": safe_str(db_sub_item.get(\"due_date\")).split(\" \")[\n                    0\n                ]\n                if safe_str(db_sub_item.get(\"due_date\"))\n                else None,\n                \"monday_value\": safe_str(\n                    col_vals[self.SUBITEM_DUE_DATE_COLUMN_ID].get(\"text\")\n                    if isinstance(\n                        col_vals[self.SUBITEM_DUE_DATE_COLUMN_ID], dict\n                    )\n                    else col_vals[self.SUBITEM_DUE_DATE_COLUMN_ID]\n                ),\n            },\n        ]\n\n        for f in field_map:\n            if not are_values_equal(f[\"db_value\"], f[\"monday_value\"]):\n                differences.append(\n                    {\n                        \"field\": f[\"field\"],\n                        \"db_value\": f[\"db_value\"],\n                        \"monday_value\": f[\"monday_value\"],\n                    }\n                )\n        return differences"
                    },
                    {
                        "name": "extract_subitem_identifiers",
                        "args": [
                            "self",
                            "monday_sub_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_subitem_identifiers(self, monday_sub_item):\n        col_vals = monday_sub_item[\"column_values\"]\n\n        def safe_int(val):\n            try:\n                return int(val)\n            except (ValueError, TypeError):\n                return None\n\n        project_id = safe_int(float(col_vals[self.SUBITEM_PROJECT_ID_COLUMN_ID][\"text\"]))\n        po_number = safe_int(float(col_vals[self.SUBITEM_PO_COLUMN_ID][\"text\"]))\n        detail_num = safe_int(float(col_vals[self.SUBITEM_ID_COLUMN_ID][\"text\"]))\n        line_number = safe_int(float(col_vals[self.SUBITEM_LINE_NUMBER_COLUMN_ID][\"text\"]))\n\n        if ("
                    },
                    {
                        "name": "_extract_tax_link_from_monday",
                        "args": [
                            "self",
                            "pulse_id",
                            "all_monday_contacts"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Given a contact's Monday pulse_id, find that contact in\n`all_monday_contacts` and return the link's 'url' if it exists.",
                        "function_body": "    def _extract_tax_link_from_monday(self, pulse_id, all_monday_contacts):\n        \"\"\"\n        Given a contact's Monday pulse_id, find that contact in\n        `all_monday_contacts` and return the link's 'url' if it exists.\n        \"\"\"\n        if not pulse_id:\n            return None\n\n        for c in all_monday_contacts:\n            if c[\"id\"] == str(pulse_id):\n                for col in c.get(\"column_values\", []):\n                    if col[\"id\"] == self.CONTACT_TAX_FORM_LINK:\n                        try:\n                            val = json.loads(col[\"value\"])\n                            return val.get(\"url\")\n                        except:\n                            return col.get(\"text\")\n        return None"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_util",
                "value": "MondayUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_api.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayAPI",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83c\udfd7\ufe0f Sets up the Monday API singleton with proper logging, token initialization,\nand references to critical board and column IDs.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        \ud83c\udfd7\ufe0f Sets up the Monday API singleton with proper logging, token initialization,\n        and references to critical board and column IDs.\n        \"\"\"\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "_make_request",
                        "args": [
                            "self",
                            "query",
                            "variables"
                        ],
                        "decorators": [],
                        "calls": [
                            "_handle_graphql_errors",
                            "_log_complexity"
                        ],
                        "docstring": "\ud83d\udd12 Private Method: Executes a GraphQL request against the Monday.com API with:\n  - Complexity query insertion\n  - Retry logic for transient failures (e.g., connection errors)\n  - Handling of 429 (rate-limit) responses\n\n:param query: GraphQL query string\n:param variables: Optional variables dict\n:return: Parsed JSON response from Monday API\n:raises: ConnectionError if MAX_RETRIES exceeded or any unhandled error occurs",
                        "function_body": "    def _make_request(self, query: str, variables: dict=None):\n        \"\"\"\n        \ud83d\udd12 Private Method: Executes a GraphQL request against the Monday.com API with:\n          - Complexity query insertion\n          - Retry logic for transient failures (e.g., connection errors)\n          - Handling of 429 (rate-limit) responses\n\n        :param query: GraphQL query string\n        :param variables: Optional variables dict\n        :return: Parsed JSON response from Monday API\n        :raises: ConnectionError if MAX_RETRIES exceeded or any unhandled error occurs\n        \"\"\"\n        self.logger.debug(f\"GraphQL to Monday:\\n{query}\")\n        if 'complexity' not in query:\n            insertion_index = query.find('{', query.find('query') if 'query' in query else query.find('mutation'))\n            if insertion_index != -1:\n                query = query[:insertion_index + 1] + ' complexity { query before after } ' + query[insertion_index + 1:]\n        headers = {'Authorization': self.api_token}\n        attempt = 0\n        while attempt < MAX_RETRIES:\n            try:\n                self.logger.debug(f'\ud83d\udce1 Attempt {attempt + 1}/{MAX_RETRIES}: Sending request to Monday.com')\n                response = requests.post(self.api_url, json={'query': query, 'variables': variables}, headers=headers, timeout=200)\n                response.raise_for_status()\n                data = response.json()\n                if 'errors' in data:\n                    self._handle_graphql_errors(data['errors'])\n                self._log_complexity(data)\n                return data\n            except requests.exceptions.ConnectionError as ce:\n                self.logger.warning(f'\u26a0\ufe0f Connection error: {ce}. Attempt {attempt + 1}/{MAX_RETRIES}. Retrying...')\n                time.sleep(RETRY_BACKOFF_FACTOR ** (attempt + 1))\n                attempt += 1\n            except requests.exceptions.HTTPError as he:\n                self.logger.error(f'\u274c HTTP error encountered: {he}')\n                if response.status_code == 429:\n                    retry_after = response.headers.get('Retry-After', 10)\n                    self.logger.warning(f'\ud83d\udd04 Rate limit (429) hit. Waiting {retry_after} seconds before retry.')\n                    time.sleep(int(retry_after))\n                    attempt += 1\n                else:\n                    raise\n            except Exception as e:\n                self.logger.error(f'\u274c Unexpected exception during request: {e}')\n                raise\n        self.logger.error('\u274c Max retries reached without success. Failing the request.')\n        raise ConnectionError('Failed to complete request after multiple retries.')"
                    },
                    {
                        "name": "_handle_graphql_errors",
                        "args": [
                            "self",
                            "errors"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udd12 Private Method: Handles GraphQL-level errors returned by Monday.com.\nRaises specific exceptions based on error messages for clarity.",
                        "function_body": "    def _handle_graphql_errors(self, errors):\n        \"\"\"\n        \ud83d\udd12 Private Method: Handles GraphQL-level errors returned by Monday.com.\n        Raises specific exceptions based on error messages for clarity.\n        \"\"\"\n        for error in errors:"
                    },
                    {
                        "name": "_log_complexity",
                        "args": [
                            "self",
                            "data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udd12 Private Method: Logs complexity usage if available in the API response data.\nHelps track usage and avoid hitting Monday API limits.",
                        "function_body": "    def _log_complexity(self, data):\n        \"\"\"\n        \ud83d\udd12 Private Method: Logs complexity usage if available in the API response data.\n        Helps track usage and avoid hitting Monday API limits.\n        \"\"\"\n        complexity_info = data.get('data', {}).get('complexity', {})\n        if complexity_info:"
                    },
                    {
                        "name": "create_item",
                        "args": [
                            "self",
                            "board_id",
                            "group_id",
                            "name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83c\udfa8 Create a new item on a board.\n:param board_id: Board ID where the item will be created\n:param group_id: The group_id to place the item in\n:param name: Name of the new item\n:param column_values: Column values in JSON or dict format\n:return: GraphQL response",
                        "function_body": "    def create_item(self, board_id: int, group_id: str, name: str, column_values: dict):\n        \"\"\"\n        \ud83c\udfa8 Create a new item on a board.\n        :param board_id: Board ID where the item will be created\n        :param group_id: The group_id to place the item in\n        :param name: Name of the new item\n        :param column_values: Column values in JSON or dict format\n        :return: GraphQL response\n        \"\"\"\n        self.logger.debug(f\"[create_item] - \ud83c\udd95 Creating item on board {board_id}, name='{name}'...\")\n        query = '''\n        mutation ($board_id: ID!, $group_id: String, $item_name: String!, $column_values: JSON) {\n            create_item(board_id: $board_id, group_id: $group_id, item_name: $item_name, column_values: $column_values) {\n                id\n            }\n        }\n        '''\n        variables = {'board_id': int(board_id), 'item_name': name, 'column_values': column_values}\n        if group_id:\n            variables['group_id'] = group_id\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "create_subitem",
                        "args": [
                            "self",
                            "parent_item_id",
                            "subitem_name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83e\udde9 Create a subitem (child item) under a given parent item.\n:param parent_item_id: The parent item's ID\n:param subitem_name: Subitem name\n:param column_values: Column values in JSON or dict format\n:return: GraphQL response",
                        "function_body": "    def create_subitem(self, parent_item_id: int, subitem_name: str, column_values: dict):\n        \"\"\"\n        \ud83e\udde9 Create a subitem (child item) under a given parent item.\n        :param parent_item_id: The parent item's ID\n        :param subitem_name: Subitem name\n        :param column_values: Column values in JSON or dict format\n        :return: GraphQL response\n        \"\"\"\n        self.logger.debug(f\"[create_subitem] - \ud83c\udd95 Creating subitem under parent {parent_item_id} with name='{subitem_name}'...\")\n        query = '''\n        mutation ($parent_item_id: ID!, $subitem_name: String!, $column_values: JSON!) {\n            create_subitem(parent_item_id: $parent_item_id, item_name: $subitem_name, column_values: $column_values) {\n                id\n            }\n        }\n        '''\n        variables = {'parent_item_id': parent_item_id, 'subitem_name': subitem_name, 'column_values': column_values}\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "create_contact",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\uddc2\ufe0f Create a new contact in the 'Contacts' board.\n:param name: Contact Name\n:return: GraphQL response with ID and name",
                        "function_body": "    def create_contact(self, name):\n        \"\"\"\n        \ud83d\uddc2\ufe0f Create a new contact in the 'Contacts' board.\n        :param name: Contact Name\n        :return: GraphQL response with ID and name\n        \"\"\"\n        self.logger.debug(f\"[create_contact] - \ud83c\udd95 Creating contact with name='{name}'...\")\n        query = '''\n        mutation ($board_id: ID!, $item_name: String!) {\n            create_item(board_id: $board_id, item_name: $item_name) {\n                id,\n                name\n            }\n        }\n        '''\n        variables = {'board_id': int(self.CONTACT_BOARD_ID), 'item_name': name}\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "update_item",
                        "args": [
                            "self",
                            "item_id",
                            "column_values",
                            "type"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd27 Updates an existing item, subitem, or contact.\n:param item_id: Pulse (item) ID to update\n:param column_values: Dict/JSON of column values to update\n:param type: 'main', 'subitem', or 'contact' to determine board\n:return: GraphQL response",
                        "function_body": "    def update_item(self, item_id: str, column_values, type='main'):\n        \"\"\"\n        \ud83d\udd27 Updates an existing item, subitem, or contact.\n        :param item_id: Pulse (item) ID to update\n        :param column_values: Dict/JSON of column values to update\n        :param type: 'main', 'subitem', or 'contact' to determine board\n        :return: GraphQL response\n        \"\"\"\n        self.logger.debug(f\"[update_item] - \u2699\ufe0f Updating item {item_id} on type='{type}' board...\")\n        query = '''\n        mutation ($board_id: ID!, $item_id: ID!, $column_values: JSON!) {\n            change_multiple_column_values(board_id: $board_id, item_id: $item_id, column_values: $column_values) {\n                id\n            }\n        }\n        '''\n        if type == 'main':\n            board_id = self.PO_BOARD_ID\n        elif type == 'subitem':\n            board_id = self.SUBITEM_BOARD_ID\n        elif type == 'contact':\n            board_id = self.CONTACT_BOARD_ID\n        else:\n            board_id = self.PO_BOARD_ID\n        variables = {'board_id': str(board_id), 'item_id': str(item_id), 'column_values': column_values}\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "fetch_all_items",
                        "args": [
                            "self",
                            "board_id",
                            "limit"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetches all items from a given board using cursor-based pagination.\n:param board_id: Board ID to fetch items from\n:param limit: # of items to fetch per query\n:return: List of item dicts as returned by Monday",
                        "function_body": "    def fetch_all_items(self, board_id, limit=200):\n        \"\"\"\n        \ud83d\udd0e Fetches all items from a given board using cursor-based pagination.\n        :param board_id: Board ID to fetch items from\n        :param limit: # of items to fetch per query\n        :return: List of item dicts as returned by Monday\n        \"\"\"\n        self.logger.debug(f'[fetch_all_items] - \ud83d\udce5 Fetching all items from board {board_id} with limit={limit}...')\n        all_items = []\n        cursor = None\n        while True:\n            if cursor:\n                query = '''\n                query ($cursor: String!, $limit: Int!) {\n                    complexity { query before after }\n                    next_items_page(cursor: $cursor, limit: $limit) {\n                        cursor\n                        items {\n                            id\n                            name\n                            column_values {\n                                id\n                                text\n                                value\n                            }\n                        }\n                    }\n                }\n                '''\n                variables = {'cursor': cursor, 'limit': limit}\n            else:\n                query = '''\n                query ($board_id: [ID!]!, $limit: Int!) {\n                    complexity { query before after }\n                    boards(ids: $board_id) {\n                        items_page(limit: $limit) {\n                            cursor\n                            items {\n                                id\n                                name\n                                column_values {\n                                    id\n                                    text\n                                    value\n                                }\n                            }\n                        }\n                    }\n                }\n                '''\n                variables = {'board_id': str(board_id), 'limit': limit}\n            try:\n                response = self._make_request(query, variables)\n            except Exception as e:\n                self.logger.error(f'[fetch_all_items] - \u274c Error fetching items: {e}')\n                break\n            if cursor:\n                items_data = response.get('data', {}).get('next_items_page', {})\n            else:\n                boards_data = response.get('data', {}).get('boards', [])\n                if not boards_data:\n                    self.logger.warning(f'[fetch_all_items] - \u26a0\ufe0f No boards found for board_id {board_id}. Check your permissions or ID.')\n                    break\n                items_data = boards_data[0].get('items_page', {})\n            items = items_data.get('items', [])\n            all_items.extend(items)\n            cursor = items_data.get('cursor')\n            if not cursor:\n                self.logger.debug('[fetch_all_items] - \u2705 No more pages left to fetch for this board.')\n                break\n            self.logger.info(f'[fetch_all_items] - \ud83d\udcc4 Fetched {len(items)} items from board {board_id}. Continuing pagination...')\n        return all_items"
                    },
                    {
                        "name": "fetch_all_sub_items",
                        "args": [
                            "self",
                            "limit"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch all subitems from the subitem board, filtering out those without a parent_item.\nReturns only valid subitems that have a parent.",
                        "function_body": "    def fetch_all_sub_items(self, limit=100):\n        \"\"\"\n        \ud83d\udd0e Fetch all subitems from the subitem board, filtering out those without a parent_item.\n        Returns only valid subitems that have a parent.\n        \"\"\"\n        self.logger.debug(f'[fetch_all_sub_items] - \ud83d\udce5 Fetching all subitems from subitem board {self.SUBITEM_BOARD_ID}, limit={limit}...')\n        all_items = []\n        cursor = None\n        while True:\n            if cursor:\n                query = '''\n                query ($cursor: String!, $limit: Int!) {\n                    complexity { query before after }\n                    next_items_page(cursor: $cursor, limit: $limit) {\n                        cursor\n                        items  {\n                            id\n                            name\n                            parent_item {\n                                id\n                                name\n                            }\n                            column_values {\n                                id\n                                text\n                                value\n                            }\n                        }\n                    }\n                }\n                '''\n                variables = {'cursor': cursor, 'limit': limit}\n            else:\n                query = '''\n                query ($board_id: [ID!]!, $limit: Int!) {\n                    complexity { query before after }\n                    boards(ids: $board_id) {\n                        items_page(limit: $limit) {\n                            cursor\n                            items {\n                                id\n                                name\n                                parent_item {\n                                    id\n                                    name\n                                }\n                                column_values {\n                                    id\n                                    text\n                                    value\n                                }\n                            }\n                        }\n                    }\n                }\n                '''\n                variables = {'board_id': str(self.SUBITEM_BOARD_ID), 'limit': limit}\n            try:\n                response = self._make_request(query, variables)\n            except Exception as e:\n                self.logger.error(f'[fetch_all_sub_items] - \u274c Error fetching subitems: {e}')\n                break\n            if cursor:\n                items_data = response.get('data', {}).get('next_items_page', {})\n            else:\n                boards_data = response.get('data', {}).get('boards', [])\n                if not boards_data:\n                    self.logger.warning(f'[fetch_all_sub_items] - \u26a0\ufe0f No boards found for board_id {self.SUBITEM_BOARD_ID}. Check your permissions or ID.')\n                    break\n                items_data = boards_data[0].get('items_page', {})\n            items = items_data.get('items', [])\n            valid_items = [item for item in items if item.get('parent_item') is not None]\n            all_items.extend(valid_items)\n            cursor = items_data.get('cursor')\n            if not cursor:\n                self.logger.debug('[fetch_all_sub_items] - \u2705 No more subitem pages left to fetch.')\n                break\n            self.logger.info(f'[fetch_all_sub_items] - \ud83d\udcc4 Fetched {len(valid_items)} valid subitems from board {self.SUBITEM_BOARD_ID}. Continuing...')\n        return all_items"
                    },
                    {
                        "name": "get_subitems_in_board",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "Fetches subitems from the subitem board (self.SUBITEM_BOARD_ID).\n\n- If project_number is None, returns all subitems from the subitem board.\n- If project_number is provided, returns all subitems whose\n  project_id column (self.monday_util.SUBITEM_PROJECT_ID_COLUMN_ID)\n  matches the given project_number.\n\nFor each subitem, we transform its 'column_values' list into a dict:\n  \"column_values\": {\n      <column_id>: {\n          \"text\": <string>,\n          \"value\": <raw JSON string or None>\n      },\n      ...\n  }\n\nReturns: a list of subitem dicts like:\n[\n  {\n    \"id\": <subitem_id>,\n    \"name\": <subitem_name>,\n    \"parent_item\": {\n        \"id\": <parent_item_id>,\n        \"name\": <parent_item_name>\n    },\n    \"column_values\": {\n        \"<col_id>\": { \"text\": ..., \"value\": ... },\n        ...\n    }\n  },\n  ...\n]",
                        "function_body": "    def get_subitems_in_board(self, project_number=None):\n        \"\"\"\n        Fetches subitems from the subitem board (self.SUBITEM_BOARD_ID).\n\n        - If project_number is None, returns all subitems from the subitem board.\n        - If project_number is provided, returns all subitems whose\n          project_id column (self.monday_util.SUBITEM_PROJECT_ID_COLUMN_ID)\n          matches the given project_number.\n\n        For each subitem, we transform its 'column_values' list into a dict:\n          \"column_values\": {\n              <column_id>: {\n                  \"text\": <string>,\n                  \"value\": <raw JSON string or None>\n              },\n              ...\n          }\n\n        Returns: a list of subitem dicts like:\n        [\n          {\n            \"id\": <subitem_id>,\n            \"name\": <subitem_name>,\n            \"parent_item\": {\n                \"id\": <parent_item_id>,\n                \"name\": <parent_item_name>\n            },\n            \"column_values\": {\n                \"<col_id>\": { \"text\": ..., \"value\": ... },\n                ...\n            }\n          },\n          ...\n        ]\n        \"\"\"\n        board_id = self.SUBITEM_BOARD_ID\n        column_id = self.monday_util.SUBITEM_PROJECT_ID_COLUMN_ID\n        limit = 200\n        self.logger.info(f'[get_subitems_in_board] - \ud83d\udce5 Fetching subitems from board_id={board_id}, project_number={project_number}')\n        all_items = []\n        cursor = None\n        if project_number is None:"
                    },
                    {
                        "name": "fetch_all_contacts",
                        "args": [
                            "self",
                            "limit"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch all contacts from the 'Contacts' board with pagination.\n:param limit: number of items to fetch per page\n:return: List of contact items",
                        "function_body": "    def fetch_all_contacts(self, limit: int=250) -> list:\n        \"\"\"\n        \ud83d\udd0e Fetch all contacts from the 'Contacts' board with pagination.\n        :param limit: number of items to fetch per page\n        :return: List of contact items\n        \"\"\"\n        self.logger.info('[fetch_all_contacts] - \ud83d\udce5 Fetching all contacts from the Contacts board...')\n        all_items = []\n        cursor = None\n        while True:\n            if cursor:\n                query = '''\n                query ($cursor: String!, $limit: Int!) {\n                    complexity { query before after }\n                    next_items_page(cursor: $cursor, limit: $limit) {\n                        cursor\n                        items {\n                            id\n                            name\n                            column_values {\n                                id\n                                text\n                                value\n                            }\n                        }\n                    }\n                }\n                '''\n                variables = {'cursor': cursor, 'limit': limit}\n            else:\n                query = '''\n                query ($board_id: [ID!]!, $limit: Int!) {\n                    complexity { query before after }\n                    boards(ids: $board_id) {\n                        items_page(limit: $limit) {\n                            cursor\n                            items {\n                                id\n                                name\n                                column_values {\n                                    id\n                                    text\n                                    value\n                                }\n                            }\n                        }\n                    }\n                }\n                '''\n                variables = {'board_id': str(self.monday_util.CONTACT_BOARD_ID), 'limit': limit}\n            try:\n                response = self._make_request(query, variables)\n            except Exception as e:\n                self.logger.error(f'[fetch_all_contacts] - \u274c Error fetching contacts: {e}')\n                break\n            if cursor:\n                items_data = response.get('data', {}).get('next_items_page', {})\n            else:\n                boards_data = response.get('data', {}).get('boards', [])\n                if not boards_data:\n                    self.logger.warning(f'[fetch_all_contacts] - \u26a0\ufe0f No boards found for board_id {self.monday_util.CONTACT_BOARD_ID}. Check your permissions or ID.')\n                    break\n                items_data = boards_data[0].get('items_page', {})\n            items = items_data.get('items', [])\n            all_items.extend(items)\n            cursor = items_data.get('cursor')\n            if not cursor:\n                self.logger.debug('[fetch_all_contacts] - \u2705 All contacts fetched successfully.')\n                break\n            self.logger.debug(f'[fetch_all_contacts] - \ud83d\udd04 Fetched {len(items)} contacts so far. Continuing pagination...')\n        return all_items"
                    },
                    {
                        "name": "fetch_item_by_ID",
                        "args": [
                            "self",
                            "id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a single item by ID.\n:param id: Item (pulse) ID\n:return: The item dict, or None if not found",
                        "function_body": "    def fetch_item_by_ID(self, id: str):\n        \"\"\"\n        \ud83d\udd0e Fetch a single item by ID.\n        :param id: Item (pulse) ID\n        :return: The item dict, or None if not found\n        \"\"\"\n        self.logger.debug(f\"[fetch_item_by_ID] - \ud83d\udd75\ufe0f Searching for item by ID '{id}'...\")\n        try:"
                    },
                    {
                        "name": "fetch_group_ID",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetches the group ID whose title contains the given project_id.\n:param project_id: The project identifier string\n:return: Group ID as string or None if no match",
                        "function_body": "    def fetch_group_ID(self, project_id):\n        \"\"\"\n        \ud83d\udd0e Fetches the group ID whose title contains the given project_id.\n        :param project_id: The project identifier string\n        :return: Group ID as string or None if no match\n        \"\"\"\n        self.logger.debug(f\"[fetch_group_ID] - \ud83d\udd75\ufe0f Searching for group ID matching project_id='{project_id}' on board {self.PO_BOARD_ID}...\")\n        query = f'''\n        query {{\n            complexity {{ query before after }}\n            boards (ids: {self.PO_BOARD_ID}) {{\n                groups {{\n                  title\n                  id\n                }}\n            }}\n        }}\n        '''\n        response = self._make_request(query, {})\n        groups = response['data']['boards'][0]['groups']\n        for group in groups:\n            if group['title'] and project_id in group['title']:\n                self.logger.debug(f\"[fetch_group_ID] - \u2705 Found group '{group['title']}' with ID '{group['id']}'.\")\n                return group['id']\n        self.logger.debug('[fetch_group_ID] - \ud83d\udd75\ufe0f No matching group found.')\n        return None"
                    },
                    {
                        "name": "fetch_subitem_by_receipt_and_line",
                        "args": [
                            "self",
                            "receipt_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch subitem matching receipt_number & line_number from subitem board.\nReplace 'receipt_number_column_id' and 'line_number_column_id' with your real subitem board columns.",
                        "function_body": "    def fetch_subitem_by_receipt_and_line(self, receipt_number, line_number):\n        \"\"\"\n        \ud83d\udd0e Fetch subitem matching receipt_number & line_number from subitem board.\n        Replace 'receipt_number_column_id' and 'line_number_column_id' with your real subitem board columns.\n        \"\"\"\n        self.logger.debug(f\"[fetch_subitem_by_receipt_and_line] - \ud83d\udd0d Searching subitem by receipt_number='{receipt_number}', line_number='{line_number}'...\")\n        receipt_number_column_id = 'numeric__1'\n        line_number_column_id = 'numbers_Mjj5uYts'\n        query = f'''\n        query ($board_id: ID!, $receipt_number: String!, $line_number: String!) {{\n            complexity {{ query before after }}\n            items_page_by_column_values(\n                board_id: $board_id, \n                columns: [\n                  {{column_id: \"{receipt_number_column_id}\", column_values: [$receipt_number]}}, \n                  {{column_id: \"{line_number_column_id}\", column_values: [$line_number]}}\n                ], \n                limit: 1\n            ) {{\n                items {{\n                    id\n                    column_values {{\n                        id\n                        text\n                        value\n                    }}\n                }}\n            }}\n        }}\n        '''\n        variables = {'board_id': int(self.SUBITEM_BOARD_ID), 'receipt_number': str(receipt_number), 'line_number': str(line_number)}\n        response = self._make_request(query, variables)\n        items = response.get('data', {}).get('items_page_by_column_values', {}).get('items', [])\n        return items[0] if items else None"
                    },
                    {
                        "name": "fetch_item_by_po_and_project",
                        "args": [
                            "self",
                            "project_id",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a main item by matching project_id and po_number columns.\n:param project_id: The project identifier\n:param po_number: The Purchase Order number\n:return: GraphQL response with item(s) in 'data.items_page_by_column_values.items'",
                        "function_body": "    def fetch_item_by_po_and_project(self, project_id, po_number):\n        \"\"\"\n        \ud83d\udd0e Fetch a main item by matching project_id and po_number columns.\n        :param project_id: The project identifier\n        :param po_number: The Purchase Order number\n        :return: GraphQL response with item(s) in 'data.items_page_by_column_values.items'\n        \"\"\"\n        self.logger.debug(f\"[fetch_item_by_po_and_project] - \ud83d\udd0d Searching for item with project_id='{project_id}', po_number='{po_number}'...\")\n        query = '''\n        query ($board_id: ID!, $po_number: String!, $project_id: String!, $project_id_column: String!, $po_column: String!) {\n            complexity { query before after }\n            items_page_by_column_values (limit: 1, board_id: $board_id, \n                columns: [\n                   {column_id: $project_id_column, column_values: [$project_id]}, \n                   {column_id: $po_column, column_values: [$po_number]}\n                ]) {\n                items {\n                  id\n                  name\n                  column_values {\n                    id\n                    value\n                  }\n                }\n            }\n        }'''\n        variables = {\n            'board_id': int(self.PO_BOARD_ID),\n            'po_number': str(po_number),\n            'project_id': str(project_id),\n            'po_column': str(self.po_number_column),\n            'project_id_column': str(self.project_id_column)\n        }\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "fetch_subitem_by_po_receipt_line",
                        "args": [
                            "self",
                            "po_number",
                            "receipt_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a subitem by matching PO number, receipt number, and line ID columns.",
                        "function_body": "    def fetch_subitem_by_po_receipt_line(self, po_number, receipt_number, line_number):\n        \"\"\"\n        \ud83d\udd0e Fetch a subitem by matching PO number, receipt number, and line ID columns.\n        \"\"\"\n        self.logger.debug(f\"[fetch_subitem_by_po_receipt_line] - \ud83d\udd0d Searching subitem (PO='{po_number}', receipt='{receipt_number}', line_number='{line_number}')...\")\n        po_number_column_id = self.monday_util.SUBITEM_PO_COLUMN_ID\n        receipt_number_column_id = self.monday_util.SUBITEM_ID_COLUMN_ID\n        line_number_column_id = self.monday_util.SUBITEM_LINE_NUMBER_COLUMN_ID\n        query = f'''\n        query ($board_id: ID!, $po_number: String!, $receipt_number: String!, $line_number: String!) {{\n            complexity {{ query before after }}\n            items_page_by_column_values(\n                board_id: $board_id, \n                columns: [\n                    {{column_id: \"{po_number_column_id}\", column_values: [$po_number]}},\n                    {{column_id: \"{receipt_number_column_id}\", column_values: [$receipt_number]}},\n                    {{column_id: \"{line_number_column_id}\", column_values: [$line_number]}}\n                ], \n                limit: 1\n            ) {{\n                items {{\n                    id\n                    column_values {{\n                        id\n                        text\n                        value\n                    }}\n                }}\n            }}\n        }}\n        '''\n        variables = {\n            'board_id': int(self.SUBITEM_BOARD_ID),\n            'po_number': str(po_number),\n            'receipt_number': str(receipt_number),\n            'line_number': str(line_number)\n        }\n        response = self._make_request(query, variables)\n        items = response.get('data', {}).get('items_page_by_column_values', {}).get('items', [])\n        if items:\n            self.logger.debug(f\"[fetch_subitem_by_po_receipt_line] - \u2705 Found subitem with ID {items[0]['id']}\")\n        else:\n            self.logger.debug('[fetch_subitem_by_po_receipt_line] - \ud83d\udd75\ufe0f No subitem found for the given PO, receipt, and line.')\n        return items[0] if items else None"
                    },
                    {
                        "name": "fetch_item_by_name",
                        "args": [
                            "self",
                            "name",
                            "board"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a single item by 'name' column on the specified board.\n:param name: The item's name to search for\n:param board: 'PO', 'Contacts', or fallback to subitem board\n:return: The single matching item dict or None if not found",
                        "function_body": "    def fetch_item_by_name(self, name, board='PO'):\n        \"\"\"\n        \ud83d\udd0e Fetch a single item by 'name' column on the specified board.\n        :param name: The item's name to search for\n        :param board: 'PO', 'Contacts', or fallback to subitem board\n        :return: The single matching item dict or None if not found\n        \"\"\"\n        self.logger.debug(f\"[fetch_item_by_name] - \ud83d\udd0e Searching item by name='{name}' on '{board}' board...\")\n        query = '''\n        query ($board_id: ID!, $name: String!) {\n            complexity { query before after }\n            items_page_by_column_values (limit: 1, board_id: $board_id, columns: [{column_id: \"name\", column_values: [$name]}]) {\n                items {\n                  id\n                  name\n                  column_values {\n                    id\n                    value\n                  }\n                }\n            }\n        }'''\n        if board == 'PO':\n            board_id = self.PO_BOARD_ID\n        elif board == 'Contacts':\n            board_id = self.CONTACT_BOARD_ID\n        else:\n            board_id = self.SUBITEM_BOARD_ID\n        variables = {'board_id': int(board_id), 'name': str(name)}\n        response = self._make_request(query, variables)\n        item_list = response['data']['items_page_by_column_values']['items']\n        if len(item_list) != 1:\n            self.logger.debug('[fetch_item_by_name] - \ud83d\udd75\ufe0f No single matching item found or multiple matches encountered.')\n            return None\n        self.logger.debug(f\"[fetch_item_by_name] - \u2705 Found item with ID={item_list[0]['id']}.\")\n        return item_list"
                    },
                    {
                        "name": "_safe_get_text",
                        "args": [
                            "self",
                            "vals_dict",
                            "col_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udee1\ufe0f Safe retrieval of text from column_values dict.\nUseful if the value doesn't exist or is None.",
                        "function_body": "    def _safe_get_text(self, vals_dict, col_id):\n        \"\"\"\n        \ud83d\udee1\ufe0f Safe retrieval of text from column_values dict.\n        Useful if the value doesn't exist or is None.\n        \"\"\"\n        return vals_dict.get(col_id, {}).get('text', '')"
                    },
                    {
                        "name": "get_items_in_project",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Retrieve all items from the PO_BOARD_ID that match a given project_id column value.\nUses cursor-based pagination if needed.\n:param project_id: The project identifier (string)\n:return: A list of items with column_values as a dict",
                        "function_body": "    def get_items_in_project(self, project_id):\n        \"\"\"\n        \ud83d\udd0e Retrieve all items from the PO_BOARD_ID that match a given project_id column value.\n        Uses cursor-based pagination if needed.\n        :param project_id: The project identifier (string)\n        :return: A list of items with column_values as a dict\n        \"\"\"\n        self.logger.debug(f\"[get_items_in_project] - \ud83d\udce5 Fetching all items in project_id='{project_id}' from board {self.PO_BOARD_ID} ...\")\n        query = '''\n        query ($board_id: ID!, $project_id_column: String!, $project_id_val: String!, $limit: Int, $cursor: String) {\n            items_page_by_column_values(\n                board_id: $board_id,\n                columns: [{column_id: $project_id_column, column_values: [$project_id_val]}],\n                limit: $limit,\n                cursor: $cursor\n            ) {\n                cursor\n                items {\n                    id\n                    name\n                    column_values {\n                        id\n                        text\n                        value\n                    }\n                }\n            }\n        }'''\n        variables = {\n            'board_id': self.PO_BOARD_ID,\n            'project_id_column': self.project_id_column,\n            'project_id_val': str(project_id),\n            'limit': 500,\n            'cursor': None\n        }\n        all_items = []\n        try:"
                    },
                    {
                        "name": "get_subitems_for_item",
                        "args": [
                            "self",
                            "item_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch subitems for a given parent item_id in the main board.\n:param item_id: Main item ID\n:return: List of subitem dicts: { \"id\": subitem_id, \"name\": subitem_name, \"column_values\": {..} }",
                        "function_body": "    def get_subitems_for_item(self, item_id):\n        \"\"\"\n        \ud83d\udd0e Fetch subitems for a given parent item_id in the main board.\n        :param item_id: Main item ID\n        :return: List of subitem dicts: { \"id\": subitem_id, \"name\": subitem_name, \"column_values\": {..} }\n        \"\"\"\n        self.logger.debug(f'[get_subitems_for_item] - \ud83d\udce5 Fetching subitems for item_id={item_id} ...')\n        query = '''\n        query ($item_id: [ID!]!) {\n            complexity { query before after }\n            items (ids: $item_id) {\n                id\n                name\n                subitems {\n                    id\n                    name\n                    column_values {\n                        id\n                        text\n                    }\n                }\n            }\n        }\n        '''\n        variables = {'item_id': str(item_id)}\n        try:"
                    },
                    {
                        "name": "batch_create_or_update_items",
                        "args": [
                            "self",
                            "batch",
                            "project_id",
                            "create"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Splits items into sub-batches and calls create_items_batch for each.",
                        "function_body": "    def batch_create_or_update_items(self, batch, project_id, create=True):\n        \"\"\"\n        Splits items into sub-batches and calls create_items_batch for each.\n        \"\"\"\n        self.logger.info(\n            f\"[batch_create_or_update_items] - Processing {len(batch)} items for project_id={project_id}, create={create}...\")\n\n        # Try smaller chunks. Even 5 might be too large if you have big text.\n        chunk_size = 5\n        sub_batches = [batch[i:i + chunk_size] for i in range(0, len(batch), chunk_size)]\n        self.logger.info(\n            f\"[batch_create_or_update_items] - Splitting into {len(sub_batches)} sub-batches of size={chunk_size}.\")\n\n        results = []\n        with ThreadPoolExecutor() as executor:\n            future_map = {}\n            for idx, sbatch in enumerate(sub_batches, start=1):\n                future = executor.submit(self.create_items_batch, sbatch, project_id)\n                future_map[future] = idx\n\n            for future in as_completed(future_map):\n                sbatch_num = future_map[future]\n                try:\n                    sub_result = future.result()\n                    results.extend(sub_result)\n                    self.logger.debug(f\"[batch_create_or_update_items] - Sub-batch #{sbatch_num} done.\")\n                except Exception as e:\n                    self.logger.exception(f\"[batch_create_or_update_items] - Error in sub-batch #{sbatch_num}: {e}\")\n                    raise\n\n        return results"
                    },
                    {
                        "name": "create_items_batch",
                        "args": [
                            "self",
                            "batch",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "po_column_values_formatter",
                            "_make_request"
                        ],
                        "docstring": "Creates a batch of items on the PO board using the Monday.com GraphQL API.\nEach item\u2019s column values are formatted via monday_util.po_column_values_formatter,\nwhich maps your DB field names to the proper Monday column IDs.\n\nArgs:\n    batch (list): A list of dicts. Each dict is expected to have:\n        - 'db_item': the local record (e.g. with a vendor name)\n        - 'column_values': a dict keyed by your DB field names\n    project_id: A project identifier (for logging purposes).\n\nReturns:\n    The batch list updated with each item\u2019s new Monday ID (under the key 'monday_item_id').",
                        "function_body": "    def create_items_batch(self, batch, project_id):\n        \"\"\"\n        Creates a batch of items on the PO board using the Monday.com GraphQL API.\n        Each item\u2019s column values are formatted via monday_util.po_column_values_formatter,\n        which maps your DB field names to the proper Monday column IDs.\n\n        Args:\n            batch (list): A list of dicts. Each dict is expected to have:\n                - 'db_item': the local record (e.g. with a vendor name)\n                - 'column_values': a dict keyed by your DB field names\n            project_id: A project identifier (for logging purposes).\n\n        Returns:\n            The batch list updated with each item\u2019s new Monday ID (under the key 'monday_item_id').\n        \"\"\"\n        self.logger.info(f\"[create_items_batch] - Creating {len(batch)} items in one request, project_id={project_id}.\")\n        mutation_parts = []\n\n        for i, itm in enumerate(batch):\n            item = itm[\"db_item\"]\n            formatted_column_values = monday_util.po_column_values_formatter(\n                project_id=item[\"project_number\"],\n                po_number=item[\"po_number\"],\n                description=item[\"description\"],\n                contact_pulse_id=itm[\"monday_contact_id\"],\n                folder_link=item[\"folder_link\"],\n                producer_id=item[\"producer\"],\n                name=item[\"vendor_name\"],\n            )\n            formatted_value = formatted_column_values.replace('\"', '\\\\\"')\n            safe_item_name = itm['db_item'].get('vendor_name') or \"Unnamed\"\n            safe_item_name = safe_item_name.replace('\"', '\\\\\"')\n\n            mutation_parts.append(\n                f'create{i}: create_item('\n                f'board_id: {self.PO_BOARD_ID}, '\n                f'item_name: \"{safe_item_name}\", '\n                f'column_values: \"{formatted_value}\"'\n                f') {{ id }}'\n            )\n\n        mutation_body = \" \".join(mutation_parts)\n        query = f\"mutation {{ {mutation_body} }}\"\n        self.logger.debug(f\"[create_items_batch] GraphQL:\\n{query}\")\n\n        response = self._make_request(query)\n\n        for i, itm in enumerate(batch):\n            key = f'create{i}'\n            created_item = response.get('data', {}).get(key)\n            if created_item and 'id' in created_item:\n                itm['monday_item_id'] = created_item['id']\n            else:\n                self.logger.warning(f\"[create_items_batch] - No item id in response for create{i}\")\n\n        return batch"
                    },
                    {
                        "name": "find_or_create_item_in_monday",
                        "args": [
                            "self",
                            "item",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [
                            "po_column_values_formatter",
                            "fetch_item_by_po_and_project",
                            "update_item",
                            "create_item"
                        ],
                        "docstring": "\ud83d\udd0e Finds an item by project_id & PO. If it exists, returns it.\nOtherwise, creates a new item.\n:param item: dict with keys [\"project_id\", \"PO\", \"name\", \"group_id\", ...]\n:param column_values: JSON/dict of column values\n:return: The updated item with \"item_pulse_id\" assigned",
                        "function_body": "    def find_or_create_item_in_monday(self, item, column_values):\n        \"\"\"\n        \ud83d\udd0e Finds an item by project_id & PO. If it exists, returns it.\n        Otherwise, creates a new item.\n        :param item: dict with keys [\"project_id\", \"PO\", \"name\", \"group_id\", ...]\n        :param column_values: JSON/dict of column values\n        :return: The updated item with \"item_pulse_id\" assigned\n        \"\"\"\n        self.logger.info(f\"[find_or_create_item_in_monday] - \ud83d\udd0e Checking if item with project_id='{item['project_id']}' and PO='{item['PO']}' exists...\")\n        response = self.fetch_item_by_po_and_project(item['project_id'], item['PO'])\n        response_item = response['data']['items_page_by_column_values']['items']\n        if len(response_item) == 1:"
                    },
                    {
                        "name": "find_or_create_sub_item_in_monday",
                        "args": [
                            "self",
                            "sub_item",
                            "parent_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_item_by_ID",
                            "update_item",
                            "fetch_subitem_by_po_receipt_line",
                            "create_subitem",
                            "subitem_column_values_formatter"
                        ],
                        "docstring": "\ud83d\udd0e Finds or creates a subitem in Monday corresponding to external data (invoice lines, hours, etc.).\n:param sub_item: dict with keys like [\"line_number\", \"date\", \"due date\", \"po_number\", \"vendor\", etc.]\n:param parent_item: dict with at least [\"item_pulse_id\", \"status\", \"name\", ...]\n:return: The updated sub_item with \"pulse_id\" assigned if created or found",
                        "function_body": "    def find_or_create_sub_item_in_monday(self, sub_item, parent_item):\n        \"\"\"\n        \ud83d\udd0e Finds or creates a subitem in Monday corresponding to external data (invoice lines, hours, etc.).\n        :param sub_item: dict with keys like [\"line_number\", \"date\", \"due date\", \"po_number\", \"vendor\", etc.]\n        :param parent_item: dict with at least [\"item_pulse_id\", \"status\", \"name\", ...]\n        :return: The updated sub_item with \"pulse_id\" assigned if created or found\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "parse_tax_number",
                        "args": [
                            "self",
                            "tax_str"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83e\uddfe Removes hyphens (e.g., for SSN '123-45-6789' or EIN '12-3456789') and attempts to parse as int.\nReturns None if parsing fails or if the string is empty.",
                        "function_body": "    def parse_tax_number(self, tax_str: str):\n        \"\"\"\n        \ud83e\uddfe Removes hyphens (e.g., for SSN '123-45-6789' or EIN '12-3456789') and attempts to parse as int.\n        Returns None if parsing fails or if the string is empty.\n        \"\"\"\n        if not tax_str:\n            self.logger.debug('[parse_tax_number] - No tax_str provided. Returning None.')\n            return None\n        cleaned = tax_str.replace('-', '')\n        try:"
                    },
                    {
                        "name": "extract_monday_contact_fields",
                        "args": [
                            "self",
                            "contact_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\uddc2\ufe0f Converts a Monday contact_item (including its column_values) into a structured dict of fields.",
                        "function_body": "    def extract_monday_contact_fields(self, contact_item: dict) -> dict:\n        \"\"\"\n        \ud83d\uddc2\ufe0f Converts a Monday contact_item (including its column_values) into a structured dict of fields.\n        \"\"\"\n        self.logger.debug(\n            f\"[extract_monday_contact_fields] [item ID={contact_item.get('id')}] \"\n            \"\ud83d\udce6 Extracting contact fields...\"\n        )\n        column_values = contact_item.get('column_values', [])\n\n        def parse_column_value(cv):\n            raw_text = cv.get('text') or ''\n            raw_value = cv.get('value')\n            if raw_value:\n                try:\n                    data = json.loads(raw_value)\n                    if isinstance(data, dict) and data.get('url'):\n                        return data['url']\n                except (ValueError, TypeError):\n                    pass\n            return raw_text\n\n        parsed_values = {}\n        for cv in column_values:\n            col_id = cv['id']\n            parsed_values[col_id] = parse_column_value(cv)\n\n        return {"
                    },
                    {
                        "name": "create_contact_in_monday",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_item_by_ID",
                            "create_contact"
                        ],
                        "docstring": "\u2795 Create a contact in Monday and immediately fetch its full item data.\n:param name: Name of the contact\n:return: The newly created contact item",
                        "function_body": "    def create_contact_in_monday(self, name: str) -> dict:\n        \"\"\"\n        \u2795 Create a contact in Monday and immediately fetch its full item data.\n        :param name: Name of the contact\n        :return: The newly created contact item\n        \"\"\"\n        self.logger.info(f\"[create_contact_in_monday] - \u2795 Creating new Monday contact with name='{name}'...\")\n        create_resp = self.create_contact(name)\n        new_id = create_resp['data']['create_item']['id']\n        self.logger.info(f\"[create_contact_in_monday] - \u2705 Contact created with pulse_id={new_id}. Fetching the new item's data...\")\n        created_item = self.fetch_item_by_ID(new_id)\n        return created_item"
                    },
                    {
                        "name": "sync_db_contact_to_monday",
                        "args": [
                            "self",
                            "db_contact"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item"
                        ],
                        "docstring": "\ud83d\udd04 Syncs local DB contact fields to an existing Monday contact.\n:param db_contact: DB contact object with attributes matching your columns",
                        "function_body": "    def sync_db_contact_to_monday(self, db_contact):\n        \"\"\"\n        \ud83d\udd04 Syncs local DB contact fields to an existing Monday contact.\n        :param db_contact: DB contact object with attributes matching your columns\n        \"\"\"\n        if not db_contact.pulse_id:\n            self.logger.warning(\n                f\"[sync_db_contact_to_monday] - \u26a0\ufe0f DB Contact id={db_contact.id} has no pulse_id. \"\n                \"Use 'find_or_create_contact_in_monday' first.\"\n            )\n            return\n        self.logger.info(\n            f'[sync_db_contact_to_monday] - \ud83d\udd04 Updating Monday contact (pulse_id={db_contact.pulse_id}) with DB fields...'\n        )\n        column_values = {\n            self.monday_util.CONTACT_PHONE: db_contact.phone or '',\n            self.monday_util.CONTACT_EMAIL: db_contact.email or '',\n            self.monday_util.CONTACT_ADDRESS_LINE_1: db_contact.address_line_1 or '',\n            self.monday_util.CONTACT_ADDRESS_LINE_2: db_contact.address_line_2 or '',\n            self.monday_util.CONTACT_CITY: db_contact.city or '',\n            self.monday_util.CONTACT_STATE: db_contact.state or '',\n            self.monday_util.CONTACT_COUNTRY: db_contact.country or '',\n            self.monday_util.CONTACT_REGION: db_contact.region or '',\n            self.monday_util.CONTACT_ZIP: db_contact.zip_code or '',\n            self.monday_util.CONTACT_TAX_TYPE: db_contact.tax_type or '',\n            self.monday_util.CONTACT_TAX_NUMBER: str(db_contact.tax_number) if db_contact.tax_number else '',\n            self.monday_util.CONTACT_TAX_FORM_LINK: db_contact.tax_form_link or '',\n            self.monday_util.CONTACT_PAYMENT_DETAILS: db_contact.payment_details or '',\n            self.monday_util.CONTACT_VENDOR_STATUS: db_contact.vendor_status or ''\n        }\n        try:"
                    },
                    {
                        "name": "update_monday_tax_form_link",
                        "args": [
                            "self",
                            "pulse_id",
                            "new_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item"
                        ],
                        "docstring": "\u270f\ufe0f Update the tax_form_link column for a Monday contact, setting an appropriate link text label.",
                        "function_body": "    def update_monday_tax_form_link(self, pulse_id, new_link):\n        \"\"\"\n        \u270f\ufe0f Update the tax_form_link column for a Monday contact, setting an appropriate link text label.\n        \"\"\"\n        if not pulse_id:\n            self.logger.warning('[update_monday_tax_form_link] - \u26a0\ufe0f No pulse_id provided to update Monday link. Aborting update.')\n            return\n        link_lower = new_link.lower()\n        if 'w9' in link_lower:\n            link_text = 'W-9'\n        elif 'w8-ben-e' in link_lower:\n            link_text = 'W-8BEN-E'\n        elif 'w8-ben' in link_lower:\n            link_text = 'W-8BEN'\n        else:\n            link_text = 'Tax Form'\n        link_value = {'url': new_link, 'text': link_text}\n        column_values = json.dumps({self.monday_util.CONTACT_TAX_FORM_LINK: link_value})\n        try:"
                    },
                    {
                        "name": "batch_create_or_update_subitems",
                        "args": [
                            "self",
                            "subitems_batch",
                            "parent_item_id",
                            "create"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Splits subitems into sub-batches and calls either create_subitems_batch() or update_subitems_batch().\nEach subitem dict can have its own 'parent_id'; if missing, fallback to parent_item_id param.\n\nsubitems_batch: [\n  {\n    \"db_sub_item\": <python dict of subitem data>,\n    \"column_values\": {...some dict...},\n    \"parent_id\": <int or None>,\n    \"monday_item_id\": <existing subitem ID if update, else None>\n  },\n  ...\n]",
                        "function_body": "    def batch_create_or_update_subitems(self, subitems_batch, parent_item_id=None, create=True):\n        \"\"\"\n        Splits subitems into sub-batches and calls either create_subitems_batch() or update_subitems_batch().\n        Each subitem dict can have its own 'parent_id'; if missing, fallback to parent_item_id param.\n\n        subitems_batch: [\n          {\n            \"db_sub_item\": <python dict of subitem data>,\n            \"column_values\": {...some dict...},\n            \"parent_id\": <int or None>,\n            \"monday_item_id\": <existing subitem ID if update, else None>\n          },\n          ...\n        ]\n        \"\"\"\n        verb = \"create\" if create else \"update\"\n        self.logger.info(\n            f\"[batch_create_or_update_subitems] - Preparing to {verb} {len(subitems_batch)} subitems...\"\n        )\n\n        chunk_size = 5  # keep each GraphQL mutation of manageable size\n        sub_batches = [subitems_batch[i:i + chunk_size] for i in range(0, len(subitems_batch), chunk_size)]\n        self.logger.info(\n            f\"[batch_create_or_update_subitems] - Splitting subitems into {len(sub_batches)} sub-batches of size={chunk_size}.\"\n        )\n\n        results = []\n        with ThreadPoolExecutor() as executor:\n            future_map = {}\n            for idx, sbatch in enumerate(sub_batches, start=1):\n                if create:\n                    future = executor.submit(self.create_subitems_batch, sbatch, parent_item_id)\n                else:\n                    future = executor.submit(self.update_subitems_batch, sbatch)\n\n                future_map[future] = idx\n\n            for future in as_completed(future_map):\n                sbatch_num = future_map[future]\n                try:\n                    sub_result = future.result()\n                    results.extend(sub_result)\n                    self.logger.debug(f\"[batch_create_or_update_subitems] - Sub-batch #{sbatch_num} done.\")\n                except Exception as e:\n                    self.logger.exception(f\"[batch_create_or_update_subitems] - Error in sub-batch #{sbatch_num}: {e}\")\n                    raise\n\n        return results"
                    },
                    {
                        "name": "create_subitems_batch",
                        "args": [
                            "self",
                            "sbatch",
                            "default_parent_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "Creates multiple subitems in one GraphQL mutation. Each subitem can define its own `parent_id`.",
                        "function_body": "    def create_subitems_batch(self, sbatch, default_parent_id=None):\n        \"\"\"\n        Creates multiple subitems in one GraphQL mutation. Each subitem can define its own `parent_id`.\n        \"\"\"\n        self.logger.info(f\"[create_subitems_batch] - Creating {len(sbatch)} subitems in one request.\")\n        mutation_parts = []\n\n        for i, subdict in enumerate(sbatch):\n            db_sub_item = subdict[\"db_sub_item\"]\n            column_values = subdict[\"column_values\"]\n            column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n            # If a parent_id is on the subitem, use that; else fallback to default_parent_id\n            parent_id = subdict.get(\"parent_id\") or default_parent_id\n            if not parent_id:\n                raise ValueError(f\"[create_subitems_batch] - No parent_item_id provided for subitem: {db_sub_item}\")\n\n            subitem_name = db_sub_item.get('name') or db_sub_item.get('vendor') or 'Subitem'\n            subitem_name_safe = subitem_name.replace('\"', '\\\\\"')\n\n            mutation_parts.append(\n                f'createSub{i}: create_subitem('\n                f'parent_item_id: {parent_id}, '\n                f'item_name: \"{subitem_name_safe}\", '\n                f'column_values: \"{column_values_json}\"'\n                f') {{ id }}'\n            )\n\n        mutation_body = \" \".join(mutation_parts)\n        query = f\"mutation {{ {mutation_body} }}\"\n        self.logger.debug(f\"[create_subitems_batch] GraphQL:\\n{query}\")\n\n        response = self._make_request(query)\n        for i, subdict in enumerate(sbatch):\n            key = f'createSub{i}'\n            created_item = response.get('data', {}).get(key)\n            if created_item and 'id' in created_item:\n                subdict['monday_item_id'] = created_item['id']\n            else:\n                self.logger.warning(f\"[create_subitems_batch] - No item id in response for createSub{i}\")\n\n        return sbatch"
                    },
                    {
                        "name": "update_subitems_batch",
                        "args": [
                            "self",
                            "sbatch"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "Updates multiple existing subitems in one GraphQL mutation.\nExpects each dict to have 'monday_item_id' and 'column_values'.",
                        "function_body": "    def update_subitems_batch(self, sbatch):\n        \"\"\"\n        Updates multiple existing subitems in one GraphQL mutation.\n        Expects each dict to have 'monday_item_id' and 'column_values'.\n        \"\"\"\n        self.logger.info(f\"[update_subitems_batch] - Updating {len(sbatch)} subitems in one request.\")\n        mutation_parts = []\n\n        for i, subdict in enumerate(sbatch):\n            sub_id = subdict.get(\"monday_item_id\")\n            column_values = subdict[\"column_values\"]\n            if not sub_id:\n                raise ValueError(\"[update_subitems_batch] - 'monday_item_id' is missing in subitem dict. Cannot update.\")\n\n            column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n            mutation_parts.append(\n                f'updateSub{i}: change_multiple_column_values('\n                f'board_id: {self.SUBITEM_BOARD_ID}, '\n                f'item_id: \"{sub_id}\", '\n                f'column_values: \"{column_values_json}\"'\n                f') {{ id }}'\n            )\n\n        mutation_body = \" \".join(mutation_parts)\n        query = f\"mutation {{ {mutation_body} }}\"\n        self.logger.debug(f\"[update_subitems_batch] GraphQL:\\n{query}\")\n\n        response = self._make_request(query)\n        for i, subdict in enumerate(sbatch):\n            key = f'updateSub{i}'\n            updated_item = response.get('data', {}).get(key)\n            if updated_item and 'id' in updated_item:\n                self.logger.debug(f\"[update_subitems_batch] - Subitem {updated_item['id']} updated successfully.\")\n            else:\n                self.logger.warning(f\"[update_subitems_batch] - No 'id' in response for updateSub{i}\")\n\n        return sbatch"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "MAX_RETRIES",
                "value": "3"
            },
            {
                "name": "RETRY_BACKOFF_FACTOR",
                "value": "2"
            },
            {
                "name": "monday_api",
                "value": "MondayAPI()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_database_util.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayDatabaseUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "create_or_update_main_item_in_db",
                        "args": [
                            "self",
                            "item_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_purchase_order",
                            "update_purchase_order",
                            "search_purchase_orders"
                        ],
                        "docstring": "Example usage of DatabaseOperations for a main item (PurchaseOrder).",
                        "function_body": "    def create_or_update_main_item_in_db(self, item_data):\n        \"\"\"\n        Example usage of DatabaseOperations for a main item (PurchaseOrder).\n        \"\"\"\n        pulse_id = item_data.get('pulse_id')\n        if not pulse_id:\n            self.logger.warning('[create_or_update_main_item_in_db] - No pulse_id specified in item_data. Cannot create or update.')\n            return 'Fail'\n        existing_pos = self.db_ops.search_purchase_orders(['pulse_id'], [pulse_id])\n        if existing_pos:"
                    },
                    {
                        "name": "create_or_update_sub_item_in_db",
                        "args": [
                            "self",
                            "item_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_detail_item",
                            "search_detail_items",
                            "update_detail_item"
                        ],
                        "docstring": "Example usage of DatabaseOperations for a subitem (DetailItem).",
                        "function_body": "    def create_or_update_sub_item_in_db(self, item_data):\n        \"\"\"\n        Example usage of DatabaseOperations for a subitem (DetailItem).\n        \"\"\"\n        pulse_id = item_data.get('pulse_id')\n        if not pulse_id:\n            self.logger.warning('[create_or_update_sub_item_in_db] - No pulse_id specified in subitem_data. Cannot create or update.')\n            return {'status': 'Fail'}\n        existing_sub = self.db_ops.search_detail_items(['pulse_id'], [pulse_id])\n        if existing_sub:"
                    },
                    {
                        "name": "get_purchase_order_surrogate_id_by_pulse_id",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders"
                        ],
                        "docstring": "Now uses db_ops.search_purchase_orders to find the PO by pulse_id.",
                        "function_body": "    def get_purchase_order_surrogate_id_by_pulse_id(self, pulse_id):\n        \"\"\"\n        Now uses db_ops.search_purchase_orders to find the PO by pulse_id.\n        \"\"\"\n        found = self.db_ops.search_purchase_orders(['pulse_id'], [pulse_id])\n        if not found:\n            return None\n        if isinstance(found, list):\n            found = found[0]\n        return found['id']"
                    },
                    {
                        "name": "get_purchase_order_type_by_pulse_id",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders"
                        ],
                        "docstring": null,
                        "function_body": "    def get_purchase_order_type_by_pulse_id(self, pulse_id):\n        found = self.db_ops.search_purchase_orders(['pulse_id'], [pulse_id])\n        if not found:\n            return None\n        if isinstance(found, list):\n            found = found[0]\n        return found.get('po_type')"
                    },
                    {
                        "name": "get_detail_item_by_pulse_id",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items"
                        ],
                        "docstring": null,
                        "function_body": "    def get_detail_item_by_pulse_id(self, pulse_id):\n        found = self.db_ops.search_detail_items(['pulse_id'], [pulse_id])\n        if isinstance(found, list) and len(found) > 0:\n            return found[0]\n        return found"
                    },
                    {
                        "name": "update_db_with_sub_item_change",
                        "args": [
                            "self",
                            "change_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items",
                            "update_detail_item"
                        ],
                        "docstring": "Applies a prepared change to a DetailItem.",
                        "function_body": "    def update_db_with_sub_item_change(self, change_item):\n        \"\"\"\n        Applies a prepared change to a DetailItem.\n        \"\"\"\n        pulse_id = change_item.get('pulse_id')\n        db_field = change_item.get('db_field')\n        new_value = change_item.get('new_value')\n        if not pulse_id or not db_field:\n            self.logger.error('[update_db_with_sub_item_change] - Incomplete change_item data provided.')\n            return 'Fail'\n        found_sub = self.db_ops.search_detail_items(['pulse_id'], [pulse_id])\n        if not found_sub:\n            self.logger.info(f'[update_db_with_sub_item_change] - No DetailItem found with pulse_id {pulse_id}.')\n            return 'Not Found'\n        if isinstance(found_sub, list):\n            found_sub = found_sub[0]\n        detail_id = found_sub['id']\n        updated = self.db_ops.update_detail_item(detail_id, **{db_field: new_value})\n        if updated:\n            self.logger.info(f'[update_db_with_sub_item_change] - Updated DetailItem {pulse_id}: set {db_field} to {new_value}')\n            return 'Success'\n        return 'Fail'"
                    },
                    {
                        "name": "delete_purchase_order_in_db",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders",
                            "get_db_session"
                        ],
                        "docstring": "Example: Search the PO by pulse_id, then if found, delete it.",
                        "function_body": "    def delete_purchase_order_in_db(self, pulse_id):\n        \"\"\"\n        Example: Search the PO by pulse_id, then if found, delete it.\n        \"\"\"\n        found_po = self.db_ops.search_purchase_orders(['pulse_id'], [pulse_id])\n        if not found_po:\n            self.logger.error(f'[delete_purchase_order_in_db] - PurchaseOrder with pulse_id {pulse_id} does not exist.')\n            return False\n        if isinstance(found_po, list):\n            found_po = found_po[0]\n        from database.db_util import get_db_session\n        from database.models import PurchaseOrder\n        with get_db_session() as session:"
                    },
                    {
                        "name": "delete_detail_item_in_db",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items",
                            "get_db_session"
                        ],
                        "docstring": "Example: Search the DetailItem by pulse_id, then delete it if found.",
                        "function_body": "    def delete_detail_item_in_db(self, pulse_id):\n        \"\"\"\n        Example: Search the DetailItem by pulse_id, then delete it if found.\n        \"\"\"\n        found_sub = self.db_ops.search_detail_items(['pulse_id'], [pulse_id])\n        if not found_sub:\n            self.logger.error(f'[delete_detail_item_in_db] - DetailItem with pulse_id {pulse_id} does not exist.')\n            return False\n        if isinstance(found_sub, list):\n            found_sub = found_sub[0]\n        from database.db_util import get_db_session\n        from database.models import DetailItem\n        with get_db_session() as session:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_database_util",
                "value": "MondayDatabaseUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_service.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83c\udf1f Sets up logging, references to Monday utilities & DB ops,\nand relevant board/column config from Config & monday_util.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        \ud83c\udf1f Sets up logging, references to Monday utilities & DB ops,\n        and relevant board/column config from Config & monday_util.\n        \"\"\"\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "_make_request",
                        "args": [
                            "self",
                            "query",
                            "variables"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "Internal method that delegates to the official 'monday_api' for raw GraphQL queries.",
                        "function_body": "    def _make_request(self, query: str, variables: dict = None):\n        \"\"\"\n        Internal method that delegates to the official 'monday_api' for raw GraphQL queries.\n        \"\"\"\n        self.logger.debug(\"\ud83d\udd12 [_make_request] - Delegating GraphQL request to monday_api.\")\n        return self.monday_api._make_request(query, variables=variables)"
                    },
                    {
                        "name": "update_po_status",
                        "args": [
                            "self",
                            "pulse_id",
                            "status"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83c\udfa8 Update the status of a Purchase Order (PO) in Monday.com\nusing a known column_id for 'status' from monday_util.",
                        "function_body": "    def update_po_status(self, pulse_id: int, status: str):\n        \"\"\"\n        \ud83c\udfa8 Update the status of a Purchase Order (PO) in Monday.com\n        using a known column_id for 'status' from monday_util.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd8d\ufe0f [update_po_status] - Updating PO item_id={pulse_id} to status='{status}'...\")\n        try:"
                    },
                    {
                        "name": "match_or_create_contact",
                        "args": [
                            "self",
                            "vendor_name",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_item_by_name",
                            "create_contact"
                        ],
                        "docstring": "\ud83d\udd0e Either finds an existing contact by vendor_name or creates a new one, then optionally links it to the PO in local DB.\n\n:param vendor_name: The vendor's name from your PO record\n:param po_number: The PO number for linking logic\n:return: contact_id in Monday.com (pulse_id)",
                        "function_body": "    def match_or_create_contact(self, vendor_name: str, po_number: str) -> int:\n        \"\"\"\n        \ud83d\udd0e Either finds an existing contact by vendor_name or creates a new one, then optionally links it to the PO in local DB.\n\n        :param vendor_name: The vendor's name from your PO record\n        :param po_number: The PO number for linking logic\n        :return: contact_id in Monday.com (pulse_id)\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd17 [match_or_create_contact] - Attempting to match or create contact for vendor='{vendor_name}', PO='{po_number}'...\")\n        try:"
                    },
                    {
                        "name": "get_po_number_from_item",
                        "args": [
                            "self",
                            "item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the PO number from a specific item in Monday.com using your existing monday_util method.",
                        "function_body": "    def get_po_number_from_item(self, item_id: int) -> Any | None:\n        \"\"\"\n        Retrieves the PO number from a specific item in Monday.com using your existing monday_util method.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd0e [get_po_number_from_item] - Attempting to retrieve PO number for item={item_id}...\")\n        try:"
                    },
                    {
                        "name": "upsert_po_in_monday",
                        "args": [
                            "self",
                            "po_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_item_by_po_and_project",
                            "update_item",
                            "create_item"
                        ],
                        "docstring": null,
                        "function_body": "    def upsert_po_in_monday(self, po_record: dict):\n        self.logger.info(f\"\ud83c\udf10 [upsert_po_in_monday] - Handling upsert for PO record:\\n    {po_record}\")\n        project_number = po_record.get('project_number')\n        po_number = po_record.get('po_number')\n        pulse_id = po_record.get('pulse_id')\n        description = po_record.get('description')\n        contact_name = po_record.get(\"vendor_name\")\n\n        # Prepare column values using the formatter function from monday_util.\n        column_values_dict = self._build_po_column_values(po_record)\n        column_values_str = json.dumps(column_values_dict)\n\n        if not pulse_id:\n            self.logger.info(\"\ud83d\udd0e Checking if item already exists in Monday by project_number & po_number...\")\n            search_resp = self.monday_api.fetch_item_by_po_and_project(project_number, po_number)\n            items_found = search_resp['data']['items_page_by_column_values']['items']\n\n            if len(items_found) == 1:\n                existing_item = items_found[0]\n                existing_id = existing_item['id']\n                self.logger.info(f\"\ud83d\udd17 Found existing PO item => ID={existing_id}. Updating columns.\")\n                po_record['pulse_id'] = existing_id\n                self.monday_api.update_item(existing_id, column_values_str, type='main')\n            else:\n                self.logger.info(\"\ud83c\udd95 No matching item found => creating new one.\")\n                group_id = 'topics'  # or however you choose the group\n                create_resp = self.monday_api.create_item(\n                    board_id=self.board_id,\n                    group_id=group_id,\n                    name=contact_name or f\"PO#{po_number}\",\n                    column_values=column_values_str\n                )\n                try:\n                    new_id = create_resp['data']['create_item']['id']\n                    po_record['pulse_id'] = new_id\n                    self.logger.info(f\"\ud83c\udf89 Created new PO item => ID={new_id} for PO#{po_number}\")\n                except Exception as ce:\n                    self.logger.error(f\"\u274c Could not create PO item for po_number={po_number}: {ce}\")\n        else:\n            self.logger.info(f\"\u2139\ufe0f Existing pulse_id={pulse_id} found => updating columns.\")\n            self.monday_api.update_item(pulse_id, column_values_str, type='main')\n\n        self.logger.info(\"\u2705 [upsert_po_in_monday] - Finished upsert logic for PO record.\")"
                    },
                    {
                        "name": "upsert_detail_subitem_in_monday",
                        "args": [
                            "self",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "_build_detail_subitem_values",
                            "update_item",
                            "create_subitem"
                        ],
                        "docstring": null,
                        "function_body": "    def upsert_detail_subitem_in_monday(self, detail_item: dict):\n        self.logger.info(f\"\ud83e\uddf1 [upsert_detail_subitem_in_monday] - Handling subitem upsert:\\n    {detail_item}\")\n        parent_id = detail_item.get('parent_pulse_id')\n        if not parent_id:\n            self.logger.warning(\"\u26a0\ufe0f No parent_pulse_id; cannot create subitem. Exiting.\")\n            return\n\n        column_values_dict = self._build_detail_subitem_values(detail_item)\n        column_values_json_str = json.dumps(column_values_dict)\n        self.logger.debug(f\"\ud83d\udd8c\ufe0f Column values for subitem: {column_values_json_str}\")\n\n        subitem_id = detail_item.get('pulse_id')\n        if subitem_id:\n            self.logger.info(f\"\ud83d\udd04 Updating existing subitem ID={subitem_id}...\")\n            self.monday_api.update_item(subitem_id, column_values_json_str, type='subitem')\n        else:\n            self.logger.info(\"\ud83d\udd0e No existing subitem found; creating new one.\")\n            create_resp = self.monday_api.create_subitem(\n                parent_item_id=parent_id,\n                subitem_name=detail_item.get('description') or f\"Line {detail_item.get('line_number')}\",\n                column_values=column_values_dict  # Pass the dict directly as variable\n            )\n            if create_resp and create_resp['data']['create_subitem'].get('id'):\n                new_id = create_resp['data']['create_subitem']['id']\n                detail_item['pulse_id'] = new_id\n                self.logger.info(f\"\ud83c\udf89 Created new subitem with ID={new_id}\")\n            else:\n                self.logger.warning(\"\u274c Could not create new subitem; no 'id' in response.\")\n\n        self.logger.info(\"\ud83c\udfc1 [upsert_detail_subitem_in_monday] - Completed subitem upsert.\")"
                    },
                    {
                        "name": "sync_main_items_from_monday_board",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_all_items",
                            "create_or_update_main_item_in_db"
                        ],
                        "docstring": "\u267b\ufe0f Pull main items from Monday's PO board, then attempt to sync them into the DB.\nYou can store them using self.db_util if needed.",
                        "function_body": "    def sync_main_items_from_monday_board(self):\n        \"\"\"\n        \u267b\ufe0f Pull main items from Monday's PO board, then attempt to sync them into the DB.\n        You can store them using self.db_util if needed.\n        \"\"\"\n        self.logger.info(f'\ud83d\udce5 [sync_main_items_from_monday_board] - Fetching items from board {self.board_id}...')\n        try:"
                    },
                    {
                        "name": "sync_sub_items_from_monday_board",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_or_update_sub_item_in_db",
                            "fetch_all_sub_items"
                        ],
                        "docstring": "\u267b\ufe0f Pull subitems from Monday's subitem board, then sync them to DB.",
                        "function_body": "    def sync_sub_items_from_monday_board(self):\n        \"\"\"\n        \u267b\ufe0f Pull subitems from Monday's subitem board, then sync them to DB.\n        \"\"\"\n        self.logger.info(f'\ud83d\udce5 [sync_sub_items_from_monday_board] - Fetching sub-items from board {self.subitem_board_id}...')\n        try:\n            all_subitems = self.monday_api.fetch_all_sub_items()\n            self.logger.info(f'\ud83e\udde9 [sync_sub_items_from_monday_board] - Fetched {len(all_subitems)} sub-items from board {self.subitem_board_id}')\n        except Exception as e:\n            self.logger.error(f'\u26a0\ufe0f [sync_sub_items_from_monday_board] - Error fetching sub-items: {e}')\n            return\n\n        # region \ud83d\uddc2 Process items\n        try:"
                    },
                    {
                        "name": "sync_contacts_from_monday_board",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_contact",
                            "parse_tax_number",
                            "fetch_all_contacts",
                            "extract_monday_contact_fields",
                            "create_contact"
                        ],
                        "docstring": "\u267b\ufe0f Pull contacts from Monday's contact board, then sync them into local DB.",
                        "function_body": "    def sync_contacts_from_monday_board(self):\n        \"\"\"\n        \u267b\ufe0f Pull contacts from Monday's contact board, then sync them into local DB.\n        \"\"\"\n        self.logger.info(f'\ud83d\udce5 [sync_contacts_from_monday_board] - Fetching contacts from board {self.contact_board_id}...')\n        try:\n            all_contacts = self.monday_api.fetch_all_contacts()\n            self.logger.info(f'\ud83d\uddc2 [sync_contacts_from_monday_board] - Fetched {len(all_contacts)} contact(s).')\n        except Exception as e:\n            self.logger.error(f'\u26a0\ufe0f [sync_contacts_from_monday_board] - Error fetching contacts: {e}')\n            return\n\n        # region \ud83d\uddc3 Store or Update in DB\n        try:\n            for contact in all_contacts:\n                monday_fields = self.monday_api.extract_monday_contact_fields(contact)\n                tax_number_int = None\n                if monday_fields['tax_number_str']:\n                    tax_number_int = self.database_util.parse_tax_number(monday_fields['tax_number_str'])\n                vendor_status = monday_fields['vendor_status']\n                if vendor_status not in ['PENDING', 'TO VERIFY', 'APPROVED', 'ISSUE']:\n                    vendor_status = 'PENDING'\n                try:\n                    existing_contact = self.database_util.find_contact_by_name(contact_name=contact['name'])\n                    if not existing_contact:\n                        db_contact = self.database_util.create_contact(\n                            name=contact['name'],\n                            pulse_id=monday_fields['pulse_id'],\n                            phone=monday_fields['phone'],\n                            email=monday_fields['email'],\n                            address_line_1=monday_fields['address_line_1'],\n                            address_line_2=monday_fields['address_line_2'],\n                            city=monday_fields['city'],\n                            zip=monday_fields['zip_code'],\n                            region=monday_fields['region'],\n                            country=monday_fields['country'],\n                            tax_type=monday_fields['tax_type'],\n                            tax_number=tax_number_int,\n                            payment_details=monday_fields['payment_details'],\n                            vendor_status=vendor_status,\n                            tax_form_link=monday_fields['tax_form_link']\n                        )\n                    else:\n                        db_contact = self.database_util.update_contact(\n                            contact_id=existing_contact['id'],\n                            name=contact['name'],\n                            pulse_id=monday_fields['pulse_id'],\n                            phone=monday_fields['phone'],\n                            email=monday_fields['email'],\n                            address_line_1=monday_fields['address_line_1'],\n                            address_line_2=monday_fields['address_line_2'],\n                            city=monday_fields['city'],\n                            zip=monday_fields['zip_code'],\n                            region=monday_fields['region'],\n                            country=monday_fields['country'],\n                            tax_type=monday_fields['tax_type'],\n                            tax_number=tax_number_int,\n                            payment_details=monday_fields['payment_details'],\n                            vendor_status=vendor_status,\n                            tax_form_link=monday_fields['tax_form_link']\n                        )\n                    self.logger.info(f\"\ud83d\udd04 [sync_contacts_from_monday_board] - Synced contact => {contact['name']}, ID={db_contact.get('id') if db_contact else '??'}\")\n                except Exception as ce:\n                    self.logger.error(f'\u274c [sync_contacts_from_monday_board] - Error adding contact to DB: {ce}')\n        except Exception as e:\n            self.logger.error(f'\u274c [sync_contacts_from_monday_board] - Error syncing contacts to DB: {e}')\n        self.logger.info('\u2705 [sync_contacts_from_monday_board] - Contacts synchronization done.')"
                    },
                    {
                        "name": "buffered_upsert_po",
                        "args": [
                            "self",
                            "po_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "purchase_order_has_changes"
                        ],
                        "docstring": "\ud83c\udf00 [START] Stage a PurchaseOrder for eventual upsert in Monday IF:\n  - There's no 'pulse_id' (new record),\n  - OR if db_ops.purchase_order_has_changes(...) is True.\n\n:param po_record: Local DB dict (has 'id', 'project_number', 'po_number', possibly 'pulse_id', etc.)",
                        "function_body": "    def buffered_upsert_po(self, po_record: dict):\n        \"\"\"\n        \ud83c\udf00 [START] Stage a PurchaseOrder for eventual upsert in Monday IF:\n          - There's no 'pulse_id' (new record),\n          - OR if db_ops.purchase_order_has_changes(...) is True.\n\n        :param po_record: Local DB dict (has 'id', 'project_number', 'po_number', possibly 'pulse_id', etc.)\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Attempting to stage a PurchaseOrder for Monday upsert...\")\n        if not po_record:\n            self.logger.warning(\"\ud83c\udf00 No PO record => skipping.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Fail]\")\n            return\n\n        local_id = po_record.get('id')\n        pulse_id = po_record.get('pulse_id')\n\n        # Check if newly created (no pulse_id) or if aggregator says we have DB changes:\n        if not pulse_id:\n            self.logger.info(\"\ud83c\udd95 PO has no pulse_id => definitely enqueueing for creation in Monday.\")\n            self._po_upsert_queue.append(po_record)\n        else:\n            # Use db_ops to see if we have changes\n            has_changes = self.db_ops.purchase_order_has_changes(\n                record_id=local_id,\n                # if you want to pass newly updated fields to check, for example:\n                project_number=po_record.get('project_number'),\n                po_number=po_record.get('po_number'),\n                description=po_record.get('description'),\n                folder_link=po_record.get('folder_link')\n                # ... any other fields that might differ ...\n            )\n            if has_changes:\n                self.logger.info(f\"\ud83c\udf00 PO {local_id} => aggregator indicates changes => enqueueing update.\")\n                self._po_upsert_queue.append(po_record)\n            else:\n                self.logger.info(\"\ud83c\udf00 No changes => skipping Monday upsert for this PO.\")\n\n        self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success] Staged PO for Monday upsert.\")"
                    },
                    {
                        "name": "execute_batch_upsert_pos",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "batch_create_or_update_items",
                            "update_purchase_order",
                            "search_contacts"
                        ],
                        "docstring": "\ud83c\udf00 [START] Actually perform the create/update in Monday for all queued POs,\nusing the existing monday_api's batch_create_or_update_items method.\n\nClears the queue at the end.",
                        "function_body": "    def execute_batch_upsert_pos(self):\n        \"\"\"\n        \ud83c\udf00 [START] Actually perform the create/update in Monday for all queued POs,\n        using the existing monday_api's batch_create_or_update_items method.\n\n        Clears the queue at the end.\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Performing batched PO upserts in Monday...\")\n\n        if not self._po_upsert_queue:\n            self.logger.info(\"\ud83c\udf00 No POs in queue => nothing to upsert.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success] No work done.\")\n            return\n\n        items_to_create = []\n        items_to_update = []\n\n        # Build batch data for each queued PO\n        for po_data in self._po_upsert_queue:\n            pulse_id = po_data.get('pulse_id')\n\n            contact_record = self.db_ops.search_contacts([\"id\"], [po_data[\"contact_id\"]])\n            if isinstance(contact_record, list):\n                contact_record = contact_record[0]\n            contact_pulse_id = contact_record['pulse_id']\n\n            if not pulse_id:\n                items_to_create.append({\n                    'db_item': po_data,\n                    'monday_item_id': None,\n                    'monday_contact_id': contact_pulse_id\n                })\n            else:\n                items_to_update.append({\n                    'db_item': po_data,\n                    'monday_item_id': pulse_id,\n                    \"monday_contact_id\": contact_pulse_id\n                })\n\n        self.logger.info(f\"\ud83c\udf00 Upserting POs => create={len(items_to_create)}, update={len(items_to_update)}\")\n\n        # If you want to group by project_number, do so. We'll pick from the first create item:\n        project_id = None\n        if items_to_create:\n            project_id = items_to_create[0]['db_item'].get('project_number')\n\n        # Actually do the create calls\n        created_results = []\n        if items_to_create:\n            created_results = self.monday_api.batch_create_or_update_items(\n                batch=items_to_create,\n                project_id=project_id or \"Unknown\",\n                create=True\n            )\n\n        # Do the update calls\n        updated_results = []\n        if items_to_update:\n            updated_results = self.monday_api.batch_create_or_update_items(\n                batch=items_to_update,\n                project_id=project_id or \"Unknown\",\n                create=False\n            )\n\n        self._po_upsert_queue.clear()\n\n        total_processed = len(created_results) + len(updated_results)\n        self.logger.info(f\"\ud83c\udf00 [COMPLETED] [STATUS=Success] PO batch upsert => total={total_processed} processed.\")\n\n        #SAVE RESULTS TO DB\n        self.logger.info(f\"\ud83d\udedf Saving new Pulse IDs to DB\")\n        for result in created_results:\n            self.db_ops.update_purchase_order(result[\"db_item\"][\"id\"], pulse_id=result[\"monday_item_id\"])\n        self.logger.info(f\"\ud83d\udedf Saved {len(created_results)}  Pulse IDs to DB\")"
                    },
                    {
                        "name": "buffered_upsert_contact",
                        "args": [
                            "self",
                            "contact_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "contact_has_changes"
                        ],
                        "docstring": "\ud83c\udf00 [START] Stage a Contact record for Monday upsert\nif newly created or aggregator says it changed (contact_has_changes).",
                        "function_body": "    def buffered_upsert_contact(self, contact_record: dict):\n        \"\"\"\n        \ud83c\udf00 [START] Stage a Contact record for Monday upsert\n        if newly created or aggregator says it changed (contact_has_changes).\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Attempting to stage a Contact for Monday upsert...\")\n        if not contact_record:\n            self.logger.warning(\"\ud83c\udf00 No contact_record => skipping.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Fail]\")\n            return\n\n        contact_id = contact_record.get('id')\n        pulse_id = contact_record.get('pulse_id')\n\n        # If no pulse_id => definitely new in Monday\n        if not pulse_id:\n            self.logger.info(\"\ud83c\udd95 Contact has no pulse_id => enqueuing for Monday create.\")\n            self.contact_upsert_queue.append(contact_record)\n        else:\n            # Check if aggregator logic indicates changes\n            has_changes = self.db_ops.contact_has_changes(\n                record_id=contact_id,\n                name=contact_record.get('name'),\n                email=contact_record.get('email'),\n                phone=contact_record.get('phone'),\n                payment_details=contact_record.get('payment_details'),\n                vendor_status=contact_record.get('vendor_status'),\n                address_line_1=contact_record.get('address_line_1'),\n                address_line_2=contact_record.get('address_line_2'),\n                city=contact_record.get('city'),\n                zip=contact_record.get('zip'),\n                region=contact_record.get('region'),\n                country=contact_record.get('country'),\n                tax_type=contact_record.get('tax_type'),\n                tax_number=contact_record.get('tax_number'),\n                tax_form_link=contact_record.get('tax_form_link'),\n                xero_id=contact_record.get('xero_id'),\n                session=None,  # or pass a session if needed\n            )\n            if has_changes:\n                self.logger.info(f\"\ud83c\udf00 Contact {contact_id} => aggregator indicates changes => enqueueing update.\")\n                self.contact_upsert_queue.append(contact_record)\n            else:\n                self.logger.info(\"\ud83c\udf00 No contact changes => skipping Monday upsert.\")\n\n        self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success] Staged Contact for Monday upsert.\")"
                    },
                    {
                        "name": "execute_batch_upsert_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "batch_create_or_update_items",
                            "_build_contact_column_values"
                        ],
                        "docstring": "\ud83c\udf00 Perform the batch create/update in Monday for all queued contacts,\nclearing the queue afterwards.",
                        "function_body": "    def execute_batch_upsert_contacts(self):\n        \"\"\"\n        \ud83c\udf00 Perform the batch create/update in Monday for all queued contacts,\n        clearing the queue afterwards.\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Performing batched Contact upserts in Monday...\")\n\n        if not self.contact_upsert_queue:\n            self.logger.info(\"\ud83c\udf00 No contacts in queue => nothing to upsert.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success] None processed.\")\n            return\n\n        items_to_create = []\n        items_to_update = []\n\n        for ct_data in self.contact_upsert_queue:\n            pulse_id = ct_data.get('pulse_id')\n            col_vals = self._build_contact_column_values(ct_data)\n\n            if not pulse_id:\n                items_to_create.append({\n                    'db_item': ct_data,\n                    'column_values': col_vals,\n                    'monday_item_id': None\n                })\n            else:\n                items_to_update.append({\n                    'db_item': ct_data,\n                    'column_values': col_vals,\n                    'monday_item_id': pulse_id\n                })\n\n        self.logger.info(f\"\ud83c\udf00 Upserting Contacts => create={len(items_to_create)}, update={len(items_to_update)}\")\n\n        # For contacts, we might not have a 'project_id', so just call them \"Contacts\"\n        project_id = \"Contacts\"\n        created_results = []\n        updated_results = []\n\n        if items_to_create:\n            created_results = self.monday_api.batch_create_or_update_items(\n                batch=items_to_create,\n                project_id=project_id,\n                create=True\n            )\n        if items_to_update:\n            updated_results = self.monday_api.batch_create_or_update_items(\n                batch=items_to_update,\n                project_id=project_id,\n                create=False\n            )\n\n        self.contact_upsert_queue.clear()\n        total = len(created_results) + len(updated_results)\n        self.logger.info(f\"\ud83c\udf00 [COMPLETED] [STATUS=Success] Contact batch => total={total} processed.\")"
                    },
                    {
                        "name": "_build_contact_column_values",
                        "args": [
                            "self",
                            "contact_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Build column values dict for a contact.\nOnly do so if aggregator says changes or new record.",
                        "function_body": "    def _build_contact_column_values(self, contact_data: dict) -> dict:\n        \"\"\"\n        Build column values dict for a contact.\n        Only do so if aggregator says changes or new record.\n        \"\"\"\n        col_vals = {}\n        if contact_data.get('name'):\n            col_vals[self.monday_util.CONTACT_NAME] = str(contact_data['name'])\n        if contact_data.get('vendor_status'):\n            col_vals[self.monday_util.CONTACT_STATUS] = {'label': contact_data[\"vendor_status\"]}\n        if contact_data.get('payment_details'):\n            col_vals[self.monday_util.CONTACT_PAYMENT_DETAILS] = {'label': contact_data[\"payment_details\"]}\n        if contact_data.get(\"vendor_type\"):\n            pass #TODO need to add field to mnd\n        if contact_data.get('email'):\n            col_vals[self.monday_util.CONTACT_EMAIL] = str(contact_data['email'])\n        if contact_data.get('phone'):\n            col_vals[self.monday_util.CONTACT_PHONE] = str(contact_data['phone'])\n        if contact_data.get('address_line_1'):\n            col_vals[self.monday_util.CONTACT_ADDRESS_LINE_1] = str(contact_data['address_line_1'])\n        if contact_data.get('address_line_2'):\n            col_vals[self.monday_util.CONTACT_ADDRESS_LINE_2] = str(contact_data['address_line_2'])\n        if contact_data.get('city'):\n            col_vals[self.monday_util.CONTACT_ADDRESS_CITY] = str(contact_data['city'])\n        if contact_data.get('zip'):\n            col_vals[self.monday_util.CONTACT_ADDRESS_ZIP] = str(contact_data['zip'])\n        if contact_data.get('region'):\n            pass #TODO need to add field to mnd\n        if contact_data.get('country'):\n            col_vals[self.monday_util.CONTACT_ADDRESS_COUNTRY] = str(contact_data['country'])\n        if contact_data.get('tax_type'):\n            col_vals[self.monday_util.CONTACT_TAX_TYPE] = str(contact_data['tax_type'])\n        if contact_data.get('tax_number'):\n            col_vals[self.monday_util.CONTACT_TAX_NUMBER] = str(contact_data['tax_number'])\n           #TODO modify this for new tax form structure\n        if contact_data.get('tax_form_link'):\n            link_lower = contact_data['tax_form_link'].lower()\n            if 'w9' in link_lower:\n                link_text = '\ud83c\uddfa\ud83c\uddf8 W-9'\n            elif 'w8-ben-e' in link_lower:\n                link_text = '\ud83c\udf0e W-8BEN-E \ud83c\udfe2'\n            elif 'w8-ben' in link_lower:\n                link_text = '\ud83c\udf0e W-8BEN \ud83d\ude4b'\n            else:\n                link_text = 'Tax Form \ud83e\udd37'\n            col_vals[self.monday_util.CONTACT_TAX_FORM_LINK] = {\n                'url': contact_data['tax_form_link'],\n                'text': link_text\n            }\n\n        if contact_data.get(\"xero_id\"):\n            pass #TODO need to add field to mnd\n\n\n\n        self.logger.debug(f\"\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5\ud83d\udca5{col_vals}\")\n\n        return col_vals"
                    },
                    {
                        "name": "buffered_upsert_detail_item",
                        "args": [
                            "self",
                            "detail_record"
                        ],
                        "decorators": [],
                        "calls": [
                            "detail_item_has_changes"
                        ],
                        "docstring": "\ud83c\udf00 [START] Stage a detail item for Monday subitem upsert.\nIf aggregator found changes (detail_item_has_changes) or no subitem ID,\nwe enqueue.\n\ndetail_record: local dict, possibly has 'parent_id', 'pulse_id', etc.\nFor subitems, we might store 'parent_pulse_id' for the main item\nand 'pulse_id' for the subitem itself.",
                        "function_body": "    def buffered_upsert_detail_item(self, detail_record: dict):\n        \"\"\"\n        \ud83c\udf00 [START] Stage a detail item for Monday subitem upsert.\n        If aggregator found changes (detail_item_has_changes) or no subitem ID,\n        we enqueue.\n\n        detail_record: local dict, possibly has 'parent_id', 'pulse_id', etc.\n        For subitems, we might store 'parent_pulse_id' for the main item\n        and 'pulse_id' for the subitem itself.\n        \"\"\"\n        if not detail_record:\n            self.logger.warning(\"\ud83c\udf00 No detail_item record => skipping.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Fail]\")\n            return\n\n        record_id = detail_record.get('id')\n        subitem_id = detail_record.get('pulse_id')  # or some field that means 'subitem pulse_id'\n        parent_pulse_id = detail_record.get('parent_pulse_id')\n\n        # If aggregator says no changes + subitem_id exists => skip\n        has_changes = self.db_ops.detail_item_has_changes(\n            record_id=record_id,\n            project_number=detail_record.get('project_number'),\n            po_number=detail_record.get('po_number'),\n            detail_number=detail_record.get('detail_number'),\n            line_number=detail_record.get('line_number'),\n            state=detail_record.get('state'),\n            description=detail_record.get('description'),\n            transaction=detail_record.get('transaction_date'),\n            due_date=detail_record.get('due_date'),\n            rate=detail_record.get('rate'),\n            quantity=detail_record.get('quantity'),\n            ot=detail_record.get('ot'),\n            fringes=detail_record.get('fringes'),\n            receipt_id=detail_record.get('receipt_id'),\n            invoid_id=detail_record.get('invoid_id'),\n            pulse_id=detail_record.get('pulse_id'),\n            parent_pulse_id=detail_record.get('parent_pulse_id'),\n            payment_type=detail_record.get('payment_type')\n        )\n\n        if not subitem_id and not has_changes:\n            # If there's absolutely no subitem ID, but aggregator also says no changes,\n            # it's still \"new\"? Actually, aggregator presumably created it in DB =>\n            # that alone might be changes. But if there's truly no difference from the aggregator perspective,\n            # we skip.\n            self.logger.info(\"\ud83c\udf00 No subitem_id, aggregator says no changes => skipping subitem upsert.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=NoChange]\")\n            return\n\n        if subitem_id:\n            # We have a subitem ID => only queue if has_changes\n            if has_changes:\n                self.logger.info(\"\ud83c\udf00 Subitem has changes => enqueueing update.\")\n                self._detail_upsert_queue.append(detail_record)\n            else:\n                self.logger.info(\"\ud83c\udf00 Subitem no changes => skipping Monday.\")\n        else:\n            # No subitem_id => new subitem\n            self.logger.info(\"\ud83c\udd95 No subitem_id => definitely enqueueing for Monday create.\")\n            self._detail_upsert_queue.append(detail_record)\n\n        self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success] Staged detail item for subitem upsert.\")"
                    },
                    {
                        "name": "execute_batch_upsert_detail_items",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_build_detail_subitem_values",
                            "batch_create_or_update_subitems"
                        ],
                        "docstring": "\ud83c\udf00 Perform batch create/update of detail items as Monday subitems.\nClears the queue after.",
                        "function_body": "    def execute_batch_upsert_detail_items(self):\n        \"\"\"\n        \ud83c\udf00 Perform batch create/update of detail items as Monday subitems.\n        Clears the queue after.\n        \"\"\"\n        self.logger.info(\"\ud83c\udf00 [START] Performing batched subitem upserts in Monday...\")\n\n        if not self._detail_upsert_queue:\n            self.logger.info(\"\ud83c\udf00 No detail items queued => done.\")\n            self.logger.info(\"\ud83c\udf00 [COMPLETED] [STATUS=Success]\")\n            return\n\n        items_to_create = []\n        items_to_update = []\n\n        for di_data in self._detail_upsert_queue:\n            subitem_id = di_data.get('pulse_id')\n            parent_item_id = di_data.get('parent_pulse_id')\n            col_vals = self._build_detail_subitem_values(di_data)\n\n            if not subitem_id:\n                # create\n                items_to_create.append({\n                    'db_sub_item': di_data,\n                    'column_values': col_vals,\n                    'parent_id': parent_item_id\n                })\n            else:\n                # update\n                items_to_update.append({\n                    'db_sub_item': di_data,\n                    'column_values': col_vals,\n                    'parent_id': parent_item_id,\n                    'monday_item_id': subitem_id\n                })\n\n        self.logger.info(f\"\ud83c\udf00 Subitem upsert => create={len(items_to_create)}, update={len(items_to_update)}\")\n\n        created_results = []\n        updated_results = []\n\n        if items_to_create:\n            self.logger.info(\"\ud83c\udf00 Creating subitems in Monday...\")\n            created_results = self.monday_api.batch_create_or_update_subitems(\n                subitems_batch=items_to_create,\n                parent_item_id=None,\n                # Each item in subitems_batch might have different 'parent_id'; you can adapt or loop\n                create=True\n            )\n        if items_to_update:\n            self.logger.info(\"\ud83c\udf00 Updating subitems in Monday...\")\n            updated_results = self.monday_api.batch_create_or_update_subitems(\n                subitems_batch=items_to_update,\n                parent_item_id=None,  # same note above\n                create=False\n            )\n\n        self._detail_upsert_queue.clear()\n        total_proc = len(created_results) + len(updated_results)\n        self.logger.info(f\"\ud83c\udf00 [COMPLETED] [STATUS=Success] subitem upsert => total={total_proc} processed.\")"
                    },
                    {
                        "name": "_build_detail_subitem_values",
                        "args": [
                            "self",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "subitem_column_values_formatter"
                        ],
                        "docstring": "Constructs the column values for a detail item subitem using the formatter\nfunction from monday_util.",
                        "function_body": "    def _build_detail_subitem_values(self, detail_item: dict) -> dict:\n        \"\"\"\n        Constructs the column values for a detail item subitem using the formatter\n        function from monday_util.\n        \"\"\"\n        formatted_json_str = self.monday_util.subitem_column_values_formatter(\n            project_id=detail_item.get('project_number'),\n            po_number=detail_item.get('po_number'),\n            detail_number=detail_item.get('detail_number'),\n            line_number=detail_item.get('line_number'),\n            description=detail_item.get('description'),\n            quantity=detail_item.get('quantity'),\n            rate=detail_item.get('rate'),\n            date=detail_item.get('transaction_date'),\n            due_date=detail_item.get('due_date'),\n            account_number=detail_item.get('account_code'),\n            link=detail_item.get('file_link'),\n            OT=detail_item.get('ot'),\n            fringes=detail_item.get('fringes')\n        )\n        return json.loads(formatted_json_str)"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_service",
                "value": "MondayService()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_webhook_handler.py",
        "functions": [
            {
                "name": "po_status_change",
                "args": [],
                "decorators": [
                    "monday_blueprint.route('/po_status_change')"
                ],
                "calls": [
                    "process_po_status_change",
                    "verify_challenge"
                ],
                "docstring": "Endpoint to handle PO status change events from Monday.com.",
                "function_body": "def po_status_change():\n    \"\"\"\n    Endpoint to handle PO status change events from Monday.com.\n    \"\"\"\n    logger.debug('PO status change event received')\n    event = request.get_json()\n    if not event:\n        return (jsonify({'error': 'Invalid event data'}), 400)\n    challenge_response = monday_webhook_handler.verify_challenge(event)\n    if challenge_response:"
            },
            {
                "name": "subitem_change",
                "args": [],
                "decorators": [
                    "monday_blueprint.route('/subitem_change')"
                ],
                "calls": [
                    "verify_challenge",
                    "process_sub_item_change"
                ],
                "docstring": "Endpoint to handle SubItem change events from Monday.com.",
                "function_body": "def subitem_change():\n    \"\"\"\n    Endpoint to handle SubItem change events from Monday.com.\n    \"\"\"\n    logger.debug('SubItem change event received')\n    event = request.get_json()\n    if not event:\n        return (jsonify({'error': 'Invalid event data'}), 400)\n    challenge_response = monday_webhook_handler.verify_challenge(event)\n    if challenge_response:"
            },
            {
                "name": "subitem_delete",
                "args": [],
                "decorators": [
                    "monday_blueprint.route('/subitem_delete')"
                ],
                "calls": [
                    "process_sub_item_delete",
                    "verify_challenge"
                ],
                "docstring": "Endpoint to handle SubItem deletion events from Monday.com.",
                "function_body": "def subitem_delete():\n    \"\"\"\n    Endpoint to handle SubItem deletion events from Monday.com.\n    \"\"\"\n    logger.debug('SubItem delete event received')\n    event = request.get_json()\n    if not event:\n        return (jsonify({'error': 'Invalid event data'}), 400)\n    challenge_response = monday_webhook_handler.verify_challenge(event)\n    if challenge_response:"
            }
        ],
        "classes": [
            {
                "name": "MondayWebhookHandler",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "verify_challenge",
                        "args": [
                            "event"
                        ],
                        "decorators": [
                            "staticmethod"
                        ],
                        "calls": [],
                        "docstring": "Verify if the event contains a challenge and respond accordingly.\n\nArgs:\n    event (dict): The event data received from Monday.com.\n\nReturns:\n    Response object if challenge is present, otherwise None.",
                        "function_body": "    def verify_challenge(event):\n        \"\"\"\n        Verify if the event contains a challenge and respond accordingly.\n\n        Args:\n            event (dict): The event data received from Monday.com.\n\n        Returns:\n            Response object if challenge is present, otherwise None.\n        \"\"\"\n        challenge = event.get('challenge')\n        if challenge:\n            return (jsonify({'challenge': challenge}), 200)\n        return None"
                    },
                    {
                        "name": "process_po_status_change",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Process purchase order (PO) status change events from Monday.com.\n\nArgs:\n    event_data (dict): The event data containing PO status change information.\n\nReturns:\n    JSON response indicating success or error.",
                        "function_body": "    def process_po_status_change(self, event_data):\n        \"\"\"\n        Process purchase order (PO) status change events from Monday.com.\n\n        Args:\n            event_data (dict): The event data containing PO status change information.\n\n        Returns:\n            JSON response indicating success or error.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "process_sub_item_change",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_item_by_ID",
                            "update_db_with_sub_item_change",
                            "get_purchase_order_surrogate_id_by_pulse_id",
                            "create_or_update_main_item_in_db",
                            "create_or_update_sub_item_in_db"
                        ],
                        "docstring": "Process SubItem change events from Monday.com and update the local DetailItem table.\n\nArgs:\n    event_data (dict): The event data containing SubItem change information.\n\nReturns:\n    JSON response indicating success or error.",
                        "function_body": "    def process_sub_item_change(self, event_data):\n        \"\"\"\n        Process SubItem change events from Monday.com and update the local DetailItem table.\n\n        Args:\n            event_data (dict): The event data containing SubItem change information.\n\n        Returns:\n            JSON response indicating success or error.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "process_sub_item_delete",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "delete_detail_item_in_db"
                        ],
                        "docstring": "Process SubItem deletion events from Monday.com and remove the item from the local database.\n\nArgs:\n    event_data (dict): The event data containing SubItem deletion information.\n\nReturns:\n    JSON response indicating success or error.",
                        "function_body": "    def process_sub_item_delete(self, event_data):\n        \"\"\"\n        Process SubItem deletion events from Monday.com and remove the item from the local database.\n\n        Args:\n            event_data (dict): The event data containing SubItem deletion information.\n\n        Returns:\n            JSON response indicating success or error.\n        \"\"\"\n        return (jsonify({'message': 'SubItem deleted successfully'}), 200)\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_blueprint",
                "value": "Blueprint('files_monday', __name__)"
            },
            {
                "name": "monday_webhook_handler",
                "value": "MondayWebhookHandler()"
            },
            {
                "name": "logger",
                "value": "logging.getLogger('monday_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/webhook_main.py",
        "functions": [
            {
                "name": "account_tax_view",
                "args": [],
                "decorators": [
                    "webhook_main_bp.route('/account_tax_view')"
                ],
                "calls": [],
                "docstring": "Shows an Excel-like table to edit accountCodes + TaxAccounts together.\nAccepts optional ?sort=account_code or ?sort=tax_code",
                "function_body": "def account_tax_view():\n    \"\"\"\n    Shows an Excel-like table to edit accountCodes + TaxAccounts together.\n    Accepts optional ?sort=account_code or ?sort=tax_code\n    \"\"\"\n    logger.debug(\"\ud83c\udff7 [ /account_tax_view ] - Handling GET request.\")\n    sort = request.args.get('sort')\n    logger.debug(f\"\ud83d\udce5 [ /account_tax_view ] - Received sort parameter: {sort}\")\n    records = db_view_util.get_all_account_with_tax(sort_by=sort)\n    logger.debug(\"\ud83d\udcc3 [ /account_tax_view ] - Retrieved records from db_view_util.\")\n#    logger.info(f\"\u2705 [ /account_tax_view ] - Rendering map_codes_view.html with {len(records)} record(s).\")\n    return render_template('map_codes_view.html', records=records, sort=sort)"
            },
            {
                "name": "bulk_update_account_tax",
                "args": [],
                "decorators": [
                    "webhook_main_bp.route('/bulk_update_account_tax')"
                ],
                "calls": [
                    "bulk_update_account_tax"
                ],
                "docstring": "Accepts JSON data from the front-end with a list of updated rows.\nCalls the new method in AccountTaxModel to commit changes to DB.",
                "function_body": "def bulk_update_account_tax():\n    \"\"\"\n    Accepts JSON data from the front-end with a list of updated rows.\n    Calls the new method in AccountTaxModel to commit changes to DB.\n    \"\"\"\n    logger.debug(\"\ud83d\udce8 [ /bulk_update_account_tax ] - Handling POST request for bulk update.\")\n    data = request.get_json()\n    logger.debug(f\"\ud83d\udce5 [ /bulk_update_account_tax ] - Data received: {data}\")\n    if not data or not isinstance(data, list):\n        logger.warning(\"\u26a0\ufe0f [ /bulk_update_account_tax ] - Invalid input data.\")\n        return jsonify({'status': 'error', 'message': 'Invalid input data'}), 400\n    try:"
            },
            {
                "name": "index",
                "args": [],
                "decorators": [
                    "webhook_main_bp.route('/health')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def index():\n    logger.debug(\"\ud83d\udd0e [ /health ] - Health check requested.\")\n    logger.info(\"\ud83d\udc9a [ /health ] - Returning status: Webhook listener is running.\")\n    return jsonify({'message': 'Webhook listener is running.'}), 200"
            },
            {
                "name": "po_html",
                "args": [
                    "project_ID"
                ],
                "decorators": [
                    "webhook_main_bp.route('/po_html/<string:project_ID>')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def po_html(project_ID):\n    logger.debug(f\"\ud83d\udd0e [ /po_html/{project_ID} ] - Handling GET request.\")\n    logger.info(f\"\ud83d\udcdd [ /po_html ] - Project ID requested: {project_ID}\")\n    result = po_log_database_util.fetch_po_by_id(project_ID)\n    json_result = result.get_json()\n    logger.debug(\"\u2705 [ /po_html ] - Result converted to JSON successfully. Rendering template.\")\n    return render_template('po_template.html', data=json_result)"
            },
            {
                "name": "control_panel",
                "args": [],
                "decorators": [
                    "webhook_main_bp.route('/control_panel')"
                ],
                "calls": [],
                "docstring": "Renders the Control Panel HTML page.",
                "function_body": "def control_panel():\n    \"\"\"\n    Renders the Control Panel HTML page.\n    \"\"\"\n    logger.debug(\"\ud83c\udfd7 [ /control_panel ] - Handling GET to render Control Panel page.\")\n    logger.info(\"\u2705 [ /control_panel ] - Rendering control_panel.html.\")\n    return render_template('control_panel.html')"
            },
            {
                "name": "map_codes_view",
                "args": [],
                "decorators": [
                    "webhook_main_bp.route('/map_codes_view')"
                ],
                "calls": [],
                "docstring": "Renders a template with tabs for each map_code,\neach containing the two-panel (Account left / Tax right) layout,\nlocal storage logic, pagination, etc.",
                "function_body": "def map_codes_view():\n    \"\"\"\n    Renders a template with tabs for each map_code,\n    each containing the two-panel (Account left / Tax right) layout,\n    local storage logic, pagination, etc.\n    \"\"\"\n    logger.debug(\"\ud83c\udfd7 [ /map_codes_view ] - Handling GET request.\")\n    logger.info(\"\u2705 [ /map_codes_view ] - Rendering map_codes_view.html.\")\n    return render_template('map_codes_view.html')"
            },
            {
                "name": "dev_proxy",
                "args": [
                    "subpath"
                ],
                "decorators": [
                    "webhook_main_bp.route('/dev/<path:subpath>')"
                ],
                "calls": [],
                "docstring": "Forwards any request under /dev/... to the dev server on port 5003.\nIf the dev server is offline, returns a 200 with a JSON indicating offline status.",
                "function_body": "def dev_proxy(subpath):\n    \"\"\"\n    Forwards any request under /dev/... to the dev server on port 5003.\n    If the dev server is offline, returns a 200 with a JSON indicating offline status.\n    \"\"\"\n    logger.debug(f\"\ud83d\udd0e [ /dev/{subpath} ] - Handling {request.method} request.\")\n    logger.info(f\"\u27a1\ufe0f [ /dev ] - Attempting to proxy request to /dev/{subpath}\")\n    dev_url = f\"http://localhost:{config.WEBHOOK_MAIN_PORT_DEBUG}/{subpath}\"\n    logger.debug(f\"\ud83d\udd27 [ /dev ] - Constructed dev server URL: {dev_url}\")\n\n    try:"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            },
            {
                "name": "webhook_main_bp",
                "value": "Blueprint('webhook_main_bp', __name__)"
            },
            {
                "name": "config",
                "value": "Config()"
            },
            {
                "name": "db_view_util",
                "value": "AccountTaxModel()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/__init__.py",
        "functions": [
            {
                "name": "create_app",
                "args": [],
                "decorators": [],
                "calls": [
                    "setup_web_logger"
                ],
                "docstring": "Application factory that creates and configures the Flask app.",
                "function_body": "def create_app():\n    \"\"\"Application factory that creates and configures the Flask app.\"\"\"\n\n    logger.info(\"\ud83d\udd25 Creating the Flask application instance...\")\n    app = Flask(__name__)\n\n    # 1. Load/Use the custom config\n    config = Config()\n    app.debug = config.APP_DEBUG\n    app.config['TEMPLATES_AUTO_RELOAD'] = True\n    logger.info(f\"\ud83d\udc22 Set Flask debug={config.APP_DEBUG}, TEMPLATES_AUTO_RELOAD=True\")\n\n    # 2. Setup web logger\n    setup_web_logger(app, console_handler, formatter)\n    logger.info(\"\ud83d\udd27 Web logger set up with console_handler & formatter\")\n\n    # 3. Register Blueprints\n    logger.info(\"\ud83d\udce6 Registering Blueprints from server_webhook.webhook_main...\")\n    from server_webhook.webhook_main import webhook_main_bp\n    app.register_blueprint(webhook_main_bp)\n    logger.info(\"\ud83c\udf89 webhook_main_bp registered successfully!\")\n\n    # If you have additional blueprint imports, register them similarly:\n    # from files_monday.monday_webhook_handler import monday_blueprint\n    # app.register_blueprint(monday_blueprint, url_prefix='/webhook/monday')\n    # logger.info(\"\ud83d\udce6 Registered monday_blueprint at '/webhook/monday'\")\n\n    logger.info(\"\u2705 All set. Returning the Flask 'app' instance now.\")\n    return app"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/orchestrator.py",
        "functions": [],
        "classes": [
            {
                "name": "Orchestrator",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.config = Config()\n        self.monday_service = monday_service\n        self.ocr_service = OCRService()\n        self.xero_api = xero_api\n        self.logger = logging.getLogger('admin_logger')\n        self.xero_services = xero_services"
                    },
                    {
                        "name": "start_background_tasks",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "populate_xero_contacts"
                        ],
                        "docstring": null,
                        "function_body": "    def start_background_tasks(self):\n        self.logger.info('[start_background_tasks] - Starting background tasks...')\n        current_dir = os.getcwd()\n        self.logger.info(f'[start_background_tasks] - Current working directory: {current_dir}')\n        self.xero_services.populate_xero_contacts()"
                    },
                    {
                        "name": "sync_monday_main_items",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "sync_main_items_from_monday_board"
                        ],
                        "docstring": "Fetch Main Item entries from Monday.com and handle them immediately (one-time run).",
                        "function_body": "    def sync_monday_main_items(self):\n        \"\"\"\n        Fetch Main Item entries from Monday.com and handle them immediately (one-time run).\n        \"\"\"\n        self.logger.info('[sync_monday_main_items] - Fetching Main Item entries')\n        try:"
                    },
                    {
                        "name": "sync_monday_sub_items",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "sync_sub_items_from_monday_board"
                        ],
                        "docstring": "Fetch Sub Item entries from Monday.com and handle them immediately (one-time run).",
                        "function_body": "    def sync_monday_sub_items(self):\n        \"\"\"\n        Fetch Sub Item entries from Monday.com and handle them immediately (one-time run).\n        \"\"\"\n        self.logger.info('[sync_monday_sub_items] - Fetching Sub Item entries')\n        try:"
                    },
                    {
                        "name": "sync_monday_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "sync_contacts_from_monday_board"
                        ],
                        "docstring": "Fetch contact entries from Monday.com and handle them immediately (one-time run).",
                        "function_body": "    def sync_monday_contacts(self):\n        \"\"\"\n        Fetch contact entries from Monday.com and handle them immediately (one-time run).\n        \"\"\"\n        self.logger.info('[sync_monday_contacts] - Fetching Contact entries')\n        try:"
                    },
                    {
                        "name": "sync_spend_money_items",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "load_spend_money_transactions"
                        ],
                        "docstring": "Retrieve spend money transactions from Xero for a single run.",
                        "function_body": "    def sync_spend_money_items(self):\n        \"\"\"\n        Retrieve spend money transactions from Xero for a single run.\n        \"\"\"\n        self.logger.info('[sync_spend_money_items] - Syncing spend money transactions...')\n        result = self.xero_services.load_spend_money_transactions(project_id='2416')\n        return result"
                    },
                    {
                        "name": "sync_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "populate_xero_contacts"
                        ],
                        "docstring": "Retrieve and populate Xero contacts in a single run.",
                        "function_body": "    def sync_contacts(self):\n        \"\"\"\n        Retrieve and populate Xero contacts in a single run.\n        \"\"\"\n        self.logger.info('[sync_contacts] - Syncing Xero contacts...')\n        result = self.xero_services.populate_xero_contacts()\n        return result"
                    },
                    {
                        "name": "sync_xero_bills",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieve Xero bills in a single run.",
                        "function_body": "    def sync_xero_bills(self):\n        \"\"\"\n        Retrieve Xero bills in a single run.\n        \"\"\"\n        self.logger.info('[sync_xero_bills] - Syncing Xero bills...')\n        result = self.xero_services.load_bills('2416')\n        return result"
                    },
                    {
                        "name": "scan_project_receipts",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "scan_project_receipts"
                        ],
                        "docstring": "Calls the dropbox_service to scan a specific project folder for receipts\nand process each receipt into the database.",
                        "function_body": "    def scan_project_receipts(self, project_number: str):\n        \"\"\"\n        Calls the dropbox_service to scan a specific project folder for receipts\n        and process each receipt into the database.\n        \"\"\"\n        self.logger.info(f'[scan_project_receipts] - \ud83d\udcc2 Orchestrator: scanning receipts for project {project_number}.')\n        from files_dropbox.dropbox_service import DropboxService\n        dropbox_service = DropboxService()\n        dropbox_service.scan_project_receipts(project_number)"
                    },
                    {
                        "name": "scan_project_invoices",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Calls the dropbox_service to scan a specific project folder for invoices\nand process each invoice into the database.",
                        "function_body": "    def scan_project_invoices(self, project_number: str):\n        \"\"\"\n        Calls the dropbox_service to scan a specific project folder for invoices\n        and process each invoice into the database.\n        \"\"\"\n        self.logger.info(f'[scan_project_invoices] - \ud83d\udcc2 Orchestrator: scanning invoice for project {project_number}.')"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "orchestrator",
                "value": "Orchestrator()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/main.py",
        "functions": [
            {
                "name": "run_flask_app",
                "args": [
                    "app"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Function to run the Flask app in a blocking manner (serve_forever).",
                "function_body": "def run_flask_app(app):\n    \"\"\"\n    Function to run the Flask app in a blocking manner (serve_forever).\n    \"\"\"\n    config = Config()\n    chosen_port = config.get_running_port()\n    logger.info(f\"\ud83d\ude80 Starting Flask server on port {chosen_port}...\")\n\n    server = make_server('0.0.0.0', chosen_port, app)\n    logger.info(f\"\ud83c\udf10 Server listening at 0.0.0.0:{chosen_port}. Serving forever...\")\n\n    try:"
            },
            {
                "name": "main",
                "args": [],
                "decorators": [],
                "calls": [
                    "initialize_database",
                    "create_app"
                ],
                "docstring": null,
                "function_body": "def main():\n    logger.info(\"\ud83d\udd11 Starting the application...\")\n\n    # 1. Initialize the database\n    config = Config()\n    db_settings = config.get_database_settings(config.USE_LOCAL)\n    logger.info(f\"\ud83d\udcbe Initializing the database with URL: {db_settings['url']}\")\n    initialize_database(db_settings['url'])\n    logger.info(\"\u2705 Database initialized successfully.\")\n\n    # 2. Create the Flask app via the factory\n    app = create_app()\n\n    # 3. Start the Flask server in a new thread\n    flask_thread = threading.Thread(target=run_flask_app, args=(app,))\n    flask_thread.start()\n    logger.info(\"\ud83c\udfc3 Flask server thread started. Main thread will remain active.\")\n\n    # 4. Keep the main thread alive\n    try:"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/logging_setup.py",
        "functions": [
            {
                "name": "setup_logging",
                "args": [],
                "decorators": [],
                "calls": [],
                "docstring": "Configure all module-specific loggers (admin, budget, dropbox, invoice, etc.)\nEXCEPT for the Flask `web_logger`. We'll do that in `setup_web_logger()`.",
                "function_body": "def setup_logging():\n    \"\"\"\n    Configure all module-specific loggers (admin, budget, dropbox, invoice, etc.)\n    EXCEPT for the Flask `web_logger`. We'll do that in `setup_web_logger()`.\n    \"\"\"\n    os.makedirs('./logs', exist_ok=True)\n    basepath = './server_webhook/logs/'\n\n    # Prepare our custom formatter\n    formatter = PaddedFormatter(\n        fmt=\"%(asctime)s [%(levelname)s] [%(filename)s] [%(funcName)s] %(message)s\",\n        datefmt=\"%M:%S\"\n    )\n\n    # A console handler to display logs to stdout\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n\n    # --------------------------------------------------------------------------\n    # Admin logger\n    # --------------------------------------------------------------------------\n    admin_logger = logging.getLogger('admin_logger')\n    admin_logger.setLevel(logging.DEBUG)\n    file_handler_admin = logging.FileHandler(os.path.join(basepath, 'admin.log'))\n    file_handler_admin.setFormatter(formatter)\n    admin_logger.addHandler(file_handler_admin)\n    admin_logger.addHandler(console_handler)\n    admin_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Budget logger\n    # --------------------------------------------------------------------------\n    budget_logger = logging.getLogger('budget_logger')\n    budget_logger.setLevel(logging.DEBUG)\n    file_handler_budget = logging.FileHandler(os.path.join(basepath, 'budget.log'))\n    file_handler_budget.setFormatter(formatter)\n    budget_logger.addHandler(file_handler_budget)\n    budget_logger.addHandler(console_handler)\n    budget_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Dropbox logger (SDK logs)\n    # --------------------------------------------------------------------------\n    dropbox_logger = logging.getLogger('dropbox')\n    dropbox_logger.setLevel(logging.DEBUG)\n    file_handler_dropbox = logging.FileHandler(os.path.join(basepath, 'dropbox.log'))\n    file_handler_dropbox.setFormatter(formatter)\n    dropbox_logger.addHandler(file_handler_dropbox)\n    dropbox_logger.addHandler(console_handler)\n    dropbox_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Invoice logger\n    # --------------------------------------------------------------------------\n    invoice_logger = logging.getLogger('invoice_logger')\n    invoice_logger.setLevel(logging.DEBUG)\n    file_handler_invoice = logging.FileHandler(os.path.join(basepath, 'invoice.log'))\n    file_handler_invoice.setFormatter(formatter)\n    invoice_logger.addHandler(file_handler_invoice)\n    invoice_logger.addHandler(console_handler)\n    invoice_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Monday logger\n    # --------------------------------------------------------------------------\n    monday_logger = logging.getLogger('monday_logger')\n    monday_logger.setLevel(logging.DEBUG)\n    file_handler_monday = logging.FileHandler(os.path.join(basepath, 'monday.log'))\n    file_handler_monday.setFormatter(formatter)\n    monday_logger.addHandler(file_handler_monday)\n    monday_logger.addHandler(console_handler)\n    monday_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # PO logger\n    # --------------------------------------------------------------------------\n    po_log_logger = logging.getLogger('po_log_logger')\n    po_log_logger.setLevel(logging.DEBUG)\n    file_handler_po = logging.FileHandler(os.path.join(basepath, 'po_log.log'))\n    file_handler_po.setFormatter(formatter)\n    po_log_logger.addHandler(file_handler_po)\n    po_log_logger.addHandler(console_handler)\n    po_log_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Xero logger\n    # --------------------------------------------------------------------------\n    xero_logger = logging.getLogger('xero_logger')\n    xero_logger.setLevel(logging.DEBUG)\n    file_handler_xero = logging.FileHandler(os.path.join(basepath, 'xero.log'))\n    file_handler_xero.setFormatter(formatter)\n    xero_logger.addHandler(file_handler_xero)\n    xero_logger.addHandler(console_handler)\n    xero_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Database logger\n    # --------------------------------------------------------------------------\n    db_logger = logging.getLogger('database_logger')\n    db_logger.setLevel(logging.DEBUG)\n    file_handler_db = logging.FileHandler(os.path.join(basepath, 'database.log'))\n    file_handler_db.setFormatter(formatter)\n    db_logger.addHandler(file_handler_db)\n    db_logger.addHandler(console_handler)\n    db_logger.propagate = False\n\n    # --------------------------------------------------------------------------\n    # Basic config to ensure at least INFO messages are displayed for the root\n    # This can help in capturing library logs that propagate to the root logger\n    # (though we've turned off propagate for our main named loggers above).\n    # --------------------------------------------------------------------------\n    logging.basicConfig(level=logging.INFO)\n\n    # Return console_handler (or any other handler) for potential reuse\n    return console_handler, formatter"
            },
            {
                "name": "setup_web_logger",
                "args": [
                    "flask_app",
                    "console_handler",
                    "formatter"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Set up a 'web_logger' dedicated to Flask logs.\nThen attach these handlers to flask_app.logger, removing any defaults.",
                "function_body": "def setup_web_logger(flask_app, console_handler, formatter):\n    \"\"\"\n    Set up a 'web_logger' dedicated to Flask logs.\n    Then attach these handlers to flask_app.logger, removing any defaults.\n    \"\"\"\n    basepath = './server_webhook/logs/'\n    web_logger = logging.getLogger('web_logger')\n    web_logger.setLevel(logging.DEBUG)\n\n    # Create a file handler specifically for web logs\n    file_handler_web = logging.FileHandler(os.path.join(basepath, 'web.log'))\n    file_handler_web.setFormatter(formatter)\n\n    web_logger.addHandler(file_handler_web)\n    web_logger.addHandler(console_handler)\n    web_logger.propagate = False\n\n    # Attach Flask's logger to our 'web_logger' handlers\n    flask_app.logger.handlers = []\n    flask_app.logger.addHandler(file_handler_web)\n    flask_app.logger.addHandler(console_handler)\n    flask_app.logger.setLevel(logging.DEBUG)"
            }
        ],
        "classes": [
            {
                "name": "PaddedFormatter",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self",
                            "fmt",
                            "datefmt",
                            "max_length"
                        ],
                        "decorators": [],
                        "calls": [
                            "__init__"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self, fmt=None, datefmt=None, max_length=80):\n        super().__init__(fmt, datefmt)\n        self.max_length = max_length\n        self.COLUMN_WIDTHS = {"
                    },
                    {
                        "name": "pad_center",
                        "args": [
                            "self",
                            "text",
                            "width"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Pad text to the specified width, centering it.",
                        "function_body": "    def pad_center(self, text, width):\n        \"\"\"Pad text to the specified width, centering it.\"\"\"\n        text = text[:width] if len(text) > width else text  # Truncate if too long\n        return f\"{text:^{width}}\""
                    },
                    {
                        "name": "pad_left",
                        "args": [
                            "self",
                            "text",
                            "width"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Pad text to the specified width, aligning it to the left.",
                        "function_body": "    def pad_left(self, text, width):\n        \"\"\"Pad text to the specified width, aligning it to the left.\"\"\"\n        text = text[:width] if len(text) > width else text  # Truncate if too long\n        return f\"{text:<{width}}\""
                    },
                    {
                        "name": "format",
                        "args": [
                            "self",
                            "record"
                        ],
                        "decorators": [],
                        "calls": [
                            "pad_center",
                            "formatTime",
                            "pad_left",
                            "format"
                        ],
                        "docstring": null,
                        "function_body": "    def format(self, record):\n        # Map log levels to their corresponding icons\n        level_icons = {\n            \"ERROR\": \"\ud83c\udf15\",\n            \"WARNING\": \"\ud83c\udf17\",\n            \"INFO\": \"\ud83c\udf11\",\n            \"DEBUG\": \"\ud83c\udf12\",\n        }\n        icon = level_icons.get(record.levelname, \" \")\n        record.levelname = f\"{icon}{record.levelname}\"\n\n        # Center-align and pad each field dynamically\n        record.asctime  = self.pad_center(self.formatTime(record), self.COLUMN_WIDTHS[\"time\"])\n        record.levelname= self.pad_center(record.levelname,    self.COLUMN_WIDTHS[\"levelname\"])\n        record.filename = self.pad_left(record.filename,       self.COLUMN_WIDTHS[\"filename\"])\n        record.funcName = self.pad_left(record.funcName,       self.COLUMN_WIDTHS[\"funcName\"])\n\n        # Truncate message if necessary\n        if len(record.msg) > self.max_length:\n            record.msg = record.msg[:self.max_length] + \"...\"\n        return super().format(record)"
                    },
                    {
                        "name": "formatTime",
                        "args": [
                            "self",
                            "record",
                            "datefmt"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def formatTime(self, record, datefmt=None):\n        ct = datetime.fromtimestamp(record.created)\n        if datefmt:\n            result = f\"[{ ct.strftime(datefmt)}]-[{int(record.msecs):03d}]\"\n        else:\n            result = f\"[{ct.strftime('%M:%S')}].[{int(record.msecs):03d}]\"\n        # We pad in the calling method so everything lines up\n        return result"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/celery_server.py",
        "functions": [
            {
                "name": "announce_tasks",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "celery_app.on_after_finalize.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def announce_tasks(sender, **kwargs):\n    logger.info('Celery tasks have been finalized. Ready to go!')"
            },
            {
                "name": "init_db",
                "args": [],
                "decorators": [
                    "worker_init.connect"
                ],
                "calls": [
                    "initialize_database"
                ],
                "docstring": null,
                "function_body": "def init_db(**kwargs):\n    logger.info('Initializing Local DB session inside Celery worker...')\n\n    config = Config()\n    db_settings = config.get_database_settings(config.USE_LOCAL)\n\n    try:"
            },
            {
                "name": "signal_worker_init",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "worker_init.connect"
                ],
                "calls": [],
                "docstring": "Runs at worker initialization. We also purge any leftover tasks\nso the queue is empty when we start accepting new tasks.",
                "function_body": "def signal_worker_init(sender=None, **kwargs):\n    \"\"\"\n    Runs at worker initialization. We also purge any leftover tasks\n    so the queue is empty when we start accepting new tasks.\n    \"\"\"\n    logger.info('\ud83d\udc77\\u200d\u2640\ufe0f Celery Worker is starting up... Warm up the engines!')\n    try:"
            },
            {
                "name": "signal_worker_ready",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "worker_ready.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def signal_worker_ready(sender=None, **kwargs):\n    logger.info('\ud83d\ude80 Celery Worker is READY and waiting for tasks! Buckle up, folks.')"
            },
            {
                "name": "signal_worker_shutdown",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "worker_shutdown.connect"
                ],
                "calls": [],
                "docstring": "Runs just before the Celery worker fully shuts down.\nWe revoke any active tasks (forcing them to stop) and then purge\nany remaining messages in the queue.",
                "function_body": "def signal_worker_shutdown(sender=None, **kwargs):\n    \"\"\"\n    Runs just before the Celery worker fully shuts down.\n    We revoke any active tasks (forcing them to stop) and then purge\n    any remaining messages in the queue.\n    \"\"\"\n    logger.warning('\ud83d\uded1 Celery Worker is shutting down. Everyone, please exit in an orderly fashion.')\n\n    try:"
            }
        ],
        "classes": [
            {
                "name": "DBRetryTask",
                "methods": [],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            },
            {
                "name": "celery_app",
                "value": "Celery('celery_app', broker='redis://localhost:6379/5', backend='redis://localhost:6379/5')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/celery_task_router.py",
        "functions": [],
        "classes": [
            {
                "name": "CeleryTaskService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        pass"
                    },
                    {
                        "name": "po_log_trigger_on_create",
                        "args": [
                            "self",
                            "po_log_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def po_log_trigger_on_create(self, po_log_id: int):\n        return handle_po_log_create(po_log_id=po_log_id)"
                    },
                    {
                        "name": "xero_bill_line_item_trigger_on_create",
                        "args": [
                            "self",
                            "xero_bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def xero_bill_line_item_trigger_on_create(self, xero_bill_line_item_id: int):\n        return handle_xero_xero_bill_line_item_create(xero_bill_line_item_id)"
                    },
                    {
                        "name": "xero_bill_line_item_trigger_on_update",
                        "args": [
                            "self",
                            "xero_bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def xero_bill_line_item_trigger_on_update(self, xero_bill_line_item_id: int):\n        return handle_xero_xero_bill_line_item_update(xero_bill_line_item_id)"
                    },
                    {
                        "name": "xero_bill_line_item_trigger_on_delete",
                        "args": [
                            "self",
                            "xero_bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def xero_bill_line_item_trigger_on_delete(self, xero_bill_line_item_id: int):\n        return handle_xero_xero_bill_line_item_delete(xero_bill_line_item_id)"
                    },
                    {
                        "name": "spend_money_trigger_on_create",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "handle_spend_money_create"
                        ],
                        "docstring": null,
                        "function_body": "    def spend_money_trigger_on_create(self, spend_money_id: int):\n        return handle_spend_money_create(spend_money_id)"
                    },
                    {
                        "name": "spend_money_trigger_on_update",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "handle_spend_money_update"
                        ],
                        "docstring": null,
                        "function_body": "    def spend_money_trigger_on_update(self, spend_money_id: int):\n        return handle_spend_money_update(spend_money_id)"
                    },
                    {
                        "name": "spend_money_trigger_on_delete",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def spend_money_trigger_on_delete(self, spend_money_id: int):\n        return handle_spend_money_delete(spend_money_id)"
                    },
                    {
                        "name": "create_xero_bill_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def create_xero_bill_trigger(self, bill_id: int):\n        return handle_xero_bill_create(bill_id)"
                    },
                    {
                        "name": "update_xero_bill_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def update_xero_bill_trigger(self, bill_id: int):\n        return handle_xero_bill_update(bill_id)"
                    },
                    {
                        "name": "delete_xero_bill_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def delete_xero_bill_trigger(self, bill_id: int):\n        return handle_xero_bill_delete(bill_id)"
                    },
                    {
                        "name": "create_xero_xero_bill_line_items_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def create_xero_xero_bill_line_items_trigger(self, bill_id: int):\n        return handle_xero_xero_bill_line_item_create(bill_id)"
                    },
                    {
                        "name": "update_xero_xero_bill_line_item_trigger",
                        "args": [
                            "self",
                            "line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def update_xero_xero_bill_line_item_trigger(self, line_item_id: int):\n        return handle_xero_xero_bill_line_item_update(line_item_id)"
                    },
                    {
                        "name": "delete_xero_xero_bill_line_item_trigger",
                        "args": [
                            "self",
                            "line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def delete_xero_xero_bill_line_item_trigger(self, line_item_id: int):\n        return handle_xero_xero_bill_line_item_delete(line_item_id)"
                    },
                    {
                        "name": "project_trigger_on_create",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def project_trigger_on_create(self, project_id: int):\n        return handle_project_create(project_id)"
                    },
                    {
                        "name": "project_trigger_on_update",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def project_trigger_on_update(self, project_id: int):\n        return handle_project_update(project_id)"
                    },
                    {
                        "name": "project_trigger_on_delete",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def project_trigger_on_delete(self, project_id: int):\n        return handle_project_delete(project_id)"
                    },
                    {
                        "name": "purchase_order_trigger_on_create",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def purchase_order_trigger_on_create(self, po_id: int):\n        return handle_purchase_order_create(po_id)"
                    },
                    {
                        "name": "purchase_order_trigger_on_update",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def purchase_order_trigger_on_update(self, po_id: int):\n        return handle_purchase_order_update(po_id)"
                    },
                    {
                        "name": "purchase_order_trigger_on_delete",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def purchase_order_trigger_on_delete(self, po_id: int):\n        return handle_purchase_order_delete(po_id)"
                    },
                    {
                        "name": "detail_item_trigger_on_create",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def detail_item_trigger_on_create(self, detail_item_id: int):\n        return handle_detail_item_create(detail_item_id)"
                    },
                    {
                        "name": "detail_item_trigger_on_update",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def detail_item_trigger_on_update(self, detail_item_id: int):\n        return handle_detail_item_update(detail_item_id)"
                    },
                    {
                        "name": "detail_item_on_delete",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def detail_item_on_delete(self, detail_item_id: int):\n        return handle_detail_item_delete(detail_item_id)"
                    },
                    {
                        "name": "invoice_trigger_on_create_or_update",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def invoice_trigger_on_create_or_update(self, invoice_id: int):\n        return handle_invoice_create_or_update(invoice_id)"
                    },
                    {
                        "name": "invoice_trigger_on_delete",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def invoice_trigger_on_delete(self, invoice_id: int):\n        return handle_invoice_delete(invoice_id)"
                    },
                    {
                        "name": "receipt_trigger_on_create",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def receipt_trigger_on_create(self, receipt_id: int):\n        return handle_receipt_create(receipt_id)"
                    },
                    {
                        "name": "receipt_trigger_on_update",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def receipt_trigger_on_update(self, receipt_id: int):\n        return handle_receipt_update(receipt_id)"
                    },
                    {
                        "name": "receipt_trigger_on_delete",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def receipt_trigger_on_delete(self, receipt_id: int):\n        return handle_receipt_delete(receipt_id)"
                    },
                    {
                        "name": "contact_trigger_on_create",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def contact_trigger_on_create(self, contact_id: int):\n        return handle_contact_create(contact_id)"
                    },
                    {
                        "name": "contact_trigger_on_update",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def contact_trigger_on_update(self, contact_id: int):\n        return handle_contact_update(contact_id)"
                    },
                    {
                        "name": "contact_trigger_on_delete",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def contact_trigger_on_delete(self, contact_id: int):\n        return handle_contact_delete(contact_id)"
                    },
                    {
                        "name": "tax_account_trigger_on_create",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def tax_account_trigger_on_create(self, tax_account_id: int):\n        return handle_tax_account_create(tax_account_id)"
                    },
                    {
                        "name": "tax_account_trigger_on_update",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def tax_account_trigger_on_update(self, tax_account_id: int):\n        return handle_tax_account_update(tax_account_id)"
                    },
                    {
                        "name": "tax_account_trigger_on_delete",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def tax_account_trigger_on_delete(self, tax_account_id: int):\n        return handle_tax_account_delete(tax_account_id)"
                    },
                    {
                        "name": "account_code_trigger_on_create",
                        "args": [
                            "self",
                            "account_code_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def account_code_trigger_on_create(self, account_code_id: int):\n        return handle_account_code_create(account_code_id)"
                    },
                    {
                        "name": "account_code_trigger_on_update",
                        "args": [
                            "self",
                            "account_code_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def account_code_trigger_on_update(self, account_code_id: int):\n        return handle_account_code_update(account_code_id)"
                    },
                    {
                        "name": "account_code_trigger_on_delete",
                        "args": [
                            "self",
                            "account_code_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def account_code_trigger_on_delete(self, account_code_id: int):\n        return handle_account_code_delete(account_code_id)"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "celery_task_service",
                "value": "CeleryTaskService()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/celery_tasks.py",
        "functions": [
            {
                "name": "process_invoice_trigger",
                "args": [
                    "invoice_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "invoice_trigger_on_create_or_update"
                ],
                "docstring": "The Celery task for handling invoice creates/updates.",
                "function_body": "def process_invoice_trigger(invoice_id: int):\n    \"\"\"\n    The Celery task for handling invoice creates/updates.\n    \"\"\"\n    logger = logging.getLogger('invoice_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_invoice_trigger shared task. invoice_id={invoice_id}.')\n    try:"
            },
            {
                "name": "process_invoice_delete",
                "args": [
                    "invoice_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "invoice_trigger_on_delete"
                ],
                "docstring": "The Celery task for handling invoice deletes.",
                "function_body": "def process_invoice_delete(invoice_id: int):\n    \"\"\"\n    The Celery task for handling invoice deletes.\n    \"\"\"\n    logger = logging.getLogger('invoice_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling invoice deletion for invoice_id={invoice_id}.')\n    try:"
            },
            {
                "name": "process_detail_item_update",
                "args": [
                    "detail_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "detail_item_trigger_on_update"
                ],
                "docstring": "The Celery task for detail items that just turned RTP (or updated).",
                "function_body": "def process_detail_item_update(detail_item_id: int):\n    \"\"\"\n    The Celery task for detail items that just turned RTP (or updated).\n    \"\"\"\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83c\udf00 Handling updated detail item for detail_item_id={detail_item_id}')\n    try:"
            },
            {
                "name": "process_detail_item_create",
                "args": [
                    "detail_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "detail_item_trigger_on_create"
                ],
                "docstring": "The Celery task for newly created detail items.",
                "function_body": "def process_detail_item_create(detail_item_id: int):\n    \"\"\"\n    The Celery task for newly created detail items.\n    \"\"\"\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83c\udf00 Handling created detail item for detail_item_id={detail_item_id}')\n    try:"
            },
            {
                "name": "process_detail_item_delete",
                "args": [
                    "detail_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "detail_item_on_delete"
                ],
                "docstring": "    The Celery task for dele\n        logger = logging.getLogger('budget_logger')\nted detail items.\n    ",
                "function_body": "def process_detail_item_delete(detail_item_id: int):\n    \"\"\"\n    The Celery task for dele\n        logger = logging.getLogger('budget_logger')\nted detail items.\n    \"\"\"\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted detail item for detail_item_id={detail_item_id}')\n    try:"
            },
            {
                "name": "process_purchase_order_create",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "purchase_order_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_purchase_order_create(po_id: int):\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_purchase_order_create shared task. po_id={po_id}.')\n    try:"
            },
            {
                "name": "process_purchase_order_update",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "purchase_order_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_purchase_order_update(po_id: int):\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated PurchaseOrder id={po_id}.')\n    try:"
            },
            {
                "name": "process_purchase_order_delete",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "purchase_order_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_purchase_order_delete(po_id: int):\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted PurchaseOrder id={po_id}.')\n    try:"
            },
            {
                "name": "process_contact_create",
                "args": [
                    "contact_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "contact_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_contact_create(contact_id: int):\n    logger = logging.getLogger('admin_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_contact_create shared task. contact_id={contact_id}.')\n    try:"
            },
            {
                "name": "process_contact_update",
                "args": [
                    "contact_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "contact_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_contact_update(contact_id: int):\n    logger = logging.getLogger('admin_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated Contact id={contact_id}.')\n    try:"
            },
            {
                "name": "process_contact_delete",
                "args": [
                    "contact_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "contact_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_contact_delete(contact_id: int):\n    logger = logging.getLogger('admin_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted Contact id={contact_id}.')\n    try:"
            },
            {
                "name": "process_xero_bill_line_item_create",
                "args": [
                    "xero_bill_line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "xero_bill_line_item_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_xero_bill_line_item_create(xero_bill_line_item_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_xero_bill_line_item_create shared task. xero_bill_line_item_id={xero_bill_line_item_id}.')\n    try:"
            },
            {
                "name": "process_xero_bill_line_item_update",
                "args": [
                    "xero_bill_line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "xero_bill_line_item_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_xero_bill_line_item_update(xero_bill_line_item_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated XeroBillLineItem id={xero_bill_line_item_id}.')\n    try:"
            },
            {
                "name": "process_xero_bill_line_item_delete",
                "args": [
                    "xero_bill_line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "xero_bill_line_item_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_xero_bill_line_item_delete(xero_bill_line_item_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted XeroBillLineItem id={xero_bill_line_item_id}.')\n    try:"
            },
            {
                "name": "process_bank_transaction_create",
                "args": [
                    "bank_tx_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def process_bank_transaction_create(bank_tx_id: int):\n    logger = logging.getLogger('admin_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_bank_transaction_create shared task. bank_tx_id={bank_tx_id}.')\n    try:"
            },
            {
                "name": "process_bank_transaction_update",
                "args": [
                    "bank_tx_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def process_bank_transaction_update(bank_tx_id: int):\n    logger = logging.getLogger('admin_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated BankTransaction id={bank_tx_id}.')\n    try:"
            },
            {
                "name": "process_bank_transaction_delete",
                "args": [
                    "bank_tx_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def process_bank_transaction_delete(bank_tx_id: int):\n    logger = logging.getLogger('admin_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted BankTransaction id={bank_tx_id}.')\n    try:"
            },
            {
                "name": "process_account_code_create",
                "args": [
                    "account_code_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "account_code_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_account_code_create(account_code_id: int):\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_account_code_create shared task. account_code_id={account_code_id}.')\n    try:"
            },
            {
                "name": "process_account_code_update",
                "args": [
                    "account_code_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "account_code_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_account_code_update(account_code_id: int):\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated AccountCode id={account_code_id}.')\n    try:"
            },
            {
                "name": "process_account_code_delete",
                "args": [
                    "account_code_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "account_code_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_account_code_delete(account_code_id: int):\n    logger = logging.getLogger('budget_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted AccountCode id={account_code_id}.')\n    try:"
            },
            {
                "name": "process_receipt_create",
                "args": [
                    "receipt_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "receipt_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_receipt_create(receipt_id: int):\n    logger = logging.getLogger('invoice_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_receipt_create shared task. receipt_id={receipt_id}.')\n    try:"
            },
            {
                "name": "process_receipt_update",
                "args": [
                    "receipt_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "receipt_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_receipt_update(receipt_id: int):\n    logger = logging.getLogger('invoice_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated Receipt id={receipt_id}.')\n    try:"
            },
            {
                "name": "process_receipt_delete",
                "args": [
                    "receipt_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "receipt_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_receipt_delete(receipt_id: int):\n    logger = logging.getLogger('invoice_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted Receipt id={receipt_id}.')\n    try:"
            },
            {
                "name": "process_spend_money_create",
                "args": [
                    "spend_money_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "spend_money_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_spend_money_create(spend_money_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_spend_money_create shared task. spend_money_id={spend_money_id}.')\n    try:"
            },
            {
                "name": "process_spend_money_update",
                "args": [
                    "spend_money_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "spend_money_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_spend_money_update(spend_money_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated SpendMoney id={spend_money_id}.')\n    try:"
            },
            {
                "name": "process_spend_money_delete",
                "args": [
                    "spend_money_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "spend_money_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_spend_money_delete(spend_money_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted SpendMoney id={spend_money_id}.')\n    try:"
            },
            {
                "name": "process_tax_account_create",
                "args": [
                    "tax_account_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "tax_account_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_tax_account_create(tax_account_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\ude80 Starting process_tax_account_create shared task. tax_account_id={tax_account_id}.')\n    try:"
            },
            {
                "name": "process_tax_account_update",
                "args": [
                    "tax_account_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "tax_account_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_tax_account_update(tax_account_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\udd04 Handling updated TaxAccount id={tax_account_id}.')\n    try:"
            },
            {
                "name": "process_tax_account_delete",
                "args": [
                    "tax_account_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "tax_account_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_tax_account_delete(tax_account_id: int):\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted TaxAccount id={tax_account_id}.')\n    try:"
            },
            {
                "name": "process_xero_bill_update",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "update_xero_bill_trigger"
                ],
                "docstring": "The Celery task for handling updated XeroBills.",
                "function_body": "def process_xero_bill_update(bill_id: int):\n    \"\"\"\n    The Celery task for handling updated XeroBills.\n    \"\"\"\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\ude80 Starting update_xero_bill shared task. bill_id={bill_id}.')\n    try:"
            },
            {
                "name": "process_xero_bill_create",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "create_xero_bill_trigger"
                ],
                "docstring": "The Celery task for handling newly created XeroBills.",
                "function_body": "def process_xero_bill_create(bill_id: str):\n    \"\"\"\n    The Celery task for handling newly created XeroBills.\n    \"\"\"\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83c\udf00 NEW TASK - CREATE - XERO BILL - STARTED \ud83c\udf00 {bill_id}.')\n    try:"
            },
            {
                "name": "create_xero_xero_bill_line_items",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "create_xero_xero_bill_line_items_trigger"
                ],
                "docstring": "The Celery task for handling newly inserted line items for a XeroBill.",
                "function_body": "def create_xero_xero_bill_line_items(bill_id: int):\n    \"\"\"\n    The Celery task for handling newly inserted line items for a XeroBill.\n    \"\"\"\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83c\udf00 Handling created line items for bill_id={bill_id}')\n    try:"
            },
            {
                "name": "update_xero_xero_bill_line_item",
                "args": [
                    "line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "update_xero_xero_bill_line_item_trigger"
                ],
                "docstring": "The Celery task for handling updated line items for a XeroBill.",
                "function_body": "def update_xero_xero_bill_line_item(line_item_id: int):\n    \"\"\"\n    The Celery task for handling updated line items for a XeroBill.\n    \"\"\"\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83c\udf00 Handling updated line item for line_item_id={line_item_id}')\n    try:"
            },
            {
                "name": "process_xero_bill_delete",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "delete_xero_bill_trigger"
                ],
                "docstring": "The Celery task for handling deleted XeroBills.",
                "function_body": "def process_xero_bill_delete(bill_id: int):\n    \"\"\"\n    The Celery task for handling deleted XeroBills.\n    \"\"\"\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted XeroBill bill_id={bill_id}.')\n    try:"
            },
            {
                "name": "delete_xero_xero_bill_line_item",
                "args": [
                    "line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "delete_xero_xero_bill_line_item_trigger"
                ],
                "docstring": "The Celery task for handling deleted line items for a XeroBill.",
                "function_body": "def delete_xero_xero_bill_line_item(line_item_id: int):\n    \"\"\"\n    The Celery task for handling deleted line items for a XeroBill.\n    \"\"\"\n    logger = logging.getLogger('xero_logger')\n\n    logger.info(f'\ud83d\uddd1\ufe0f Handling deleted line item for line_item_id={line_item_id}')\n    try:"
            },
            {
                "name": "process_po_log_create",
                "args": [
                    "po_log_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "po_log_trigger_on_create"
                ],
                "docstring": "The Celery task for handling PO Log [NEW] action.\nExecutes the logic to process PO log files.",
                "function_body": "def process_po_log_create(po_log_id: int):\n    \"\"\"\n    The Celery task for handling PO Log [NEW] action.\n    Executes the logic to process PO log files.\n    \"\"\"\n    logger = logging.getLogger('budget_logger')\n\n    logger.info('\ud83d\ude80 Starting process_po_log_new shared task.')\n    try:"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/logging_setup.py",
        "functions": [
            {
                "name": "setup_logging",
                "args": [],
                "decorators": [],
                "calls": [],
                "docstring": "Configure all module-specific loggers (admin, budget, dropbox, invoice, etc.)\nEXCEPT for the Flask `web_logger`. We'll do that in `setup_web_logger()`.",
                "function_body": "def setup_logging():\n    \"\"\"\n    Configure all module-specific loggers (admin, budget, dropbox, invoice, etc.)\n    EXCEPT for the Flask `web_logger`. We'll do that in `setup_web_logger()`.\n    \"\"\"\n    os.makedirs('./logs', exist_ok=True)\n    basepath = './logs/'\n\n    LOGGING_CONFIG = {\n        'version': 1,\n        'disable_existing_loggers': False,  # Keep existing loggers\n        'formatters': {\n            'padded': {\n                '()': PaddedFormatter,\n                'fmt': \"%(asctime)s [%(levelname)s] [%(filename)s] [%(funcName)s] %(message)s\",\n                'datefmt': \"%H:%M:%S\",\n                'max_length': 10000000,\n            },\n        },\n        'handlers': {\n            'console': {\n                'class': 'logging.StreamHandler',\n                'formatter': 'padded',\n            },\n            'admintax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'admin.log'),\n                'formatter': 'padded',\n            },\n            'budgettax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'budget.log'),\n                'formatter': 'padded',\n            },\n            'dropboxtax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'dropbox.log'),\n                'formatter': 'padded',\n            },\n            'invoicetax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'invoice.log'),\n                'formatter': 'padded',\n            },\n            'mondaytax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'monday.log'),\n                'formatter': 'padded',\n            },\n            'po_logtax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'po_log.log'),\n                'formatter': 'padded',\n            },\n            'xerotax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'xero.log'),\n                'formatter': 'padded',\n            },\n            'databasetax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'database.log'),\n                'formatter': 'padded',\n            },\n        },\n        'loggers': {\n            'admin_logger': {\n                'handlers': ['admintax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'budget_logger': {\n                'handlers': ['budgettax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'dropbox': {\n                'handlers': ['dropboxtax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'invoice_logger': {\n                'handlers': ['invoicetax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'monday_logger': {\n                'handlers': ['mondaytax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'po_log_logger': {\n                'handlers': ['po_logtax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'xero_logger': {\n                'handlers': ['xerotax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            'database_logger': {\n                'handlers': ['databasetax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n            # Add other loggers as needed\n        },\n        'root': {\n            'handlers': ['console'],\n            'level': 'INFO',\n        },\n    }\n\n    logging.config.dictConfig(LOGGING_CONFIG)"
            },
            {
                "name": "setup_web_logger",
                "args": [
                    "flask_app"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Set up a 'web_logger' dedicated to Flask logs.\nThen attach these handlers to flask_app.logger, removing any defaults.",
                "function_body": "def setup_web_logger(flask_app):\n    \"\"\"\n    Set up a 'web_logger' dedicated to Flask logs.\n    Then attach these handlers to flask_app.logger, removing any defaults.\n    \"\"\"\n    basepath = './server_webhook/logs/'\n    os.makedirs(basepath, exist_ok=True)\n\n    web_logging_config = {\n        'version': 1,\n        'disable_existing_loggers': False,\n        'formatters': {\n            'padded': {\n                '()': PaddedFormatter,\n                'fmt': \"%(asctime)s [%(levelname)s] [%(filename)s] [%(funcName)s] %(message)s\",\n                'datefmt': \"%H:%M:%S\",\n            },\n        },\n        'handlers': {\n            'console': {\n                'class': 'logging.StreamHandler',\n                'formatter': 'padded',\n            },\n            'webtax_form': {\n                'class': 'logging.FileHandler',\n                'filename': os.path.join(basepath, 'web.log'),\n                'formatter': 'padded',\n            },\n        },\n        'loggers': {\n            'web_logger': {\n                'handlers': ['webtax_form', 'console'],\n                'level': 'DEBUG',\n                'propagate': False,\n            },\n        },\n        'root': {\n            'handlers': ['console'],\n            'level': 'INFO',\n        },\n    }\n\n    logging.config.dictConfig(web_logging_config)\n\n    web_logger = logging.getLogger('web_logger')\n\n    # Remove default Flask handlers\n    flask_app.logger.handlers = []\n    flask_app.logger.addHandler(web_logger.handlers[0])  # webtax_form\n    flask_app.logger.addHandler(web_logger.handlers[1])  # console\n    flask_app.logger.setLevel(logging.DEBUG)"
            }
        ],
        "classes": [
            {
                "name": "PaddedFormatter",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self",
                            "fmt",
                            "datefmt",
                            "max_length"
                        ],
                        "decorators": [],
                        "calls": [
                            "__init__"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self, fmt=None, datefmt=None, max_length=2000000):\n        super().__init__(fmt, datefmt)\n        self.max_length = max_length\n        self.COLUMN_WIDTHS = {"
                    },
                    {
                        "name": "pad_center",
                        "args": [
                            "self",
                            "text",
                            "width"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Pad text to the specified width, centering it.",
                        "function_body": "    def pad_center(self, text, width):\n        \"\"\"Pad text to the specified width, centering it.\"\"\"\n        text = text[:width] if len(text) > width else text  # Truncate if too long\n        return f\"{text:^{width}}\""
                    },
                    {
                        "name": "pad_left",
                        "args": [
                            "self",
                            "text",
                            "width"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Pad text to the specified width, aligning it to the left.",
                        "function_body": "    def pad_left(self, text, width):\n        \"\"\"Pad text to the specified width, aligning it to the left.\"\"\"\n        text = text[:width] if len(text) > width else text  # Truncate if too long\n        return f\"{text:<{width}}\""
                    },
                    {
                        "name": "format",
                        "args": [
                            "self",
                            "record"
                        ],
                        "decorators": [],
                        "calls": [
                            "pad_center",
                            "formatTime",
                            "pad_left",
                            "format"
                        ],
                        "docstring": null,
                        "function_body": "    def format(self, record):\n        # Map log levels to their corresponding icons\n        level_icons = {\n            \"ERROR\": \"\ud83c\udf15\",\n            \"WARNING\": \"\ud83c\udf17\",\n            \"INFO\": \"\ud83c\udf11\",\n            \"DEBUG\": \"\ud83c\udf12\",\n        }\n        icon = level_icons.get(record.levelname, \" \")\n        record.levelname = f\"{icon}{record.levelname}\"\n\n        # Center-align and pad each field dynamically\n        record.asctime  = self.pad_center(self.formatTime(record), self.COLUMN_WIDTHS[\"time\"])\n        record.levelname= self.pad_center(record.levelname,    self.COLUMN_WIDTHS[\"levelname\"])\n        record.filename = self.pad_left(record.filename,       self.COLUMN_WIDTHS[\"filename\"])\n        record.funcName = self.pad_center(record.funcName,       self.COLUMN_WIDTHS[\"funcName\"])\n\n        # Truncate message if necessary\n        # if len(record.msg) > self.max_length:\n        #     record.msg = record.msg[:self.max_length] + \"...\"\n        return super().format(record)"
                    },
                    {
                        "name": "formatTime",
                        "args": [
                            "self",
                            "record",
                            "datefmt"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def formatTime(self, record, datefmt=None):\n        ct = datetime.fromtimestamp(record.created)\n        if datefmt:\n            result = f\"[{ ct.strftime(datefmt)}]-[{int(record.msecs):03d}]\"\n        else:\n            result = f\"[{ct.strftime('%H%M:%S')}].[{int(record.msecs):03d}]\"\n        # We pad in the calling method so everything lines up\n        return result"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": []
    }
]