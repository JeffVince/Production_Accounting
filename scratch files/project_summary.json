[
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_agent/codegen_service.py",
        "functions": [
            {
                "name": "apply_sql_script",
                "args": [
                    "sql_script"
                ],
                "decorators": [],
                "calls": [
                    "get_db_session"
                ],
                "docstring": "Execute multi-statement SQL script against the DB using the provided session factory.\nFor foreign key constraints, ensure the referencing and referenced tables use same engine (InnoDB).",
                "function_body": "def apply_sql_script(sql_script: str):\n    \"\"\"\n    Execute multi-statement SQL script against the DB using the provided session factory.\n    For foreign key constraints, ensure the referencing and referenced tables use same engine (InnoDB).\n    \"\"\"\n    logger.info(\"[apply_sql_script] Running SQL:\\n%s\", sql_script)\n    with get_db_session() as session:"
            },
            {
                "name": "update_sqlalchemy_models",
                "args": [
                    "table_name",
                    "columns_or_updates",
                    "create",
                    "delete",
                    "models_file_path"
                ],
                "decorators": [],
                "calls": [
                    "_update_model_class",
                    "_build_sqlalchemy_class",
                    "_remove_model_class"
                ],
                "docstring": "- If create=True, insert a new class into models.py (at bottom).\n- If delete=True, remove existing definition for that table.\n- Otherwise, do partial updates.",
                "function_body": "def update_sqlalchemy_models(\n    table_name: str,\n    columns_or_updates: Any,\n    create=False,\n    delete=False,\n    models_file_path: str = \"../database/models.py\"\n):\n    \"\"\"\n    - If create=True, insert a new class into models.py (at bottom).\n    - If delete=True, remove existing definition for that table.\n    - Otherwise, do partial updates.\n    \"\"\"\n    if not os.path.exists(models_file_path):\n        logger.error(\"Models file not found: %s\", models_file_path)\n        return\n\n    with open(models_file_path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n\n    class_name = _table_name_to_class_name(table_name)\n    if create:\n        # Check if class is already present\n        class_pattern = re.compile(rf\"class\\s+{class_name}\\(Base\\)\")\n        if re.search(class_pattern, content):\n            logger.warning(\"Class definition for table '%s' already exists. Skipping creation.\", table_name)\n            updated_content = content\n        else:\n            new_class = _build_sqlalchemy_class(table_name, columns_or_updates)\n            updated_content = content.strip() + f\"\\n\\n{new_class}\\n\"\n            logger.info(\"Inserted new model class for table '%s' into %s\", table_name, models_file_path)\n    elif delete:\n        updated_content = _remove_model_class(table_name, content)\n    else:\n        updated_content = _update_model_class(table_name, content, columns_or_updates)\n\n    if updated_content != content:"
            },
            {
                "name": "_build_sqlalchemy_class",
                "args": [
                    "table_name",
                    "columns"
                ],
                "decorators": [],
                "calls": [
                    "_table_name_to_class_name",
                    "_parse_column_def"
                ],
                "docstring": null,
                "function_body": "def _build_sqlalchemy_class(table_name: str, columns: Any) -> str:\n    class_name = _table_name_to_class_name(table_name)\n    lines = []\n\n    if isinstance(columns, list):\n        for col in columns:\n            lines.append(_parse_column_def(col))\n    elif isinstance(columns, dict):\n        col_defs = columns.get(\"col_defs\", [])\n        for raw_col in col_defs:\n            lines.append(_parse_column_def(raw_col))\n    else:\n        lines.append(\"# Add your column definitions here\")\n\n    col_defs = \"\\n    \".join(lines)\n\n    return f\"\"\"# region \ud83d\udea7 {class_name.upper()} TABLE"
            },
            {
                "name": "_parse_column_def",
                "args": [
                    "column_string"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _parse_column_def(column_string: str) -> str:\n    tokens = column_string.strip().split(None, 1)\n    col_name = tokens[0]\n    remainder = tokens[1].upper() if len(tokens) > 1 else \"\"\n\n    # DECIMAL(...) check\n    dec_match = re.search(r\"DECIMAL\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\", remainder)\n    if dec_match:\n        precision = dec_match.group(1)\n        scale = dec_match.group(2)\n        return f\"{col_name} = Column(MYSQL_DECIMAL({precision}, {scale}), nullable=True)\"\n\n    # INT or INT(...)\n    int_match = re.search(r\"INT\", remainder)\n    if int_match:\n        return f\"{col_name} = Column(MYSQL_INTEGER(unsigned=True), nullable=True)\"\n\n    # fallback\n    return f\"{col_name} = Column(MYSQL_INTEGER(unsigned=True), nullable=True)\""
            },
            {
                "name": "_remove_model_class",
                "args": [
                    "table_name",
                    "file_content"
                ],
                "decorators": [],
                "calls": [
                    "_table_name_to_class_name"
                ],
                "docstring": null,
                "function_body": "def _remove_model_class(table_name: str, file_content: str) -> str:\n    class_name = _table_name_to_class_name(table_name)\n    region_pattern = rf\"# region.*?{class_name.upper()} TABLE.*?# endregion\"\n    updated = re.sub(region_pattern, \"\", file_content, flags=re.DOTALL)\n\n    if updated == file_content:\n        pattern = rf\"class\\s+{class_name}\\(Base\\).*?\\n# endregion\"\n        updated = re.sub(pattern, \"\", updated, flags=re.DOTALL)\n\n    if updated == file_content:\n        logger.warning(\"No matching class definition found for %s. Nothing removed.\", table_name)\n    else:\n        logger.info(\"Removed model class (and region) for %s.\", table_name)\n    return updated"
            },
            {
                "name": "_update_model_class",
                "args": [
                    "table_name",
                    "file_content",
                    "updates"
                ],
                "decorators": [],
                "calls": [
                    "_table_name_to_class_name"
                ],
                "docstring": null,
                "function_body": "def _update_model_class(table_name: str, file_content: str, updates: Dict[str, Any]) -> str:\n    class_name = _table_name_to_class_name(table_name)\n    pattern = rf\"(class\\s+{class_name}\\(Base\\).*?)(\\nclass|\\Z)\"\n    matches = list(re.finditer(pattern, file_content, flags=re.DOTALL))\n    if not matches:\n        logger.warning(\"No existing model class found for %s. Can't update.\", table_name)\n        return file_content\n\n    first_match = matches[0]\n    class_block = first_match.group(1)\n\n    note = \"\\n    # --- Updates below ---\\n\"\n    add_cols = updates.get(\"add_columns\", [])\n    for col in add_cols:\n        note += f\"    # ADD COLUMN: {col}\\n\"\n    drop_cols = updates.get(\"drop_columns\", [])\n    for col in drop_cols:\n        note += f\"    # DROP COLUMN: {col}\\n\"\n\n    updated_class_block = class_block + note\n    start, end = first_match.span(1)\n    new_content = file_content[:start] + updated_class_block + file_content[end:]\n    logger.info(\"Appended update notes to class '%s'.\", class_name)\n    return new_content"
            },
            {
                "name": "_table_name_to_class_name",
                "args": [
                    "table_name"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _table_name_to_class_name(table_name: str) -> str:\n    return \"\".join(word.capitalize() for word in table_name.split(\"_\"))"
            },
            {
                "name": "update_database_util_files",
                "args": [
                    "table_name",
                    "create",
                    "delete",
                    "db_util_path"
                ],
                "decorators": [],
                "calls": [
                    "_build_crud_methods",
                    "_remove_crud_methods"
                ],
                "docstring": "If create=True, we append new CRUD stubs at bottom. If delete=True, remove them.",
                "function_body": "def update_database_util_files(\n    table_name: str,\n    create=False,\n    delete=False,\n    db_util_path: str = \"../database/database_util.py\"\n):\n    \"\"\"\n    If create=True, we append new CRUD stubs at bottom. If delete=True, remove them.\n    \"\"\"\n    if not os.path.exists(db_util_path):\n        logger.warning(\"database_util.py not found at %s\", db_util_path)\n        return\n\n    with open(db_util_path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n\n    if create:\n        region_re = rf\"# region.*?{table_name}.*?# endregion\"\n        if re.search(region_re, content, flags=re.DOTALL):\n            logger.warning(\"CRUD region for '%s' already exists. Skipping creation.\", table_name)\n            updated_content = content\n        else:\n            crud_pattern = (\n                rf\"def\\s+search_{table_name}\\(.*?\\)\"\n                rf\"|def\\s+create_{table_name}\\(.*?\\)\"\n                rf\"|def\\s+update_{table_name}\\(.*?\\)\"\n            )\n            if re.search(crud_pattern, content, flags=re.DOTALL):\n                logger.warning(\"CRUD methods for '%s' already exist. Skipping creation.\", table_name)\n                updated_content = content\n            else:\n                new_methods = _build_crud_methods(table_name)\n                updated_content = content.strip() + f\"\\n\\n{new_methods}\\n\"\n                logger.info(\"Added new CRUD methods for table '%s' to database_util.py\", table_name)\n    elif delete:\n        updated_content = _remove_crud_methods(table_name, content)\n    else:\n        updated_content = content\n\n    if updated_content != content:"
            },
            {
                "name": "_build_crud_methods",
                "args": [
                    "table_name"
                ],
                "decorators": [],
                "calls": [
                    "_table_name_to_class_name"
                ],
                "docstring": null,
                "function_body": "def _build_crud_methods(table_name: str) -> str:\n    class_name = _table_name_to_class_name(table_name)\n    return f\"\"\""
            },
            {
                "name": "_remove_crud_methods",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _remove_crud_methods(table_name: str, content: str) -> str:\n    region_pattern = rf\"# region.*?{table_name}.*?# endregion\"\n    updated = re.sub(region_pattern, \"\", content, flags=re.DOTALL)\n    if updated != content:\n        logger.info(\"Removed region for '%s' from database_util.py\", table_name)\n        return updated\n\n    pattern = (\n        rf\"def\\s+search_{table_name}\\(.*?\\n\\n\"\n        rf\"|def\\s+create_{table_name}\\(.*?\\n\\n\"\n        rf\"|def\\s+update_{table_name}\\(.*?\\n\\n\"\n    )\n    updated = re.sub(pattern, \"\", content, flags=re.DOTALL)\n    if updated == content:\n        logger.warning(\"No existing CRUD stubs found for '%s'. Nothing removed.\", table_name)\n    else:\n        logger.info(\"Removed existing CRUD methods for '%s'.\", table_name)\n    return updated"
            },
            {
                "name": "update_database_trigger_file",
                "args": [
                    "table_name",
                    "create",
                    "delete",
                    "triggers_file_path"
                ],
                "decorators": [],
                "calls": [
                    "_add_import_for_celery_tasks",
                    "_remove_trigger_routing",
                    "_add_trigger_routing"
                ],
                "docstring": "If create=True, add references to TASK_ROUTING or create it.\nCould also add an import for process_{table_name}_ tasks if needed.",
                "function_body": "def update_database_trigger_file(\n    table_name: str,\n    create=False,\n    delete=False,\n    triggers_file_path: str = \"../database_trigger.py\"\n):\n    \"\"\"\n    If create=True, add references to TASK_ROUTING or create it.\n    Could also add an import for process_{table_name}_ tasks if needed.\n    \"\"\"\n    if not os.path.exists(triggers_file_path):\n        logger.warning(\"database_trigger.py not found at %s\", triggers_file_path)\n        return\n\n    with open(triggers_file_path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n\n    updated_content = content\n    # Optionally: add an import for new tasks if not present\n    updated_content = _add_import_for_celery_tasks(table_name, updated_content)\n\n    if create:\n        updated_content = _add_trigger_routing(table_name, updated_content)\n    elif delete:\n        updated_content = _remove_trigger_routing(table_name, updated_content)\n\n    if updated_content != content:"
            },
            {
                "name": "_add_import_for_celery_tasks",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _add_import_for_celery_tasks(table_name: str, content: str) -> str:\n    # Insert new lines into existing 'from celery_tasks import ( ... )' if found, or create one\n    import_pattern = r\"(from\\s+celery_tasks\\s+import\\s*\\([\\s\\S]*?\\))\"\n    match = re.search(import_pattern, content)\n    new_imports = f\"process_{table_name}_create, process_{table_name}_update, process_{table_name}_delete,\"\n\n    if match:"
            },
            {
                "name": "_add_trigger_routing",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _add_trigger_routing(table_name: str, content: str) -> str:\n    routing_pattern = r\"TASK_ROUTING\\s*=\\s*\\{\\s*\\(.*?\\}\\s*\\}\"\n    match = re.search(routing_pattern, content, flags=re.DOTALL)\n\n    new_entries = f\"\"\"    (\"{table_name}\", \"INSERT\"): lambda rid: process_{table_name}_create.delay(rid),\n    (\"{table_name}\", \"UPDATE\"): lambda rid: process_{table_name}_update.delay(rid),\n    (\"{table_name}\", \"DELETE\"): lambda rid: process_{table_name}_delete.delay(rid),\"\"\"\n\n    if match:"
            },
            {
                "name": "_remove_trigger_routing",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _remove_trigger_routing(table_name: str, content: str) -> str:\n    pattern = (\n        rf'\\(\\s*\"{table_name}\"\\s*,\\s*\"INSERT\"\\s*\\).*?\\n'\n        rf'|\\(\\s*\"{table_name}\"\\s*,\\s*\"UPDATE\"\\s*\\).*?\\n'\n        rf'|\\(\\s*\"{table_name}\"\\s*,\\s*\"DELETE\"\\s*\\).*?\\n'\n    )\n    updated = re.sub(pattern, \"\", content)\n    if updated == content:\n        logger.warning(\"No references found in database_trigger.py for %s. Nothing removed.\", table_name)\n    else:\n        logger.info(\"Removed references for '%s' from database_trigger.py\", table_name)\n    return updated"
            },
            {
                "name": "update_database_trigger_service_file",
                "args": [
                    "table_name",
                    "create",
                    "delete",
                    "trigger_service_path"
                ],
                "decorators": [],
                "calls": [
                    "_remove_trigger_service_methods",
                    "_add_trigger_service_methods"
                ],
                "docstring": "If create=True, add new <table_name>_trigger_on_create/update/delete at bottom.\nIf delete=True, remove them.",
                "function_body": "def update_database_trigger_service_file(\n    table_name: str,\n    create=False,\n    delete=False,\n    trigger_service_path: str = \"../server_celery/database_trigger_service.py\"\n):\n    \"\"\"\n    If create=True, add new <table_name>_trigger_on_create/update/delete at bottom.\n    If delete=True, remove them.\n    \"\"\"\n    if not os.path.exists(trigger_service_path):\n        logger.warning(\"database_trigger_service.py not found at %s\", trigger_service_path)\n        return\n\n    with open(trigger_service_path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n\n    if create:\n        updated_content = _add_trigger_service_methods(table_name, content)\n    elif delete:\n        updated_content = _remove_trigger_service_methods(table_name, content)\n    else:\n        updated_content = content\n\n    if updated_content != content:"
            },
            {
                "name": "_add_trigger_service_methods",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [
                    "_build_trigger_service_methods"
                ],
                "docstring": null,
                "function_body": "def _add_trigger_service_methods(table_name: str, content: str) -> str:\n    region_pattern = rf\"# region.*?{table_name.upper()} TRIGGERS\"\n    if re.search(region_pattern, content, flags=re.DOTALL):\n        logger.warning(f\"Trigger region for '{table_name}' already exists. Skipping creation.\")\n        return content\n\n    code_block = _build_trigger_service_methods(table_name)\n    updated_content = content.strip() + f\"\\n\\n{code_block}\\n\"\n    logger.info(\"Added new trigger region for '%s' to database_trigger_service.py\", table_name)\n    return updated_content"
            },
            {
                "name": "_build_trigger_service_methods",
                "args": [
                    "table_name"
                ],
                "decorators": [],
                "calls": [
                    "_table_name_to_class_name"
                ],
                "docstring": null,
                "function_body": "def _build_trigger_service_methods(table_name: str) -> str:\n    capitalized = _table_name_to_class_name(table_name)\n    return f\"\"\"# region \ud83c\udff7\ufe0f {table_name.upper()} TRIGGERS"
            },
            {
                "name": "_remove_trigger_service_methods",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _remove_trigger_service_methods(table_name: str, content: str) -> str:\n    region_pattern = rf\"# region.*?{table_name.upper()} TRIGGERS.*?# endregion\"\n    updated = re.sub(region_pattern, \"\", content, flags=re.DOTALL)\n    if updated != content:\n        logger.info(\"Removed region block for '%s' triggers from database_trigger_service.py\", table_name)\n        return updated\n\n    pattern = (\n        rf\"def\\s+{table_name}_trigger_on_create\\(.*?\\n\\n\"\n        rf\"def\\s+{table_name}_trigger_on_update\\(.*?\\n\\n\"\n        rf\"def\\s+{table_name}_trigger_on_delete\\(.*?\\n\\n\"\n    )\n    updated = re.sub(pattern, \"\", content, flags=re.DOTALL)\n    if updated == content:\n        logger.warning(\"No trigger methods found to remove for '%s' in database_trigger_service.py.\", table_name)\n    else:\n        logger.info(\"Removed trigger methods for '%s' from database_trigger_service.py\", table_name)\n    return updated"
            },
            {
                "name": "update_celery_tasks_file",
                "args": [
                    "table_name",
                    "create",
                    "delete",
                    "celery_file_path"
                ],
                "decorators": [],
                "calls": [
                    "_add_celery_tasks",
                    "_remove_celery_tasks"
                ],
                "docstring": "If create=True, add tasks at bottom. If delete=True, remove them.",
                "function_body": "def update_celery_tasks_file(\n    table_name: str,\n    create=False,\n    delete=False,\n    celery_file_path: str = \"../server_celery/celery_tasks.py\"\n):\n    \"\"\"\n    If create=True, add tasks at bottom. If delete=True, remove them.\n    \"\"\"\n    if not os.path.exists(celery_file_path):\n        logger.warning(\"celery_tasks.py not found at %s\", celery_file_path)\n        return\n\n    with open(celery_file_path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n\n    if create:\n        updated_content = _add_celery_tasks(table_name, content)\n    elif delete:\n        updated_content = _remove_celery_tasks(table_name, content)\n    else:\n        updated_content = content\n\n    if updated_content != content:"
            },
            {
                "name": "_add_celery_tasks",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [
                    "_build_celery_tasks"
                ],
                "docstring": null,
                "function_body": "def _add_celery_tasks(table_name: str, content: str) -> str:\n    region_pattern = rf\"# region.*?{table_name.upper()} TASKS.*?# endregion\"\n    if re.search(region_pattern, content, flags=re.DOTALL):\n        logger.warning(\"Celery tasks region for '%s' already exists. Skipping creation.\", table_name)\n        return content\n\n    tasks_pattern = (\n        rf\"def\\s+process_{table_name}_create\\(.*?\\)\"\n        rf\"|def\\s+process_{table_name}_update\\(.*?\\)\"\n        rf\"|def\\s+process_{table_name}_delete\\(.*?\\)\"\n    )\n    if re.search(tasks_pattern, content, flags=re.DOTALL):\n        logger.warning(\"Celery tasks for '%s' already exist. Skipping creation.\", table_name)\n        return content\n\n    new_celery_tasks = _build_celery_tasks(table_name)\n    updated_content = content.strip() + f\"\\n\\n{new_celery_tasks}\\n\"\n    return updated_content"
            },
            {
                "name": "_build_celery_tasks",
                "args": [
                    "table_name"
                ],
                "decorators": [],
                "calls": [
                    "_table_name_to_class_name"
                ],
                "docstring": null,
                "function_body": "def _build_celery_tasks(table_name: str) -> str:\n    capitalized = _table_name_to_class_name(table_name)\n    return f\"\"\"# region \ud83c\udf54 {table_name.upper()} TASKS"
            },
            {
                "name": "_remove_celery_tasks",
                "args": [
                    "table_name",
                    "content"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def _remove_celery_tasks(table_name: str, content: str) -> str:\n    region_pattern = rf\"# region.*?{table_name.upper()} TASKS.*?# endregion\"\n    updated = re.sub(region_pattern, \"\", content, flags=re.DOTALL)\n    if updated != content:\n        logger.info(\"Removed region block for '%s' tasks from celery_tasks.py\", table_name)\n        return updated\n\n    pattern = (\n        rf\"@shared_task\\s+def\\s+process_{table_name}_create\\(.*?\\n\\n\"\n        rf\"@shared_task\\s+def\\s+process_{table_name}_update\\(.*?\\n\\n\"\n        rf\"@shared_task\\s+def\\s+process_{table_name}_delete\\(.*?\\n\\n\"\n    )\n    updated = re.sub(pattern, \"\", content, flags=re.DOTALL)\n    if updated == content:\n        logger.warning(\"No Celery tasks found to remove for '%s'.\", table_name)\n    else:\n        logger.info(\"Removed Celery tasks for table '%s'.\", table_name)\n    return updated"
            }
        ],
        "classes": [
            {
                "name": "AiLogCaptureHandler",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "__init__"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        super().__init__()\n        self.records = []"
                    },
                    {
                        "name": "emit",
                        "args": [
                            "self",
                            "record"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def emit(self, record: logging.LogRecord):\n        self.records.append(self.format(record))"
                    },
                    {
                        "name": "get_logs",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_logs(self) -> List[str]:\n        return self.records"
                    },
                    {
                        "name": "clear_logs",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def clear_logs(self):\n        self.records.clear()"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('agent_logger')"
            },
            {
                "name": "_ai_log_handler",
                "value": "AiLogCaptureHandler()"
            },
            {
                "name": "formatter",
                "value": "logging.Formatter('[%(levelname)s] %(name)s - %(message)s')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_agent/chat_service.py",
        "functions": [],
        "classes": [
            {
                "name": "ChatService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "initialize_database"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger(\"agent_logger\")\n        self.db_ops = DatabaseOperations()\n\n        # Initialize DB once\n        config = Config()\n        db_settings = config.get_database_settings(config.USE_LOCAL)\n        initialize_database(db_settings['url'])\n        self.logger.debug(\"Database initialized in ChatService constructor.\")"
                    },
                    {
                        "name": "create_table",
                        "args": [
                            "self",
                            "table_name",
                            "columns_or_defs"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_sqlalchemy_models",
                            "apply_sql_script",
                            "update_celery_tasks_file",
                            "update_database_util_files",
                            "_build_create_table_sql",
                            "update_database_trigger_file"
                        ],
                        "docstring": "Creates a new table in the DB with the provided columns, then updates code references.",
                        "function_body": "    def create_table(self, table_name: str, columns_or_defs: Any):\n        \"\"\"\n        Creates a new table in the DB with the provided columns, then updates code references.\n        \"\"\"\n        self.logger.info(f\"create_table -> {table_name}, columns={columns_or_defs}\")\n\n        # Build SQL\n        if isinstance(columns_or_defs, list):\n            create_sql = self._build_create_table_sql(table_name, columns_or_defs)\n        else:\n            col_list = columns_or_defs.get(\"col_defs\", [])\n            create_sql = self._build_create_table_sql(table_name, col_list)\n\n        # Apply\n        apply_sql_script(create_sql)\n\n        # Update references\n        update_sqlalchemy_models(table_name, columns_or_defs, create=True)\n        update_database_util_files(table_name, create=True)\n        update_database_trigger_file(table_name, create=True)\n        update_celery_tasks_file(table_name, create=True)\n\n        self.logger.info(f\"Table '{table_name}' created successfully in DB + code.\")"
                    },
                    {
                        "name": "update_table",
                        "args": [
                            "self",
                            "table_name",
                            "updates"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_sqlalchemy_models",
                            "apply_sql_script",
                            "update_celery_tasks_file",
                            "update_database_util_files",
                            "_build_alter_sql",
                            "update_database_trigger_file"
                        ],
                        "docstring": "Updates columns (add/drop) or other aspects, then updates references in code.",
                        "function_body": "    def update_table(self, table_name: str, updates: Dict[str, Any]):\n        \"\"\"\n        Updates columns (add/drop) or other aspects, then updates references in code.\n        \"\"\"\n        self.logger.info(f\"update_table -> {table_name}, updates={updates}\")\n\n        alter_sql = self._build_alter_sql(table_name, updates)\n        apply_sql_script(alter_sql)\n\n        update_sqlalchemy_models(table_name, updates, create=False)\n        update_database_util_files(table_name, create=False)\n        update_database_trigger_file(table_name, create=False)\n        update_celery_tasks_file(table_name, create=False)\n\n        self.logger.info(f\"Table '{table_name}' updated successfully (DB + code).\")"
                    },
                    {
                        "name": "delete_table",
                        "args": [
                            "self",
                            "table_name"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_sqlalchemy_models",
                            "apply_sql_script",
                            "update_celery_tasks_file",
                            "update_database_util_files",
                            "update_database_trigger_file"
                        ],
                        "docstring": null,
                        "function_body": "    def delete_table(self, table_name: str):\n        self.logger.info(f\"delete_table -> {table_name}\")\n        sql = f\"DROP TABLE IF EXISTS `{table_name}`;\"\n        apply_sql_script(sql)\n\n        update_sqlalchemy_models(table_name, None, delete=True)\n        update_database_util_files(table_name, delete=True)\n        update_database_trigger_file(table_name, delete=True)\n        update_celery_tasks_file(table_name, delete=True)\n\n        self.logger.info(f\"Table '{table_name}' dropped (DB + code).\")"
                    },
                    {
                        "name": "insert_data",
                        "args": [
                            "self",
                            "table_name",
                            "data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_resolve_model",
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def insert_data(self, table_name: str, data: Dict[str, Any]):\n        self.logger.info(f\"insert_data -> {table_name}, data={data}\")\n        model_cls = self._resolve_model(table_name)\n        if not model_cls:\n            self.logger.warning(f\"No model found for {table_name}, insert aborted.\")\n            return\n        self.db_ops._create_record(model_cls, unique_lookup=None, **data)\n        self.logger.info(f\"Data inserted into {table_name}.\")"
                    },
                    {
                        "name": "update_data",
                        "args": [
                            "self",
                            "table_name",
                            "updates",
                            "where"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record",
                            "_resolve_model",
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def update_data(self, table_name: str, updates: Dict[str, Any], where: Dict[str, Any]):\n        self.logger.info(f\"update_data -> {table_name}, updates={updates}, where={where}\")\n        model_cls = self._resolve_model(table_name)\n        if not model_cls:\n            self.logger.warning(f\"No model found for {table_name}, update aborted.\")\n            return\n\n        record_id = where.get(\"id\")\n        if record_id is not None:\n            self.db_ops._update_record(model_cls, record_id, **updates)\n        else:\n            found = self.db_ops._search_records(model_cls, list(where.keys()), list(where.values()))\n            if not found:\n                self.logger.warning(\"No matching records. Skipping update.\")\n                return\n            if isinstance(found, list):\n                first = found[0]\n                rid = first[\"id\"]\n                self.db_ops._update_record(model_cls, rid, **updates)\n            else:\n                rid = found[\"id\"]\n                self.db_ops._update_record(model_cls, rid, **updates)\n\n        self.logger.info(\"Update successful.\")"
                    },
                    {
                        "name": "query_data",
                        "args": [
                            "self",
                            "table_name",
                            "filters"
                        ],
                        "decorators": [],
                        "calls": [
                            "_resolve_model",
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def query_data(self, table_name: str, filters: Dict[str, Any]):\n        self.logger.info(f\"query_data -> {table_name}, filters={filters}\")\n        model_cls = self._resolve_model(table_name)\n        if not model_cls:\n            self.logger.warning(f\"No model found for {table_name}, query aborted.\")\n            return []\n        return self.db_ops._search_records(model_cls, list(filters.keys()), list(filters.values()))"
                    },
                    {
                        "name": "answer_general_question",
                        "args": [
                            "self",
                            "user_input"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def answer_general_question(self, user_input: str):\n        self.logger.info(f\"answer_general_question -> {user_input}\")\n        print(\"AI Agent: You asked for best practices or general advice. I'm here to help!\")"
                    },
                    {
                        "name": "_resolve_model",
                        "args": [
                            "self",
                            "table_name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Basic approach: map table_name to actual SQLAlchemy model.\nIf synonyms or variations (e.g. \"purchase orders\"), handle them here or in GPT prompt.",
                        "function_body": "    def _resolve_model(self, table_name: str):\n        \"\"\"\n        Basic approach: map table_name to actual SQLAlchemy model.\n        If synonyms or variations (e.g. \"purchase orders\"), handle them here or in GPT prompt.\n        \"\"\"\n        from database.models import (\n            Project, Contact, PurchaseOrder, DetailItem, Invoice, AuditLog,\n            XeroBill, BankTransaction, AccountCode, TaxAccount,\n            Receipt, SpendMoney, User, TaxLedger, BudgetMap\n        )\n        table_map = {\n            \"project\": Project,\n            \"contact\": Contact,\n            \"purchase_order\": PurchaseOrder,\n            \"detail_item\": DetailItem,\n            \"invoice\": Invoice,\n            \"audit_log\": AuditLog,\n            \"xero_bill\": XeroBill,\n            \"bank_transaction\": BankTransaction,\n            \"account_code\": AccountCode,\n            \"tax_account\": TaxAccount,\n            \"receipt\": Receipt,\n            \"spend_money\": SpendMoney,\n            \"users\": User,\n            \"tax_ledger\": TaxLedger,\n            \"budget_map\": BudgetMap\n        }\n        return table_map.get(table_name.lower())"
                    },
                    {
                        "name": "_build_create_table_sql",
                        "args": [
                            "self",
                            "table_name",
                            "columns"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _build_create_table_sql(self, table_name: str, columns: list) -> str:\n        col_defs = \",\\n  \".join(columns)\n        return f\"\"\""
                    },
                    {
                        "name": "_build_alter_sql",
                        "args": [
                            "self",
                            "table_name",
                            "updates"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Extend for foreign key logic if needed. For now, we detect 'FOREIGN KEY' substring.",
                        "function_body": "    def _build_alter_sql(self, table_name: str, updates: Dict[str, Any]) -> str:\n        \"\"\"\n        Extend for foreign key logic if needed. For now, we detect 'FOREIGN KEY' substring.\n        \"\"\"\n        stmts = []\n        add_cols = updates.get(\"add_columns\", [])\n        drop_cols = updates.get(\"drop_columns\", [])\n\n        for ac in add_cols:\n            if \"FOREIGN KEY\" in ac.upper():\n                # user might pass \"project_id INT UNSIGNED, ADD CONSTRAINT fk_project FOREIGN KEY...\"\n                stmts.append(f\"ADD {ac}\")\n            else:\n                stmts.append(f\"ADD COLUMN {ac}\")\n\n        for dc in drop_cols:\n            stmts.append(f\"DROP COLUMN {dc}\")\n\n        if stmts:\n            return f\"ALTER TABLE `{table_name}`\\n  {',  '.join(stmts)};\"\n        return f\"-- No changes for table {table_name}\""
                    }
                ],
                "decorators": []
            }
        ],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_agent/agent_app.py",
        "functions": [
            {
                "name": "load_schema_instructions",
                "args": [
                    "models_file_path"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Reads database/models.py to gather table names and generate a textual summary\nfor GPT's system prompt. Also includes synonyms or references if needed.",
                "function_body": "def load_schema_instructions(models_file_path=\"database/models.py\"):\n    \"\"\"\n    Reads database/models.py to gather table names and generate a textual summary\n    for GPT's system prompt. Also includes synonyms or references if needed.\n    \"\"\"\n    if not os.path.exists(models_file_path):\n        return \"Unable to locate models file for schema instructions.\"\n\n    with open(models_file_path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n\n    # Basic pattern: \"class SomeTable(Base):\"\n    pattern = re.compile(r\"class\\s+(\\w+)\\(Base\\)\")\n    matches = pattern.findall(content)\n    if not matches:\n        return \"No SQLAlchemy models found in database/models.py.\"\n\n    instructions = [\"I found these SQLAlchemy models:\\n\"]\n    for model_name in matches:\n        instructions.append(f\"- {model_name}\")\n\n    # (Optional) you can add synonyms, e.g. \"purchase orders\" => \"purchase_order\"\n    instructions.append(\n        \"\\nIf user says 'purchase orders', interpret as 'purchase_order'. \"\n        \"If user says 'parent of detail_item', interpret as 'purchase_order'.\\n\"\n        \"For best practices or coding strategy, respond with action='other'.\"\n    )\n    return \"\\n\".join(instructions)"
            }
        ],
        "classes": [
            {
                "name": "AgentApp",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "load_schema_instructions"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger(\"agent_logger\")\n        self.client = OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\"))\n        self.chat_service = ChatService()\n        self.schema_docs = load_schema_instructions()\n\n        # Track the most recently used table name for references like \"that table\"\n        self.current_table_name = None"
                    },
                    {
                        "name": "chat_loop",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_handle_intent",
                            "_interpret_intent",
                            "_stream_and_clear_recent_logs"
                        ],
                        "docstring": null,
                        "function_body": "    def chat_loop(self):\n        print(\"AI Agent: Hi Jeff, how can I help you today? Type 'quit' or Ctrl+C to exit.\")\n        while True:"
                    },
                    {
                        "name": "_interpret_intent",
                        "args": [
                            "self",
                            "user_text"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Use GPT to parse user input into a structured JSON, or fallback to 'other'.",
                        "function_body": "    def _interpret_intent(self, user_text: str) -> dict:\n        \"\"\"\n        Use GPT to parse user input into a structured JSON, or fallback to 'other'.\n        \"\"\"\n        system_prompt = f\"\"\"\\\nYou are an AI that handles DB requests or best practices.\nReturn JSON with:\n  action in [create_table, update_table, delete_table, insert_data, update_data, query_data, other]\n  table_name\n  columns_or_updates\n  where\n  filters\n\nBelow is the current schema context:\n{self.schema_docs}\n\"\"\"\n\n        messages = [\n            {\"role\": \"system\", \"content\": system_prompt},\n            {\"role\": \"user\", \"content\": user_text}\n        ]\n        try:"
                    },
                    {
                        "name": "_handle_intent",
                        "args": [
                            "self",
                            "intent",
                            "user_text"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_table",
                            "answer_general_question",
                            "query_data",
                            "update_data",
                            "_resolve_table_name",
                            "delete_table",
                            "insert_data",
                            "update_table"
                        ],
                        "docstring": null,
                        "function_body": "    def _handle_intent(self, intent: dict, user_text: str):\n        action = intent.get(\"action\", \"other\")\n        table_name = intent.get(\"table_name\", \"\")\n        columns_or_updates = intent.get(\"columns_or_updates\", {})\n        where_clause = intent.get(\"where\", {})\n        filters = intent.get(\"filters\", {})\n\n        # Possibly handle \"that table\" references, etc.\n        table_name = self._resolve_table_name(table_name)\n\n        if action == \"create_table\":"
                    },
                    {
                        "name": "_resolve_table_name",
                        "args": [
                            "self",
                            "table_name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _resolve_table_name(self, table_name: str) -> str:\n        if not table_name and self.current_table_name:\n            return self.current_table_name\n        return table_name"
                    },
                    {
                        "name": "_stream_and_clear_recent_logs",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "clear_logs",
                            "get_logs"
                        ],
                        "docstring": "Reads new logs from the AiLogCaptureHandler, prints them line by line as a summary.\nThis helps the user see success/failure in near real time.",
                        "function_body": "    def _stream_and_clear_recent_logs(self):\n        \"\"\"\n        Reads new logs from the AiLogCaptureHandler, prints them line by line as a summary.\n        This helps the user see success/failure in near real time.\n        \"\"\"\n        logs = _ai_log_handler.get_logs()\n        if logs:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "setup_logging('agent_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_agent/logging_setup.py",
        "functions": [
            {
                "name": "setup_logging",
                "args": [],
                "decorators": [],
                "calls": [],
                "docstring": "Create loggers for each module: budget, dropbox, invoice, monday, po_log, xero, database.\nEach logger writes to a separate file in ./logs, plus a StreamHandler for the console.",
                "function_body": "def setup_logging():\n    \"\"\"\n    Create loggers for each module: budget, dropbox, invoice, monday, po_log, xero, database.\n    Each logger writes to a separate file in ./logs, plus a StreamHandler for the console.\n    \"\"\"\n    # Ensure the logs folder exists\n    os.makedirs(\"./logs\", exist_ok=True)\n    folder_name = \"server_agent\"\n\n    basepath = \"./\" + folder_name + \"/logs/\"\n    # Common log format\n    log_format = \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\"\n    formatter = logging.Formatter(log_format)\n\n    # StreamHandler for console (all logs)\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    \n    # ---------------------------------------------------------\n    #  Logger for admin\n    # ---------------------------------------------------------\n    admin_logger = logging.getLogger(\"admin_logger\")\n    admin_logger.setLevel(logging.DEBUG)\n    file_handler_admin = logging.FileHandler(basepath + \"admin.log\")\n    file_handler_admin.setFormatter(formatter)\n    admin_logger.addHandler(file_handler_admin)\n    admin_logger.addHandler(console_handler)\n    admin_logger.propagate = False\n    \n    # ---------------------------------------------------------\n    #  Logger for budget\n    # ---------------------------------------------------------\n    budget_logger = logging.getLogger(\"budget_logger\")\n    budget_logger.setLevel(logging.DEBUG)\n    file_handler_budget = logging.FileHandler(basepath + \"budget.log\")\n    file_handler_budget.setFormatter(formatter)\n    budget_logger.addHandler(file_handler_budget)\n    budget_logger.addHandler(console_handler)\n    budget_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for dropbox\n    # ---------------------------------------------------------\n    dropbox_logger = logging.getLogger(\"dropbox_logger\")\n    dropbox_logger.setLevel(logging.DEBUG)\n    file_handler_dropbox = logging.FileHandler(basepath + \"dropbox.log\")\n    file_handler_dropbox.setFormatter(formatter)\n    dropbox_logger.addHandler(file_handler_dropbox)\n    dropbox_logger.addHandler(console_handler)\n    dropbox_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for invoice\n    # ---------------------------------------------------------\n    invoice_logger = logging.getLogger(\"invoice_logger\")\n    invoice_logger.setLevel(logging.DEBUG)\n    file_handler_invoice = logging.FileHandler(basepath + \"invoice.log\")\n    file_handler_invoice.setFormatter(formatter)\n    invoice_logger.addHandler(file_handler_invoice)\n    invoice_logger.addHandler(console_handler)\n    invoice_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for monday\n    # ---------------------------------------------------------\n    monday_logger = logging.getLogger(\"monday_logger\")\n    monday_logger.setLevel(logging.DEBUG)\n    file_handler_monday = logging.FileHandler(basepath + \"monday.log\")\n    file_handler_monday.setFormatter(formatter)\n    monday_logger.addHandler(file_handler_monday)\n    monday_logger.addHandler(console_handler)\n    monday_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for po_log\n    # ---------------------------------------------------------\n    po_log_logger = logging.getLogger(\"po_log_logger\")\n    po_log_logger.setLevel(logging.DEBUG)\n    file_handler_po = logging.FileHandler(basepath + \"po_log.log\")\n    file_handler_po.setFormatter(formatter)\n    po_log_logger.addHandler(file_handler_po)\n    po_log_logger.addHandler(console_handler)\n    po_log_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for xero\n    # ---------------------------------------------------------\n    xero_logger = logging.getLogger(\"xero_logger\")\n    xero_logger.setLevel(logging.DEBUG)\n    file_handler_xero = logging.FileHandler(basepath + \"xero.log\")\n    file_handler_xero.setFormatter(formatter)\n    xero_logger.addHandler(file_handler_xero)\n    xero_logger.addHandler(console_handler)\n    xero_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for database\n    # ---------------------------------------------------------\n    db_logger = logging.getLogger(\"database_logger\")\n    db_logger.setLevel(logging.DEBUG)\n    file_handler_db = logging.FileHandler(basepath + \"database.log\")\n    file_handler_db.setFormatter(formatter)\n    db_logger.addHandler(file_handler_db)\n    db_logger.addHandler(console_handler)\n    db_logger.propagate = False\n\n    # Optional: set root logger if you want\n    logging.basicConfig(level=logging.INFO)"
            }
        ],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/database_view_util.py",
        "functions": [
            {
                "name": "natural_sort_key",
                "args": [
                    "s"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def natural_sort_key(s: str) -> list:\n    s = s or \"\"\n    return [int(part) if part.isdigit() else part.lower()"
            }
        ],
        "classes": [
            {
                "name": "DatabaseViewUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.db_ops = DatabaseOperations()"
                    },
                    {
                        "name": "fetch_all_map_names",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def fetch_all_map_names(self) -> List[str]:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "fetch_map_data",
                        "args": [
                            "self",
                            "map_name",
                            "page_account",
                            "per_page_account",
                            "page_tax",
                            "per_page_tax",
                            "sort_by",
                            "ledger_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session",
                            "natural_sort_key"
                        ],
                        "docstring": null,
                        "function_body": "    def fetch_map_data(\n        self,\n        map_name: str,\n        page_account: int = 1,\n        per_page_account: int = 40,\n        page_tax: int = 1,\n        per_page_tax: int = 10,\n        sort_by: str = None,\n        ledger_id: str = \"\"\n    ) -> Dict[str,Any]:\n        data = {\n            \"account_records\": [],\n            \"tax_records\": [],\n            \"page_account\": page_account,\n            \"page_tax\": page_tax,\n            \"total_pages_account\": 1,\n            \"total_pages_tax\": 1\n        }\n        with get_db_session() as session:\n            bm = session.query(BudgetMap).filter(BudgetMap.map_name==map_name).one_or_none()\n            if not bm:\n                return data\n            if not ledger_id:\n                return data  # No ledger => no data\n\n            ledger_id_int = int(ledger_id)\n            tax_rows = session.query(TaxAccount).filter(TaxAccount.tax_ledger_id==ledger_id_int).all()\n            tax_ids = [t.id for t in tax_rows]\n\n            acct_query = (\n                session.query(\n                    AccountCode.id,\n                    AccountCode.code,\n                    AccountCode.account_description,\n                    AccountCode.tax_id,\n                    AccountCode.updated_at,\n                    TaxAccount.tax_code\n                )\n                .outerjoin(TaxAccount, AccountCode.tax_id==TaxAccount.id)\n                .filter(AccountCode.budget_map_id==bm.id)\n                .filter(AccountCode.tax_id.in_(tax_ids))\n            )\n\n            if sort_by==\"code\":\n                acct_query=acct_query.order_by(AccountCode.code)\n            elif sort_by==\"description\":\n                acct_query=acct_query.order_by(AccountCode.account_description)\n            elif sort_by==\"linked_tax\":\n                acct_query=acct_query.order_by(TaxAccount.tax_code)\n            elif sort_by==\"updated\":\n                acct_query=acct_query.order_by(AccountCode.updated_at.desc())\n            elif sort_by==\"code_natural\":\n                pass\n\n            acct_rows=acct_query.all()\n            if sort_by==\"code_natural\":\n                acct_rows=sorted(acct_rows, key=lambda row: natural_sort_key(row.code or \"\"))\n\n            total_accounts=len(acct_rows)\n            total_pages_account = (total_accounts//per_page_account)+(1 if total_accounts%per_page_account!=0 else 0)\n            offset_account=(page_account-1)*per_page_account\n            selected_acct_rows=acct_rows[offset_account: offset_account+per_page_account]\n\n            account_records=[]\n            for row in selected_acct_rows:\n                account_records.append({\n                    \"id\": row.id,\n                    \"code\": row.code,\n                    \"account_description\": row.account_description,\n                    \"tax_id\": row.tax_id,\n                    \"tax_code\": row.tax_code,\n                    \"updated_at\": row.updated_at.isoformat() if row.updated_at else None\n                })\n            data[\"account_records\"]=account_records\n            data[\"page_account\"]=page_account\n            data[\"total_pages_account\"]=total_pages_account\n\n            tax_records=[]\n            for t in tax_rows:\n                tax_records.append({\n                    \"id\": t.id,\n                    \"tax_code\": t.tax_code,\n                    \"description\": t.description\n                })\n            data[\"tax_records\"]=tax_records\n            data[\"page_tax\"]=page_tax\n            data[\"total_pages_tax\"]=1\n        return data"
                    },
                    {
                        "name": "create_map_code",
                        "args": [
                            "self",
                            "new_map_name",
                            "copy_from_name",
                            "user_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def create_map_code(self, new_map_name: str, copy_from_name: str=\"\", user_id:int=1) -> None:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "delete_mapping",
                        "args": [
                            "self",
                            "map_name"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def delete_mapping(self, map_name:str) -> None:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "create_tax_record",
                        "args": [
                            "self",
                            "tax_code",
                            "tax_desc",
                            "tax_ledger_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def create_tax_record(self, tax_code:str, tax_desc:str, tax_ledger_id: Optional[int]) -> int:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "delete_tax_record",
                        "args": [
                            "self",
                            "map_name",
                            "tax_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def delete_tax_record(self, map_name:str, tax_id:int) -> None:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "update_tax_record",
                        "args": [
                            "self",
                            "tax_id",
                            "tax_code",
                            "tax_desc",
                            "tax_ledger_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def update_tax_record(self, tax_id:int, tax_code:str, tax_desc:str, tax_ledger_id: Optional[int]) -> None:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "assign_tax_to_account",
                        "args": [
                            "self",
                            "map_name",
                            "account_id",
                            "tax_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def assign_tax_to_account(self, map_name:str, account_id:int, tax_id:int)->None:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "assign_tax_bulk",
                        "args": [
                            "self",
                            "map_name",
                            "account_ids",
                            "tax_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def assign_tax_bulk(self, map_name:str, account_ids:List[int], tax_id:int)->None:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "fetch_ledgers_for_map",
                        "args": [
                            "self",
                            "map_name"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def fetch_ledgers_for_map(self, map_name:str)->List[Dict[str,Any]]:\n        with get_db_session() as session:"
                    },
                    {
                        "name": "add_ledger",
                        "args": [
                            "self",
                            "map_name",
                            "ledger_name",
                            "user_id",
                            "copy_mappings"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": "If ledger_name exists => create new ledger <ledger_name>-copy + copy tax codes from it.\nIf not => brand-new ledger with 1 'PLACEHOLDER' code.\nIf copy_mappings == True, also replicate the account->tax assignments\nfrom the old ledger to the new ledger (matching tax codes by index).\nReturns (ledger_id, actual_ledger_name).",
                        "function_body": "    def add_ledger(self, map_name:str, ledger_name:str, user_id:int=1, copy_mappings:bool=False)->(int, str):\n        \"\"\"\n        If ledger_name exists => create new ledger <ledger_name>-copy + copy tax codes from it.\n        If not => brand-new ledger with 1 'PLACEHOLDER' code.\n        If copy_mappings == True, also replicate the account->tax assignments\n        from the old ledger to the new ledger (matching tax codes by index).\n        Returns (ledger_id, actual_ledger_name).\n        \"\"\"\n        with get_db_session() as session:"
                    },
                    {
                        "name": "delete_ledger",
                        "args": [
                            "self",
                            "map_name",
                            "ledger_name"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def delete_ledger(self, map_name:str, ledger_name:str)->None:\n        with get_db_session() as session:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/models.py",
        "functions": [],
        "classes": [
            {
                "name": "Project",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "Contact",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "PurchaseOrder",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "DetailItem",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "Invoice",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "AuditLog",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "XeroBill",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "BankTransaction",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "AccountCode",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "TaxAccount",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "BillLineItem",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "Receipt",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "SpendMoney",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "User",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "TaxLedger",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            },
            {
                "name": "BudgetMap",
                "methods": [
                    {
                        "name": "to_dict",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def to_dict(self):\n        return {"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "Base",
                "value": "declarative_base()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/db_util.py",
        "functions": [
            {
                "name": "initialize_database",
                "args": [
                    "connection_string"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Initializes the database connection, session factory, and creates tables.",
                "function_body": "def initialize_database(connection_string):\n    \"\"\"Initializes the database connection, session factory, and creates tables.\"\"\"\n    global session_factory\n    engine = create_engine(connection_string, echo=False)\n    session_factory = scoped_session(sessionmaker(bind=engine))\n    Base.metadata.create_all(engine)  # Add this line to create tables\n    logger.debug(f\"Database connection string: {connection_string}\")"
            },
            {
                "name": "get_db_session",
                "args": [],
                "decorators": [
                    "contextmanager"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def get_db_session():\n    global session_factory\n    if session_factory is None:\n        raise RuntimeError(\"Session factory not initialized.\")\n    session = session_factory\n\n    try:"
            },
            {
                "name": "initialize_session_factory",
                "args": [
                    "session_factory_instance"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def initialize_session_factory(session_factory_instance: scoped_session):\n    global session_factory\n    session_factory = session_factory_instance"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('database_logger')"
            },
            {
                "name": "session_factory",
                "value": "None"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/database_util.py",
        "functions": [],
        "classes": [
            {
                "name": "DatabaseOperations",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger(\"database_logger\")\n        self.logger.debug(\"\ud83c\udf1f Hello from DatabaseOperations constructor! Ready to keep the DB in check!\")"
                    },
                    {
                        "name": "_serialize_record",
                        "args": [
                            "self",
                            "record"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\uddc4 Serialize a record (SQLAlchemy model) into a dictionary of column names -> values.\nReturns None if the record is None.",
                        "function_body": "    def _serialize_record(self, record):\n        \"\"\"\n        \ud83d\uddc4 Serialize a record (SQLAlchemy model) into a dictionary of column names -> values.\n        Returns None if the record is None.\n        \"\"\"\n        if not record:\n            return None\n        # \ud83d\ude80 Convert SQLAlchemy object to a dict of {column_name: value}\n        record_values = {c.name: getattr(record, c.name) for c in record.__table__.columns}\n        self.logger.debug(f\"\ud83e\udd13 Pulling record: {record_values.get('id', 'N/A')} from table {record.__table__}\")\n        return record_values"
                    },
                    {
                        "name": "_search_records",
                        "args": [
                            "self",
                            "model",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session",
                            "_serialize_record"
                        ],
                        "docstring": "\ud83d\udd0e Search for records of a given model based on multiple column filters.\nIf no column_names or values are provided, retrieves all records from the table.\n\nReturns:\n    - None if no records\n    - A single dict if exactly one found\n    - A list if multiple found\n    - [] if mismatch in columns/values or on error\n\nThis is an *atomic* operation: we open a fresh session, do the query,\ncommit/rollback, and close the session each time.",
                        "function_body": "    def _search_records(\n            self,\n            model,\n            column_names: Optional[List[str]] = None,\n            values: Optional[List[Any]] = None\n    ) -> Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        \"\"\"\n        \ud83d\udd0e Search for records of a given model based on multiple column filters.\n        If no column_names or values are provided, retrieves all records from the table.\n\n        Returns:\n            - None if no records\n            - A single dict if exactly one found\n            - A list if multiple found\n            - [] if mismatch in columns/values or on error\n\n        This is an *atomic* operation: we open a fresh session, do the query,\n        commit/rollback, and close the session each time.\n        \"\"\"\n        column_names = column_names or []\n        values = values or []\n\n        # Basic validations\n        if column_names and values:\n            self.logger.debug(f\"\ud83d\udd75\ufe0f Searching {model.__name__} with filters: {list(zip(column_names, values))}\")\n            self.logger.info(\n                f\"\ud83d\udea6 Checking if there are any matches in {model.__name__} \"\n                f\"for columns & values: {list(zip(column_names, values))}\"\n            )\n\n            if len(column_names) != len(values):\n                self.logger.warning(\n                    \"\u26a0\ufe0f Oops, mismatch: The number of column names and values do not match. Returning empty list.\"\n                )\n                return []\n        else:\n            self.logger.debug(f\"\ud83d\udd75\ufe0f No filters provided. Retrieving all records from {model.__name__}.\")\n            self.logger.info(f\"\ud83d\udea6 Fetching the entire {model.__name__} table without any filters.\")\n\n        with get_db_session() as session:"
                    },
                    {
                        "name": "_create_record",
                        "args": [
                            "self",
                            "model",
                            "unique_lookup"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session",
                            "_serialize_record",
                            "_search_records"
                        ],
                        "docstring": "\ud83c\udd95 Create a new record in the database, returning its serialized form or None on error.\nIncludes session.flush() before session.commit() to ensure ID is generated & data is visible.\n\nConcurrency-Safe Logic:\n  - If an IntegrityError occurs (e.g. duplicate key), we do a fallback re-query\n    if 'unique_lookup' is provided.\n  - If found, return the existing record. Otherwise, raise or return None.",
                        "function_body": "    def _create_record(\n            self,\n            model,\n            unique_lookup: dict = None,\n            **kwargs\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        \ud83c\udd95 Create a new record in the database, returning its serialized form or None on error.\n        Includes session.flush() before session.commit() to ensure ID is generated & data is visible.\n\n        Concurrency-Safe Logic:\n          - If an IntegrityError occurs (e.g. duplicate key), we do a fallback re-query\n            if 'unique_lookup' is provided.\n          - If found, return the existing record. Otherwise, raise or return None.\n        \"\"\"\n        self.logger.debug(f\"\ud83e\uddd1\u200d\ud83d\udcbb Creating new {model.__name__} using data: {kwargs}\")\n        self.logger.info(f\"\ud83c\udf31 About to insert a fresh record into {model.__name__} with {kwargs}\")\n\n        with get_db_session() as session:"
                    },
                    {
                        "name": "_update_record",
                        "args": [
                            "self",
                            "model",
                            "record_id",
                            "unique_lookup"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session",
                            "_serialize_record",
                            "_search_records"
                        ],
                        "docstring": "\ud83d\udd04 Update an existing record by its primary key (ID).\nReturns the serialized updated record, or None if not found or on error.\nIncludes session.flush() before session.commit() so changes are visible.\n\nConcurrency-Safe Logic:\n  - If an IntegrityError occurs (duplicate key on some column), we can attempt\n    a fallback re-query if 'unique_lookup' is provided.\n\n:param model: The SQLAlchemy model\n:param record_id: The primary key ID for the record to update\n:param unique_lookup: optional concurrency fallback\n:param kwargs: fields to update\n:return: updated record (serialized) or None",
                        "function_body": "    def _update_record(\n            self,\n            model,\n            record_id: int,\n            unique_lookup: dict = None,\n            **kwargs\n    ) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        \ud83d\udd04 Update an existing record by its primary key (ID).\n        Returns the serialized updated record, or None if not found or on error.\n        Includes session.flush() before session.commit() so changes are visible.\n\n        Concurrency-Safe Logic:\n          - If an IntegrityError occurs (duplicate key on some column), we can attempt\n            a fallback re-query if 'unique_lookup' is provided.\n\n        :param model: The SQLAlchemy model\n        :param record_id: The primary key ID for the record to update\n        :param unique_lookup: optional concurrency fallback\n        :param kwargs: fields to update\n        :return: updated record (serialized) or None\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd27 Attempting to update {model.__name__}(id={record_id}). Fields: {kwargs}\")\n        self.logger.info(f\"\ud83e\udd1d Checking if {model.__name__}(id={record_id}) exists, then updating with {kwargs}.\")\n\n        with get_db_session() as session:"
                    },
                    {
                        "name": "search_account_codes",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_account_codes(self, column_names, values):\n        self.logger.debug(\"\ud83d\udd0e Searching for Account Code entries...\")\n        return self._search_records(AccountCode, column_names, values)"
                    },
                    {
                        "name": "create_account_code",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": "If 'account_code' is unique, pass unique_lookup={'account_code': kwargs.get('account_code')}",
                        "function_body": "    def create_account_code(self, **kwargs):\n        \"\"\"\n        If 'account_code' is unique, pass unique_lookup={'account_code': kwargs.get('account_code')}\n        \"\"\"\n        self.logger.debug(f\"\ud83c\udf08 Creating an AccountCode with data={kwargs}\")\n        unique_lookup = {}\n        if 'code' in kwargs:\n            unique_lookup['code'] = kwargs['code']\n        return self._create_record(AccountCode, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "search_purchase_orders",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_purchase_orders(self, column_names, values):\n        self.logger.debug(f\"\ud83d\udcdd search_purchase_orders: columns={column_names}, values={values}\")\n        return self._search_records(PurchaseOrder, column_names, values)"
                    },
                    {
                        "name": "create_purchase_order",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": "If you have a unique constraint like (project_id, po_number), define:\n  unique_lookup = {'project_id': ..., 'po_number': ...}",
                        "function_body": "    def create_purchase_order(self, **kwargs):\n        \"\"\"\n        If you have a unique constraint like (project_id, po_number), define:\n          unique_lookup = {'project_id': ..., 'po_number': ...}\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udcdd create_purchase_order with {kwargs}\")\n        unique_lookup = {}\n        if 'project_id' in kwargs and 'po_number' in kwargs:\n            unique_lookup = {\n                'project_id': kwargs['project_id'],\n                'po_number': kwargs['po_number']\n            }\n        return self._create_record(PurchaseOrder, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_purchase_order",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": "If there's a unique constraint (project_id, po_number) that can be updated, pass a unique_lookup.\nOtherwise normal update.",
                        "function_body": "    def update_purchase_order(self, po_id, **kwargs):\n        \"\"\"\n        If there's a unique constraint (project_id, po_number) that can be updated, pass a unique_lookup.\n        Otherwise normal update.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udcdd update_purchase_order -> PurchaseOrder(id={po_id}), data={kwargs}\")\n        return self._update_record(PurchaseOrder, po_id, **kwargs)"
                    },
                    {
                        "name": "search_purchase_order_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders"
                        ],
                        "docstring": "Return PurchaseOrder(s) based on optional project_number & po_number.\n  - If neither is provided, returns ALL PurchaseOrders.\n  - If only project_number is given, returns all POs for that project_number.\n  - If project_number + po_number are given, returns just that subset.",
                        "function_body": "    def search_purchase_order_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None\n    ) -> Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        \"\"\"\n        Return PurchaseOrder(s) based on optional project_number & po_number.\n          - If neither is provided, returns ALL PurchaseOrders.\n          - If only project_number is given, returns all POs for that project_number.\n          - If project_number + po_number are given, returns just that subset.\n        \"\"\"\n        # If nothing provided, search all\n        if not project_number and not po_number:\n            return self.search_purchase_orders([], [])\n\n        col_filters = []\n        val_filters = []\n\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n\n        return self.search_purchase_orders(col_filters, val_filters)"
                    },
                    {
                        "name": "create_purchase_order_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_purchase_order",
                            "search_projects"
                        ],
                        "docstring": "Shortcut to create a PurchaseOrder by directly specifying project_number & po_number.\nWe still need the project_id though, so consider how you want to handle that.",
                        "function_body": "    def create_purchase_order_by_keys(self, project_number: int, po_number: int, **kwargs):\n        \"\"\"\n        Shortcut to create a PurchaseOrder by directly specifying project_number & po_number.\n        We still need the project_id though, so consider how you want to handle that.\n        \"\"\"\n        # If you want to look up a project row by project_number, you can do so here:\n        project_record = self.search_projects([\"project_number\"], [project_number])\n        if not project_record:\n            self.logger.warning(\n                f\"Cannot create PurchaseOrder because Project with project_number={project_number} not found.\"\n            )\n            return None\n        if isinstance(project_record, list):\n            project_record = project_record[0]\n\n        project_id = project_record[\"id\"]\n        kwargs.update({\"project_id\": project_id, \"project_number\": project_number, \"po_number\": po_number})\n        return self.create_purchase_order(**kwargs)"
                    },
                    {
                        "name": "update_purchase_order_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_order_by_keys",
                            "update_purchase_order"
                        ],
                        "docstring": "Shortcut to update a PurchaseOrder, given project_number + po_number.\nIf multiple POs match, we only update the first one.",
                        "function_body": "    def update_purchase_order_by_keys(self, project_number: int, po_number: int, **kwargs):\n        \"\"\"\n        Shortcut to update a PurchaseOrder, given project_number + po_number.\n        If multiple POs match, we only update the first one.\n        \"\"\"\n        pos = self.search_purchase_order_by_keys(project_number, po_number)\n        if not pos:\n            return None\n        if isinstance(pos, list):\n            first_po = pos[0]\n        else:\n            first_po = pos\n\n        return self.update_purchase_order(first_po[\"id\"], **kwargs)"
                    },
                    {
                        "name": "search_detail_items",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_detail_items(self, column_names, values):\n        self.logger.debug(f\"\ud83d\udd0e search_detail_items: columns={column_names}, values={values}\")\n        return self._search_records(DetailItem, column_names, values)"
                    },
                    {
                        "name": "create_detail_item",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_detail_item(self, **kwargs):\n        self.logger.debug(f\"\ud83e\uddf1 Creating a detail item with {kwargs}\")\n        # If (project_number, po_number, detail_number, line_number) is unique, define unique_lookup\n        unique_lookup = {}\n        if ('po_number' in kwargs\n                and 'project_number' in kwargs\n                and 'detail_number' in kwargs\n                and 'line_number' in kwargs):\n            unique_lookup = {\n                'project_number': kwargs['project_number'],\n                'po_number': kwargs['po_number'],\n                'detail_number': kwargs['detail_number'],\n                'line_number': kwargs['line_number']\n            }\n        return self._create_record(DetailItem, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_detail_item",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_detail_item(self, detail_item_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udd27 update_detail_item -> DetailItem(id={detail_item_id}), data={kwargs}\")\n        return self._update_record(DetailItem, detail_item_id, **kwargs)"
                    },
                    {
                        "name": "search_detail_item_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items"
                        ],
                        "docstring": "Returns DetailItem(s) based on any subset of the four optional keys.\n  - If none provided, returns ALL DetailItems.\n  - If only project_number, returns all items for that project.\n  - If project_number + po_number, returns items for that PO, etc.",
                        "function_body": "    def search_detail_item_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None\n    ) -> Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        \"\"\"\n        Returns DetailItem(s) based on any subset of the four optional keys.\n          - If none provided, returns ALL DetailItems.\n          - If only project_number, returns all items for that project.\n          - If project_number + po_number, returns items for that PO, etc.\n        \"\"\"\n        if not project_number and not po_number and not detail_number and not line_number:\n            return self.search_detail_items([], [])\n\n        col_filters = []\n        val_filters = []\n\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n        if detail_number is not None:\n            col_filters.append(\"detail_number\")\n            val_filters.append(detail_number)\n        if line_number is not None:\n            col_filters.append(\"line_number\")\n            val_filters.append(line_number)\n\n        return self.search_detail_items(col_filters, val_filters)"
                    },
                    {
                        "name": "create_detail_item_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": "Shortcut to create a DetailItem with explicit keys.",
                        "function_body": "    def create_detail_item_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        \"\"\"\n        Shortcut to create a DetailItem with explicit keys.\n        \"\"\"\n        kwargs.update({\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number\n        })\n        # Possibly define concurrency fallback:\n        unique_lookup = {\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number\n        }\n        return self._create_record(DetailItem, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_detail_item_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item",
                            "search_detail_item_by_keys"
                        ],
                        "docstring": null,
                        "function_body": "    def update_detail_item_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        matches = self.search_detail_item_by_keys(project_number, po_number, detail_number, line_number)\n        if not matches:\n            return None\n\n        if isinstance(matches, list):\n            match = matches[0]\n        else:\n            match = matches\n\n        detail_item_id = match[\"id\"]\n        return self.update_detail_item(detail_item_id, **kwargs)"
                    },
                    {
                        "name": "search_contacts",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_contacts(self, column_names=None, values=None):\n        self.logger.debug(f\"\ud83d\udcbc Searching Contacts with column_names={column_names}, values={values}\")\n        return self._search_records(Contact, column_names, values)"
                    },
                    {
                        "name": "create_contact",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_contact(self, **kwargs):\n        self.logger.debug(f\"\ud83d\ude4b create_contact with {kwargs}\")\n        # If 'name' is unique or 'email' is unique, define unique_lookup\n        unique_lookup = {}\n        if 'name' in kwargs:\n            unique_lookup['name'] = kwargs['name']\n        return self._create_record(Contact, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_contact",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_contact(self, contact_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udc81\u200d\u2640\ufe0f update_contact -> Contact(id={contact_id}), data={kwargs}\")\n        return self._update_record(Contact, contact_id, **kwargs)"
                    },
                    {
                        "name": "find_contact_close_match",
                        "args": [
                            "self",
                            "contact_name",
                            "all_db_contacts",
                            "cutoff"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Attempt a fuzzy name match among all_db_contacts.\nReturns a list of dicts or None.",
                        "function_body": "    def find_contact_close_match(self, contact_name: str, all_db_contacts: List[Dict[str, Any]], cutoff=0.7):\n        \"\"\"\n        Attempt a fuzzy name match among all_db_contacts.\n        Returns a list of dicts or None.\n        \"\"\"\n        from difflib import get_close_matches\n\n        if not all_db_contacts:\n            self.logger.debug(\"No existing contacts provided to match against.\")\n            return None\n\n        name_map = {c['name']: c for c in all_db_contacts if c.get('name')}\n        best_matches = get_close_matches(contact_name, name_map.keys(), n=5, cutoff=cutoff)\n        if best_matches:"
                    },
                    {
                        "name": "create_minimal_contact",
                        "args": [
                            "self",
                            "contact_name"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_contact"
                        ],
                        "docstring": "Creates a minimal Contact record with just name=contact_name, vendor_type=\"Vendor\".",
                        "function_body": "    def create_minimal_contact(self, contact_name: str):\n        \"\"\"\n        Creates a minimal Contact record with just name=contact_name, vendor_type=\"Vendor\".\n        \"\"\"\n        return self.create_contact(name=contact_name, vendor_type=\"Vendor\")"
                    },
                    {
                        "name": "search_projects",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_projects(self, column_names, values):\n        self.logger.debug(f\"\ud83c\udfd7 Searching Projects with columns={column_names}, values={values}\")\n        return self._search_records(Project, column_names, values)"
                    },
                    {
                        "name": "create_project",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_project(self, **kwargs):\n        self.logger.debug(f\"\ud83c\udfd7 create_project with {kwargs}\")\n        # If 'project_number' is unique\n        unique_lookup = {}\n        if 'project_number' in kwargs:\n            unique_lookup['project_number'] = kwargs['project_number']\n        return self._create_record(Project, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_project",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_project(self, project_id, **kwargs):\n        self.logger.debug(f\"\ud83e\udd16 update_project -> Project(id={project_id}), data={kwargs}\")\n        return self._update_record(Project, project_id, **kwargs)"
                    },
                    {
                        "name": "search_bank_transactions",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_bank_transactions(self, column_names, values):\n        self.logger.debug(f\"\ud83d\udcb0 search_bank_transactions: columns={column_names}, values={values}\")\n        return self._search_records(BankTransaction, column_names, values)"
                    },
                    {
                        "name": "create_bank_transaction",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_bank_transaction(self, **kwargs):\n        self.logger.debug(f\"\ud83d\udcb8 create_bank_transaction with {kwargs}\")\n        return self._create_record(BankTransaction, **kwargs)"
                    },
                    {
                        "name": "update_bank_transaction",
                        "args": [
                            "self",
                            "transaction_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_bank_transaction(self, transaction_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udcb8 update_bank_transaction -> BankTransaction(id={transaction_id}), data={kwargs}\")\n        return self._update_record(BankTransaction, transaction_id, **kwargs)"
                    },
                    {
                        "name": "search_bill_line_items",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_bill_line_items(self, column_names, values):\n        self.logger.debug(f\"\ud83d\udcdc search_bill_line_items: columns={column_names}, values={values}\")\n        return self._search_records(BillLineItem, column_names, values)"
                    },
                    {
                        "name": "create_bill_line_item",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_bill_line_item(self, **kwargs):\n        self.logger.debug(f\"\ud83d\udcdc create_bill_line_item with {kwargs}\")\n        unique_lookup = {}\n        # If you consider (parent_id, detail_number, line_number) unique, define it here\n        if 'parent_id' in kwargs and 'detail_number' in kwargs and 'line_number' in kwargs:\n            unique_lookup = {\n                'parent_id': kwargs['parent_id'],\n                'detail_number': kwargs['detail_number'],\n                'line_number': kwargs['line_number']\n            }\n        return self._create_record(BillLineItem, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_bill_line_item",
                        "args": [
                            "self",
                            "bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_bill_line_item(self, bill_line_item_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udcdc update_bill_line_item -> BillLineItem(id={bill_line_item_id}), data={kwargs}\")\n        return self._update_record(BillLineItem, bill_line_item_id, **kwargs)"
                    },
                    {
                        "name": "search_bill_line_item_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_bill_line_items"
                        ],
                        "docstring": "Returns BillLineItem(s) for any subset of project_number, po_number, detail_number, line_number.",
                        "function_body": "    def search_bill_line_item_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None\n    ) -> Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        \"\"\"\n        Returns BillLineItem(s) for any subset of project_number, po_number, detail_number, line_number.\n        \"\"\"\n        if not project_number and not po_number and not detail_number and not line_number:\n            return self.search_bill_line_items([], [])\n\n        col_filters = []\n        val_filters = []\n\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n        if detail_number is not None:\n            col_filters.append(\"detail_number\")\n            val_filters.append(detail_number)\n        if line_number is not None:\n            col_filters.append(\"line_number\")\n            val_filters.append(line_number)\n\n        return self.search_bill_line_items(col_filters, val_filters)"
                    },
                    {
                        "name": "create_bill_line_item_by_keys",
                        "args": [
                            "self",
                            "parent_id",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_bill_line_item_by_keys(\n        self,\n        parent_id: int,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        kwargs.update({\n            \"parent_id\": parent_id,\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number,\n        })\n        unique_lookup = {\n            \"parent_id\": parent_id,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number,\n        }\n        return self._create_record(BillLineItem, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_bill_line_item_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_bill_line_item",
                            "search_bill_line_item_by_keys"
                        ],
                        "docstring": null,
                        "function_body": "    def update_bill_line_item_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        matches = self.search_bill_line_item_by_keys(project_number, po_number, detail_number, line_number)\n        if not matches:\n            return None\n        if isinstance(matches, list):\n            match = matches[0]\n        else:\n            match = matches\n        return self.update_bill_line_item(match[\"id\"], **kwargs)"
                    },
                    {
                        "name": "search_invoices",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_invoices(self, column_names, values):\n        self.logger.debug(f\"\ud83e\uddfe search_invoices: columns={column_names}, values={values}\")\n        return self._search_records(Invoice, column_names, values)"
                    },
                    {
                        "name": "create_invoice",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_invoice(self, **kwargs):\n        self.logger.debug(f\"\ud83e\uddfe create_invoice with {kwargs}\")\n        unique_lookup = {}\n        if 'invoice_number' in kwargs:\n            unique_lookup['invoice_number'] = kwargs['invoice_number']\n        return self._create_record(Invoice, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_invoice",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_invoice(self, invoice_id, **kwargs):\n        self.logger.debug(f\"\ud83e\uddfe update_invoice -> Invoice(id={invoice_id}), data={kwargs}\")\n        return self._update_record(Invoice, invoice_id, **kwargs)"
                    },
                    {
                        "name": "search_invoice_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "invoice_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_invoices"
                        ],
                        "docstring": "Return Invoice(s) based on any subset of project_number, po_number, invoice_number.\nIf none are provided, returns ALL.",
                        "function_body": "    def search_invoice_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        invoice_number: Optional[int] = None\n    ) -> Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        \"\"\"\n        Return Invoice(s) based on any subset of project_number, po_number, invoice_number.\n        If none are provided, returns ALL.\n        \"\"\"\n        if not project_number and not po_number and not invoice_number:\n            return self.search_invoices([], [])\n\n        col_filters = []\n        val_filters = []\n\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n        if invoice_number is not None:\n            col_filters.append(\"invoice_number\")\n            val_filters.append(invoice_number)\n\n        return self.search_invoices(col_filters, val_filters)"
                    },
                    {
                        "name": "search_receipts",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_receipts(self, column_names, values):\n        self.logger.debug(f\"\ud83e\uddfe search_receipts: columns={column_names}, values={values}\")\n        return self._search_records(Receipt, column_names, values)"
                    },
                    {
                        "name": "create_receipt",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_receipt(self, **kwargs):\n        self.logger.debug(f\"\ud83e\uddfe create_receipt with {kwargs}\")\n        return self._create_record(Receipt, **kwargs)"
                    },
                    {
                        "name": "update_receipt_by_id",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_receipt_by_id(self, receipt_id, **kwargs):\n        self.logger.debug(f\"\ud83e\uddfe update_receipt_by_id -> Receipt(id={receipt_id}), data={kwargs}\")\n        return self._update_record(Receipt, receipt_id, **kwargs)"
                    },
                    {
                        "name": "search_receipt_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_receipts"
                        ],
                        "docstring": null,
                        "function_body": "    def search_receipt_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None\n    ):\n        if not project_number and not po_number and not detail_number and not line_number:\n            return self.search_receipts([], [])\n\n        col_filters = []\n        val_filters = []\n\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n        if detail_number is not None:\n            col_filters.append(\"detail_number\")\n            val_filters.append(detail_number)\n        if line_number is not None:\n            col_filters.append(\"line_number\")\n            val_filters.append(line_number)\n\n        return self.search_receipts(col_filters, val_filters)"
                    },
                    {
                        "name": "create_receipt_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_receipt"
                        ],
                        "docstring": null,
                        "function_body": "    def create_receipt_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        kwargs.update({\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number\n        })\n        return self.create_receipt(**kwargs)"
                    },
                    {
                        "name": "update_receipt_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_receipt_by_keys",
                            "update_receipt_by_id"
                        ],
                        "docstring": null,
                        "function_body": "    def update_receipt_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        recs = self.search_receipt_by_keys(project_number, po_number, detail_number, line_number)\n        if not recs:\n            return None\n        if isinstance(recs, list):\n            recs = recs[0]\n        return self.update_receipt_by_id(recs[\"id\"], **kwargs)"
                    },
                    {
                        "name": "search_spend_money",
                        "args": [
                            "self",
                            "column_names",
                            "values",
                            "deleted"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_spend_money(self, column_names, values, deleted=False):\n        self.logger.debug(\n            f\"\ud83d\udcb5 search_spend_money: columns={column_names}, values={values}, deleted={deleted}\"\n        )\n        records = self._search_records(SpendMoney, column_names, values)\n        if not records:\n            return records\n\n        # If your schema uses a 'state' of \"DELETED\", filter it out unless deleted=True\n        if not deleted:\n            if isinstance(records, dict):\n                # For a single record\n                if records.get('state') == \"DELETED\":\n                    return None\n            elif isinstance(records, list):\n                # For multiple\n                records = [rec for rec in records if rec.get('state') != \"DELETED\"]\n        return records"
                    },
                    {
                        "name": "create_spend_money",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_spend_money(self, **kwargs):\n        self.logger.debug(f\"\ud83d\udcb8 create_spend_money with {kwargs}\")\n        return self._create_record(SpendMoney, **kwargs)"
                    },
                    {
                        "name": "update_spend_money",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_spend_money(self, spend_money_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udcb8 update_spend_money -> SpendMoney(id={spend_money_id}), data={kwargs}\")\n        return self._update_record(SpendMoney, spend_money_id, **kwargs)"
                    },
                    {
                        "name": "search_spend_money_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number",
                            "deleted"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_spend_money"
                        ],
                        "docstring": null,
                        "function_body": "    def search_spend_money_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None,\n        deleted: bool = False\n    ):\n        if not project_number and not po_number and not detail_number and not line_number:\n            return self.search_spend_money([], [], deleted=deleted)\n\n        col_filters = []\n        val_filters = []\n\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n        if detail_number is not None:\n            col_filters.append(\"detail_number\")\n            val_filters.append(detail_number)\n        if line_number is not None:\n            col_filters.append(\"line_number\")\n            val_filters.append(line_number)\n\n        return self.search_spend_money(col_filters, val_filters, deleted=deleted)"
                    },
                    {
                        "name": "create_spend_money_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_spend_money_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        kwargs.update({\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number\n        })\n        # If you want concurrency fallback on (project_number, po_number, detail_number, line_number):\n        unique_lookup = {\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number,\n            \"line_number\": line_number\n        }\n        return self._create_record(SpendMoney, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_spend_money_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_spend_money",
                            "search_spend_money_by_keys"
                        ],
                        "docstring": null,
                        "function_body": "    def update_spend_money_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        line_number: int,\n        **kwargs\n    ):\n        recs = self.search_spend_money_by_keys(project_number, po_number, detail_number, line_number)\n        if not recs:\n            return None\n        if isinstance(recs, list):\n            recs = recs[0]\n        return self.update_spend_money(recs[\"id\"], **kwargs)"
                    },
                    {
                        "name": "search_tax_accounts",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_tax_accounts(self, column_names, values):\n        self.logger.debug(f\"\ud83c\udfe6 search_tax_accounts with columns={column_names}, values={values}\")\n        return self._search_records(TaxAccount, column_names, values)"
                    },
                    {
                        "name": "create_tax_account",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_tax_account(self, **kwargs):\n        self.logger.debug(f\"\ud83c\udfe6 create_tax_account with {kwargs}\")\n        return self._create_record(TaxAccount, **kwargs)"
                    },
                    {
                        "name": "update_tax_account",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_tax_account(self, tax_account_id, **kwargs):\n        self.logger.debug(f\"\ud83c\udfe6 update_tax_account -> TaxAccount(id={tax_account_id}), data={kwargs}\")\n        return self._update_record(TaxAccount, tax_account_id, **kwargs)"
                    },
                    {
                        "name": "search_xero_bills",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_xero_bills(self, column_names, values):\n        self.logger.debug(f\"\ud83c\udff7 search_xero_bills with columns={column_names}, values={values}\")\n        return self._search_records(XeroBill, column_names, values)"
                    },
                    {
                        "name": "create_xero_bill",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": "If 'xero_reference_number' is unique, we pass that as unique_lookup.",
                        "function_body": "    def create_xero_bill(self, **kwargs):\n        \"\"\"\n        If 'xero_reference_number' is unique, we pass that as unique_lookup.\n        \"\"\"\n        self.logger.debug(f\"\ud83c\udff7 create_xero_bill with {kwargs}\")\n        unique_lookup = {}\n        if 'xero_reference_number' in kwargs:\n            unique_lookup['xero_reference_number'] = kwargs['xero_reference_number']\n        return self._create_record(XeroBill, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_xero_bill",
                        "args": [
                            "self",
                            "parent_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_xero_bill(self, parent_id, **kwargs):\n        self.logger.debug(f\"\ud83c\udff7 update_xero_bill -> XeroBill(id={parent_id}), data={kwargs}\")\n        return self._update_record(XeroBill, parent_id, **kwargs)"
                    },
                    {
                        "name": "search_xero_bill_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_xero_bills"
                        ],
                        "docstring": "Returns XeroBill(s) based on any subset of project_number, po_number, detail_number.",
                        "function_body": "    def search_xero_bill_by_keys(\n        self,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None\n    ) -> Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        \"\"\"\n        Returns XeroBill(s) based on any subset of project_number, po_number, detail_number.\n        \"\"\"\n        if not project_number and not po_number and not detail_number:\n            return self.search_xero_bills([], [])\n\n        col_filters = []\n        val_filters = []\n        if project_number is not None:\n            col_filters.append(\"project_number\")\n            val_filters.append(project_number)\n        if po_number is not None:\n            col_filters.append(\"po_number\")\n            val_filters.append(po_number)\n        if detail_number is not None:\n            col_filters.append(\"detail_number\")\n            val_filters.append(detail_number)\n\n        return self.search_xero_bills(col_filters, val_filters)"
                    },
                    {
                        "name": "create_xero_bill_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_xero_bill_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        **kwargs\n    ):\n        kwargs.update({\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number\n        })\n        # If (project_number, po_number, detail_number) is effectively unique:\n        unique_lookup = {\n            \"project_number\": project_number,\n            \"po_number\": po_number,\n            \"detail_number\": detail_number\n        }\n        return self._create_record(XeroBill, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_xero_bill_by_keys",
                        "args": [
                            "self",
                            "project_number",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_xero_bill",
                            "search_xero_bill_by_keys"
                        ],
                        "docstring": null,
                        "function_body": "    def update_xero_bill_by_keys(\n        self,\n        project_number: int,\n        po_number: int,\n        detail_number: int,\n        **kwargs\n    ):\n        bills = self.search_xero_bill_by_keys(project_number, po_number, detail_number)\n        if not bills:\n            return None\n        if isinstance(bills, list):\n            bills = bills[0]\n        return self.update_xero_bill(bills[\"id\"], **kwargs)"
                    },
                    {
                        "name": "search_users",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_users(self, column_names=None, values=None):\n        self.logger.debug(f\"\ud83d\udc64 search_users: columns={column_names}, values={values}\")\n        return self._search_records(User, column_names, values)"
                    },
                    {
                        "name": "create_user",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_user(self, **kwargs):\n        self.logger.debug(f\"\ud83d\udc64 create_user with {kwargs}\")\n        # If 'username' is unique, define unique_lookup here if you like\n        unique_lookup = {}\n        # Example (uncomment if needed):\n        # if 'username' in kwargs:\n        #     unique_lookup['username'] = kwargs['username']\n        return self._create_record(User, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_user",
                        "args": [
                            "self",
                            "user_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_user(self, user_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udc64 update_user -> User(id={user_id}), data={kwargs}\")\n        return self._update_record(User, user_id, **kwargs)"
                    },
                    {
                        "name": "search_tax_ledgers",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_tax_ledgers(self, column_names=None, values=None):\n        self.logger.debug(f\"\ud83d\udcd2 search_tax_ledgers: columns={column_names}, values={values}\")\n        return self._search_records(TaxLedger, column_names, values)"
                    },
                    {
                        "name": "create_tax_ledger",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_tax_ledger(self, **kwargs):\n        self.logger.debug(f\"\ud83d\udcd2 create_tax_ledger with {kwargs}\")\n        # If 'name' is unique or anything else, define unique_lookup\n        unique_lookup = {}\n        return self._create_record(TaxLedger, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_tax_ledger",
                        "args": [
                            "self",
                            "ledger_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_tax_ledger(self, ledger_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udcd2 update_tax_ledger -> TaxLedger(id={ledger_id}), data={kwargs}\")\n        return self._update_record(TaxLedger, ledger_id, **kwargs)"
                    },
                    {
                        "name": "search_budget_maps",
                        "args": [
                            "self",
                            "column_names",
                            "values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_search_records"
                        ],
                        "docstring": null,
                        "function_body": "    def search_budget_maps(self, column_names=None, values=None):\n        self.logger.debug(f\"\ud83d\udcca search_budget_maps: columns={column_names}, values={values}\")\n        return self._search_records(BudgetMap, column_names, values)"
                    },
                    {
                        "name": "create_budget_map",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_create_record"
                        ],
                        "docstring": null,
                        "function_body": "    def create_budget_map(self, **kwargs):\n        self.logger.debug(f\"\ud83d\udcca create_budget_map with {kwargs}\")\n        # If 'map_name' is unique or anything else, define unique_lookup\n        unique_lookup = {}\n        return self._create_record(BudgetMap, unique_lookup=unique_lookup, **kwargs)"
                    },
                    {
                        "name": "update_budget_map",
                        "args": [
                            "self",
                            "map_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_update_record"
                        ],
                        "docstring": null,
                        "function_body": "    def update_budget_map(self, map_id, **kwargs):\n        self.logger.debug(f\"\ud83d\udcca update_budget_map -> BudgetMap(id={map_id}), data={kwargs}\")\n        return self._update_record(BudgetMap, map_id, **kwargs)"
                    },
                    {
                        "name": "_has_changes_for_record",
                        "args": [
                            "self",
                            "model",
                            "record_id",
                            "unique_filters"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session",
                            "_serialize_record",
                            "_search_records"
                        ],
                        "docstring": "Checks whether a record of a given model has changed.\n1) If record_id is provided, we fetch by ID.\n2) Else if unique_filters is provided, we attempt a lookup with those filters.\n3) Compare each kwarg to the record\u2019s fields.\n4) Return True if any difference is found, otherwise False.\n\nSpecial logic:\n  - For 'state', do a case-insensitive comparison. Adjust as needed.",
                        "function_body": "    def _has_changes_for_record(\n        self,\n        model,\n        record_id: Optional[int] = None,\n        unique_filters: Dict[str, Any] = None,\n        **kwargs\n    ) -> bool:\n        \"\"\"\n        Checks whether a record of a given model has changed.\n        1) If record_id is provided, we fetch by ID.\n        2) Else if unique_filters is provided, we attempt a lookup with those filters.\n        3) Compare each kwarg to the record\u2019s fields.\n        4) Return True if any difference is found, otherwise False.\n\n        Special logic:\n          - For 'state', do a case-insensitive comparison. Adjust as needed.\n        \"\"\"\n        if not record_id and not unique_filters:\n            self.logger.warning(\n                f\"Cannot check changes for {model.__name__}, neither record_id nor unique_filters given.\"\n            )\n            return False\n\n        # Step A: Locate the record\n        record_dict = None\n\n        if record_id:\n            # Fetch by primary key\n            with get_db_session() as session:\n                record = session.query(model).get(record_id)\n                if record:\n                    record_dict = self._serialize_record(record)\n        else:\n            # Fetch by unique filters\n            filters_list = list(unique_filters.keys())\n            values_list = list(unique_filters.values())\n            found = self._search_records(model, filters_list, values_list)\n\n            # If exactly one match, store its dict\n            if isinstance(found, dict):\n                record_dict = found\n            elif isinstance(found, list) and len(found) == 1:\n                record_dict = found[0]\n\n        if not record_dict:\n            self.logger.debug(\n                f\"No single {model.__name__} record found to compare. Returning False.\"\n            )\n            return False\n\n        # Step B: Compare each kwarg to what is in record_dict\n        for field, new_val in kwargs.items():\n            old_val = record_dict.get(field)\n\n            # Optional case-insensitive compare for \"state\"\n            if field == \"state\":\n                old_val = (old_val or \"\").upper()\n                new_val = (new_val or \"\").upper()\n\n            if old_val != new_val:\n                return True\n\n        return False"
                    },
                    {
                        "name": "purchase_order_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": "Check if a PurchaseOrder has changed. Provide either:\n  - record_id, OR\n  - (project_number, po_number).",
                        "function_body": "    def purchase_order_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        **kwargs\n    ) -> bool:\n        \"\"\"\n        Check if a PurchaseOrder has changed. Provide either:\n          - record_id, OR\n          - (project_number, po_number).\n        \"\"\"\n        unique_filters = {}\n        if project_number is not None:\n            unique_filters[\"project_number\"] = project_number\n        if po_number is not None:\n            unique_filters[\"po_number\"] = po_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "detail_item_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": "Check if a DetailItem has changed. Provide either:\n  - record_id, OR\n  - (project_number, po_number, detail_number, line_number).",
                        "function_body": "    def detail_item_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None,\n        **kwargs\n    ) -> bool:\n        \"\"\"\n        Check if a DetailItem has changed. Provide either:\n          - record_id, OR\n          - (project_number, po_number, detail_number, line_number).\n        \"\"\"\n        unique_filters = {}\n        if project_number is not None:\n            unique_filters[\"project_number\"] = project_number\n        if po_number is not None:\n            unique_filters[\"po_number\"] = po_number\n        if detail_number is not None:\n            unique_filters[\"detail_number\"] = detail_number\n        if line_number is not None:\n            unique_filters[\"line_number\"] = line_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "contact_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "name",
                            "email"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": "If Contact is uniquely identified by 'name', or by 'email', or by record_id.\nAdjust as needed for your schema.",
                        "function_body": "    def contact_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        name: Optional[str] = None,\n        email: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        \"\"\"\n        If Contact is uniquely identified by 'name', or by 'email', or by record_id.\n        Adjust as needed for your schema.\n        \"\"\"\n        unique_filters = {}\n        if name is not None:\n            unique_filters[\"name\"] = name\n        if email is not None:\n            unique_filters[\"email\"] = email\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "project_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def project_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        project_number: Optional[int] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if project_number is not None:\n            unique_filters[\"project_number\"] = project_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "bank_transaction_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "transaction_id_xero"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": "Example: If your BankTransaction is uniquely identified by some external ID,\npass it in, else use the record_id. Adjust as needed.",
                        "function_body": "    def bank_transaction_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        transaction_id_xero: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        \"\"\"\n        Example: If your BankTransaction is uniquely identified by some external ID,\n        pass it in, else use the record_id. Adjust as needed.\n        \"\"\"\n        unique_filters = {}\n        if transaction_id_xero is not None:\n            unique_filters[\"transaction_id_xero\"] = transaction_id_xero\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "bill_line_item_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "parent_id",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def bill_line_item_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        parent_id: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if parent_id is not None:\n            unique_filters[\"parent_id\"] = parent_id\n        if detail_number is not None:\n            unique_filters[\"detail_number\"] = detail_number\n        if line_number is not None:\n            unique_filters[\"line_number\"] = line_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "invoice_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "invoice_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def invoice_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        invoice_number: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if invoice_number is not None:\n            unique_filters[\"invoice_number\"] = invoice_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "receipt_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def receipt_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if project_number is not None:\n            unique_filters[\"project_number\"] = project_number\n        if po_number is not None:\n            unique_filters[\"po_number\"] = po_number\n        if detail_number is not None:\n            unique_filters[\"detail_number\"] = detail_number\n        if line_number is not None:\n            unique_filters[\"line_number\"] = line_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "spend_money_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "project_number",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def spend_money_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        project_number: Optional[int] = None,\n        po_number: Optional[int] = None,\n        detail_number: Optional[int] = None,\n        line_number: Optional[int] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if project_number is not None:\n            unique_filters[\"project_number\"] = project_number\n        if po_number is not None:\n            unique_filters[\"po_number\"] = po_number\n        if detail_number is not None:\n            unique_filters[\"detail_number\"] = detail_number\n        if line_number is not None:\n            unique_filters[\"line_number\"] = line_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "tax_account_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "tax_code"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def tax_account_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        tax_code: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if tax_code is not None:\n            unique_filters[\"tax_code\"] = tax_code\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "xero_bill_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "xero_reference_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def xero_bill_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        xero_reference_number: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if xero_reference_number is not None:\n            unique_filters[\"xero_reference_number\"] = xero_reference_number\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "user_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "username"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def user_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        username: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if username is not None:\n            unique_filters[\"username\"] = username\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "tax_ledger_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def tax_ledger_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        name: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if name is not None:\n            unique_filters[\"name\"] = name\n\n        return self._has_changes_for_record("
                    },
                    {
                        "name": "budget_map_has_changes",
                        "args": [
                            "self",
                            "record_id",
                            "map_name"
                        ],
                        "decorators": [],
                        "calls": [
                            "_has_changes_for_record"
                        ],
                        "docstring": null,
                        "function_body": "    def budget_map_has_changes(\n        self,\n        record_id: Optional[int] = None,\n        map_name: Optional[str] = None,\n        **kwargs\n    ) -> bool:\n        unique_filters = {}\n        if map_name is not None:\n            unique_filters[\"map_name\"] = map_name\n\n        return self._has_changes_for_record("
                    }
                ],
                "decorators": []
            }
        ],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/utils.py",
        "functions": [
            {
                "name": "get_po_state",
                "args": [
                    "item_id"
                ],
                "decorators": [],
                "calls": [
                    "get_db_session"
                ],
                "docstring": "Gets the current state of a PO.",
                "function_body": "def get_po_state(item_id):\n    \"\"\"\n    Gets the current state of a PO.\n    \"\"\"\n    try:"
            },
            {
                "name": "extract_url",
                "args": [
                    "column_values",
                    "target_id"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Safely extracts the URL from the 'value' field of a column.\n\nParameters:\n- column_values (dict): Dictionary of column values.\n- target_id (str): The ID of the target column.\n\nReturns:\n- str: Extracted URL or None if not available.",
                "function_body": "def extract_url(column_values, target_id):\n    \"\"\"\n    Safely extracts the URL from the 'value' field of a column.\n\n    Parameters:\n    - column_values (dict): Dictionary of column values.\n    - target_id (str): The ID of the target column.\n\n    Returns:\n    - str: Extracted URL or None if not available.\n    \"\"\"\n    value = column_values.get(target_id, {}).get(\"value\")\n    if value:\n        try:\n            # print(f\"Parsing value for {target_id}: {value}\")  # Debugging log\n            parsed_value = json.loads(value)\n            # print(parsed_value.get(\"url\"))\n            return parsed_value.get(\"url\")\n        except (json.JSONDecodeError, TypeError) as e:\n            # print(f\"Error parsing JSON for {target_id}: {e}\")\n            return None\n    # else:\n        # print(f\"No value found for {target_id}\")\n    return None"
            },
            {
                "name": "parse_float",
                "args": [
                    "value"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Safely converts a string to a float.\n\nParameters:\n- value (str): The string to convert.\n\nReturns:\n- float: The converted float or None if conversion fails.",
                "function_body": "def parse_float(value):\n    \"\"\"\n    Safely converts a string to a float.\n\n    Parameters:\n    - value (str): The string to convert.\n\n    Returns:\n    - float: The converted float or None if conversion fails.\n    \"\"\"\n    try:"
            },
            {
                "name": "map_event_to_update_data",
                "args": [
                    "event"
                ],
                "decorators": [],
                "calls": [
                    "get_sub_item_column_mapping",
                    "parse_float",
                    "extract_text"
                ],
                "docstring": "Maps the event data to the fields that need to be updated in the DetailItem.",
                "function_body": "def map_event_to_update_data(event):\n    \"\"\"\n    Maps the event data to the fields that need to be updated in the DetailItem.\n    \"\"\"\n    column_id = event.get('columnId')\n    if not column_id:\n        logger.error(\"Missing 'columnId' in the event.\")\n        return None, \"Missing 'columnId' in the event.\"\n\n    column_mapping = get_sub_item_column_mapping()\n    field_name = column_mapping.get(column_id)\n\n    if not field_name:\n        logger.warning(f\"No mapping found for column ID: {column_id}\")\n        return None, f\"No mapping found for column ID: {column_id}\"\n\n    # Extract the new value based on columnType\n    new_value = extract_text(event)\n\n    # Handle special parsing based on the field type\n    if column_id in [SUBITEM_RATE_COLUMN_ID, SUBITEM_QUANTITY_COLUMN_ID]:\n        parsed_value = parse_float(new_value)\n    elif column_id == \"link\":\n        parsed_value = new_value  # Already extracted URL\n    else:\n        parsed_value = new_value\n\n    update_data = {field_name: parsed_value}\n    # logger.debug(f\"Mapped update data: {update_data}\")\n    return update_data, None"
            },
            {
                "name": "get_sub_item_column_mapping",
                "args": [],
                "decorators": [],
                "calls": [],
                "docstring": "Returns a mapping from column IDs to DetailItem model fields.\nUpdate this mapping based on your actual column IDs and model fields.",
                "function_body": "def get_sub_item_column_mapping():\n    \"\"\"\n    Returns a mapping from column IDs to DetailItem model fields.\n    Update this mapping based on your actual column IDs and model fields.\n    \"\"\"\n    return {"
            },
            {
                "name": "extract_text",
                "args": [
                    "event"
                ],
                "decorators": [],
                "calls": [
                    "extract_url"
                ],
                "docstring": "Extracts the text value based on columnType.\nReturns None if the value is empty or None.",
                "function_body": "def extract_text(event):\n    \"\"\"\n    Extracts the text value based on columnType.\n    Returns None if the value is empty or None.\n    \"\"\"\n    column_type = event.get('columnType')\n    value_field = event.get('value', {})\n\n    if column_type == 'color':"
            },
            {
                "name": "validate_numeric_field",
                "args": [
                    "value",
                    "field_name"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def validate_numeric_field(value, field_name):\n    try:"
            },
            {
                "name": "parse_transaction_date",
                "args": [
                    "date_str"
                ],
                "decorators": [],
                "calls": [],
                "docstring": null,
                "function_body": "def parse_transaction_date(date_str):\n    logger.debug(f\"Parsing transaction_date: '{date_str}'\")\n    try:"
            },
            {
                "name": "extract_detail_item_id",
                "args": [
                    "raw_id"
                ],
                "decorators": [],
                "calls": [],
                "docstring": "Extracts the last two digits from a detail_item_id string and strips leading zeros.\n\nParameters:\n    raw_id (str): The raw detail_item_id string (e.g., '2516_03_02').\n\nReturns:\n    int: The processed detail_item_id (e.g., 2).",
                "function_body": "def extract_detail_item_id(raw_id):\n    \"\"\"\n    Extracts the last two digits from a detail_item_id string and strips leading zeros.\n\n    Parameters:\n        raw_id (str): The raw detail_item_id string (e.g., '2516_03_02').\n\n    Returns:\n        int: The processed detail_item_id (e.g., 2).\n    \"\"\"\n    if not raw_id:\n        logger.warning(\"Empty detail_item_id received. Defaulting to 1.\")\n        return 1  # Default value if raw_id is empty or None\n\n    try:"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger(__name__)"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/account_code_loader.py",
        "functions": [
            {
                "name": "update_account_codes",
                "args": [
                    "file_path"
                ],
                "decorators": [],
                "calls": [
                    "get_db_session"
                ],
                "docstring": "Updates the `account_codes` table using data from the specified file.\n\nArgs:\n    file_path (str): Path to the file containing ACCOUNT codes and descriptions.",
                "function_body": "def update_account_codes(file_path):\n    \"\"\"\n    Updates the `account_codes` table using data from the specified file.\n\n    Args:\n        file_path (str): Path to the file containing ACCOUNT codes and descriptions.\n    \"\"\"\n    try:"
            }
        ],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/database/base.py",
        "functions": [],
        "classes": [],
        "variables": [
            {
                "name": "Base",
                "value": "declarative_base()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/xero_auth.py",
        "functions": [
            {
                "name": "index",
                "args": [],
                "decorators": [
                    "app.route('/')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def index():\n    return ("
            },
            {
                "name": "start_xero_auth",
                "args": [],
                "decorators": [
                    "app.route('/start_xero_auth')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def start_xero_auth():\n    credentials = OAuth2Credentials(\n        client_id=CLIENT_ID,\n        client_secret=CLIENT_SECRET,\n        callback_uri=CALLBACK_URI,\n        scope=DEFAULT_SCOPES,\n    )\n    authorization_url = credentials.generate_url()\n    # Store credentials.state in session so we can re-build it in callback\n    session[\"xero_creds_state\"] = credentials.state\n    logger.info(\"Redirecting user to Xero authorization URL.\")\n    return redirect(authorization_url)"
            },
            {
                "name": "xero_callback",
                "args": [],
                "decorators": [
                    "app.route('/xero_callback')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def xero_callback():\n    cred_state = session.get(\"xero_creds_state\")\n    if not cred_state:\n        return make_response(\"No Xero credential state found. Please start auth again.\", 400)\n\n    # Rebuild the credentials from the stored state\n    credentials = OAuth2Credentials(**cred_state)\n\n    # The full URL (including ?code=..., scope=..., state=...)\n    full_request_uri = request.url\n\n    # Verify and exchange authorization code for tokens\n    credentials.verify(full_request_uri)\n    logger.info(\"Successfully verified tokens with Xero.\")\n    credentials.set_default_tenant()\n\n    # Update session with any new token details\n    session[\"xero_creds_state\"] = credentials.state\n\n    # --- NEW: Save updated token values to .env ---\n    token_data = credentials.token\n    logger.info(\"Saving tokens to .env file...\")\n    set_key(\"../.env\", \"XERO_ACCESS_TOKEN\", token_data.get(\"access_token\", \"\"))\n    set_key(\"../.env\", \"XERO_REFRESH_TOKEN\", token_data.get(\"refresh_token\", \"\"))\n\n    logger.info(\"Tenant set. Tokens verified, stored in .env, and ready to use!\")\n    return ("
            },
            {
                "name": "xero_api",
                "args": [],
                "decorators": [
                    "app.route('/xero_api')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def xero_api():\n    cred_state = session.get(\"xero_creds_state\")\n    if not cred_state:\n        return make_response(\"No Xero creds. Please reauthorize first!\", 400)\n\n    credentials = OAuth2Credentials(**cred_state)\n    if credentials.expired():\n        logger.debug(\"Token expired; refreshing now...\")\n        credentials.refresh()\n        session[\"xero_creds_state\"] = credentials.state\n\n        # Also update tokens in .env each time a refresh happens\n        token_data = credentials.token\n        logger.info(\"Refreshed tokens. Saving to .env file...\")\n        set_key(\"../.env\", \"XERO_ACCESS_TOKEN\", token_data.get(\"access_token\", \"\"))\n        set_key(\"../.env\", \"XERO_REFRESH_TOKEN\", token_data.get(\"refresh_token\", \"\"))\n    else:\n        logger.info(\"CREDENTIALS ARE FINE\")\n\n    xero_client = Xero(credentials)\n    return ("
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('xero_logger')"
            },
            {
                "name": "app",
                "value": "Flask(__name__)"
            },
            {
                "name": "CLIENT_ID",
                "value": "os.getenv('XERO_CLIENT_ID', 'YOUR_CLIENT_ID')"
            },
            {
                "name": "CLIENT_SECRET",
                "value": "os.getenv('XERO_CLIENT_SECRET', 'YOUR_CLIENT_SECRET')"
            },
            {
                "name": "CALLBACK_URI",
                "value": "'http://localhost:5002/xero_callback'"
            },
            {
                "name": "DEFAULT_SCOPES",
                "value": "[XeroScopes.OFFLINE_ACCESS, XeroScopes.ACCOUNTING_TRANSACTIONS, XeroScopes.ACCOUNTING_SETTINGS, XeroScopes.ACCOUNTING_CONTACTS]"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/xero_api.py",
        "functions": [],
        "classes": [
            {
                "name": "XeroAPI",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": "Initialize XeroAPI with environment variables and set up the Xero client.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        Initialize XeroAPI with environment variables and set up the Xero client.\n        \"\"\"\n        # Load environment variables\n        try:\n            load_dotenv(os.path.join(os.path.dirname(__file__), \"..\", \".env\"))\n        except Exception as e:\n            # Log an error but continue (maybe no .env file)\n            logging.getLogger(\"xero_logger\").error(f\"\ud83d\udea8 Could not load .env: {e}\")\n\n        self.client_id = os.getenv(\"XERO_CLIENT_ID\")\n        self.client_secret = os.getenv(\"XERO_CLIENT_SECRET\")\n        self.access_token = os.getenv(\"XERO_ACCESS_TOKEN\")\n        self.refresh_token = os.getenv(\"XERO_REFRESH_TOKEN\")\n        self.tenant_id = os.getenv(\"XERO_TENANT_ID\")\n\n        # Default scope if not specified in env\n        self.scope = (\n            os.getenv(\"XERO_SCOPE\")\n            or \"accounting.contacts accounting.settings accounting.transactions offline_access\"\n        )\n\n        # Setup logging\n        self.logger = logging.getLogger(\"xero_logger\")\n        self.logger.setLevel(logging.DEBUG)  # Make sure we're logging at debug level\n\n        # Build our initial token dict from environment\n        current_time = time.time()\n        default_expires_in = 1800  # 30 minutes, adjust as needed\n        token_dict = {\n            \"access_token\": self.access_token,\n            \"refresh_token\": self.refresh_token,\n            \"expires_in\": default_expires_in,\n            \"expires_at\": current_time + default_expires_in,  # Avoid KeyError\n            \"token_type\": \"Bearer\",\n            \"scope\": self.scope.split(),  # Convert space-delimited string into list\n        }\n\n        # region \ud83d\udd12 Create OAuth2Credentials\n        self.credentials = OAuth2Credentials(\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scope=self.scope.split(),\n            token=token_dict,\n        )\n\n        if self.tenant_id:\n            self.credentials.tenant_id = self.tenant_id\n\n        # Create the Xero client\n        self.xero = Xero(self.credentials)\n\n        # Force an initial refresh check so we can set the tenant if not yet set\n        self._refresh_token_if_needed()\n\n        self.logger.info(\"\ud83d\ude80 XeroAPI (PyXero) initialized successfully!\")\n        self._initialized = True"
                    },
                    {
                        "name": "_refresh_token_if_needed",
                        "args": [
                            "self",
                            "force"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Refresh the Xero token if it\u2019s expired or about to expire.\nIf 'force=True', we attempt a refresh no matter what.",
                        "function_body": "    def _refresh_token_if_needed(self, force=False):\n        \"\"\"\n        Refresh the Xero token if it\u2019s expired or about to expire.\n        If 'force=True', we attempt a refresh no matter what.\n        \"\"\"\n        # If not forcing, only refresh if credentials show expired\n        if not force and not self.credentials.expired():\n            self.logger.debug(\"\ud83d\udd11 Token is still valid, no refresh necessary.\")\n            return\n\n        try:"
                    },
                    {
                        "name": "_retry_on_unauthorized",
                        "args": [
                            "self",
                            "func"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": "Helper method to call a PyXero function with retries if:\n - XeroUnauthorized occurs (token expired/invalid),\n - XeroRateLimitExceeded occurs (429 rate limit), or\n - other XeroExceptions that might be recoverable.\nWe will retry up to three times, sleeping between retries on rate limits.",
                        "function_body": "    def _retry_on_unauthorized(self, func, *args, **kwargs):\n        \"\"\"\n        Helper method to call a PyXero function with retries if:\n         - XeroUnauthorized occurs (token expired/invalid),\n         - XeroRateLimitExceeded occurs (429 rate limit), or\n         - other XeroExceptions that might be recoverable.\n        We will retry up to three times, sleeping between retries on rate limits.\n        \"\"\"\n        max_retries = 3\n        for attempt in range(1, max_retries + 1):\n            try:\n                self.logger.debug(f\"\ud83d\udd04 Attempting Xero API call (attempt {attempt}) => {func.__name__}\")\n                return func(*args, **kwargs)\n            except XeroUnauthorized:\n                self.logger.warning(\"\u26a0\ufe0f XeroUnauthorized caught mid-operation, attempting a force-refresh...\")\n                self._refresh_token_if_needed(force=True)\n            except XeroRateLimitExceeded:\n                self.logger.warning(\n                    f\"\ud83d\udd03 Rate limit hit. Attempt {attempt} of {max_retries}. \"\n                    f\"Sleeping for 65 seconds before retry...\"\n                )\n                time.sleep(65)\n            except XeroException as e:\n                self.logger.error(f\"\u274c XeroException occurred: {str(e)}\")\n                # Could raise or keep trying, depends on the logic you want.\n                # We'll bail out here if it's not Unauthorized or RateLimit.\n                raise e\n\n        # If we exhaust all retries (e.g., repeated 429 or 401 issues)\n        self.logger.error(\"\u274c Failed to call Xero API after multiple retry attempts.\")\n        return None"
                    },
                    {
                        "name": "_get_tax_code_for_detail_item",
                        "args": [
                            "self",
                            "session",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieve the tax code from the DB (AccountCode -> TaxAccount).\nFalls back to \"TAX001\" if anything goes wrong or if not found.",
                        "function_body": "    def _get_tax_code_for_detail_item(self, session, detail_item: DetailItem) -> str:\n        \"\"\"\n        Retrieve the tax code from the DB (AccountCode -> TaxAccount).\n        Falls back to \"TAX001\" if anything goes wrong or if not found.\n        \"\"\"\n        tax_code = \"TAX001\"  # fallback\n        try:\n            account_code_record = (\n                session.query(AccountCode).filter_by(id=detail_item.account_code_id).first()\n            )\n            if account_code_record and account_code_record.tax_account:\n                tax_code = account_code_record.tax_account.tax_code\n        except Exception as e:\n            self.logger.warning(\n                f\"\u26a0\ufe0f Error retrieving tax code for DetailItem ID {detail_item.id}: {str(e)}\"\n            )\n        return tax_code"
                    },
                    {
                        "name": "_convert_detail_item_to_line_item",
                        "args": [
                            "self",
                            "session",
                            "detail_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "_get_tax_code_for_detail_item"
                        ],
                        "docstring": "Convert a DetailItem record to a line item dict suitable for PyXero's bankTransactions or invoices.",
                        "function_body": "    def _convert_detail_item_to_line_item(self, session, detail_item: DetailItem) -> dict:\n        \"\"\"\n        Convert a DetailItem record to a line item dict suitable for PyXero's bankTransactions or invoices.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "create_spend_money",
                        "args": [
                            "self",
                            "session",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_convert_detail_item_to_line_item",
                            "_create_voided_spend_money",
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Create a SPEND bank transaction in Xero based on a local DetailItem.",
                        "function_body": "    def create_spend_money(self, session, detail_item_id: int):\n        \"\"\"\n        Create a SPEND bank transaction in Xero based on a local DetailItem.\n        \"\"\"\n        self._refresh_token_if_needed()\n\n        try:\n            detail_item = session.query(DetailItem).get(detail_item_id)\n        except Exception as e:\n            self.logger.error(f\"\u274c DB error retrieving DetailItem(id={detail_item_id}): {str(e)}\")\n            detail_item = None\n\n        if not detail_item:\n            self.logger.info(\n                f\"\ud83d\uddd2\ufe0f Detail item not found for ID {detail_item_id}, creating VOIDED spend money record.\"\n            )\n            return self._create_voided_spend_money()\n\n        # Decide on the Xero status\n        if detail_item.state == \"SUBMITTED\":\n            xero_status = \"DRAFT\"\n        elif detail_item.state == \"REVIEWED\":\n            xero_status = \"AUTHORISED\"\n        else:\n            xero_status = \"VOIDED\"\n\n        # Build the bankTransaction dict for PyXero\n        try:"
                    },
                    {
                        "name": "update_spend_money",
                        "args": [
                            "self",
                            "session",
                            "xero_spend_money_id",
                            "new_state"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Update an existing spend money transaction's status in Xero.",
                        "function_body": "    def update_spend_money(self, session, xero_spend_money_id: str, new_state: str):\n        \"\"\"\n        Update an existing spend money transaction's status in Xero.\n        \"\"\"\n        self._refresh_token_if_needed()\n        self.logger.info(f\"\ud83d\udd04 Updating spend money transaction {xero_spend_money_id} to {new_state}...\")\n\n        try:"
                    },
                    {
                        "name": "_create_voided_spend_money",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Helper to create a 'VOIDED' spend money transaction in Xero\nwhen the detail item is missing or otherwise invalid.",
                        "function_body": "    def _create_voided_spend_money(self):\n        \"\"\"\n        Helper to create a 'VOIDED' spend money transaction in Xero\n        when the detail item is missing or otherwise invalid.\n        \"\"\"\n        voided_transaction = {\n            \"Type\": \"SPEND\",\n            \"Contact\": {\"Name\": \"Unknown Vendor\"},\n            \"LineItems\": [],\n            \"Status\": \"VOIDED\"\n        }\n        try:"
                    },
                    {
                        "name": "create_bill",
                        "args": [
                            "self",
                            "session",
                            "project_id",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_convert_detail_item_to_line_item",
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Create a Bill (Invoice type='ACCPAY') in Xero for a specific project/PO/detail combo.",
                        "function_body": "    def create_bill(self, session, project_id: int, po_number: int, detail_number: int):\n        \"\"\"\n        Create a Bill (Invoice type='ACCPAY') in Xero for a specific project/PO/detail combo.\n        \"\"\"\n        self._refresh_token_if_needed()\n\n        try:\n            detail_items = (\n                session.query(DetailItem)\n                .filter(DetailItem.line_number == detail_number)\n                .all()\n            )\n        except Exception as e:\n            self.logger.error(f\"\u274c DB error loading DetailItems (detail_number={detail_number}): {str(e)}\")\n            detail_items = []\n\n        if not detail_items:\n            self.logger.warning(\"\u26a0\ufe0f No detail items found; creating empty Bill.\")\n            detail_items = []\n\n        xero_line_items = []\n        for di in detail_items:\n            try:\n                xero_line_items.append(self._convert_detail_item_to_line_item(session, di))\n            except Exception as ex:\n                self.logger.error(f\"\ud83d\udca5 Error converting a detail_item to line_item: {str(ex)}\")\n\n        # Determine Bill's status from detail items\n        states = {di.state for di in detail_items}\n        if len(states) == 1:\n            only_state = list(states)[0]\n            if only_state == \"SUBMITTED\":\n                xero_status = \"DRAFT\"\n            elif only_state == \"RTP\":\n                xero_status = \"SUBMITTED\"\n            elif only_state == \"PAID\":\n                xero_status = \"PAID\"\n            else:\n                xero_status = \"DRAFT\"\n        else:\n            xero_status = \"DRAFT\"\n\n        reference = f\"{project_id}_{po_number}_{detail_number}\"\n\n        new_invoice = {\n            \"Type\": \"ACCPAY\",\n            \"Contact\": {\"Name\": \"Vendor Name Placeholder\"},\n            \"LineItems\": xero_line_items,\n            \"Reference\": reference,\n            \"Status\": xero_status\n        }\n\n        self.logger.info(f\"\ud83d\udcbc Creating Xero bill for reference {reference}...\")\n\n        try:"
                    },
                    {
                        "name": "update_bill_status",
                        "args": [
                            "self",
                            "invoice_id",
                            "new_status"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Update the status of an existing Bill (ACCPAY Invoice) in Xero.",
                        "function_body": "    def update_bill_status(self, invoice_id: str, new_status: str):\n        \"\"\"\n        Update the status of an existing Bill (ACCPAY Invoice) in Xero.\n        \"\"\"\n        self._refresh_token_if_needed()\n        self.logger.info(f\"\ud83d\udd04 Updating bill (invoice_id={invoice_id}) to status {new_status}...\")\n\n        try:"
                    },
                    {
                        "name": "get_all_bills",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Retrieve all Invoices from Xero of Type='ACCPAY' -- including line items.\nExcluding any with Status == \"DELETED\".",
                        "function_body": "    def get_all_bills(self):\n        \"\"\"\n        Retrieve all Invoices from Xero of Type='ACCPAY' -- including line items.\n        Excluding any with Status == \"DELETED\".\n        \"\"\"\n        self._refresh_token_if_needed()\n\n        self.logger.info(\"\ud83d\udcc4 Retrieving all ACCPAY invoices from Xero (paging + individual fetch).\")\n\n        all_invoices_summary = []\n        page_number = 1\n        page_size = 100  # Xero returns up to 100 invoices per page by default\n\n        # Step 1: Collect a summary list of all ACCPAY invoices\n        while True:\n            self.logger.debug(f\"\ud83d\udd0e Fetching page {page_number} of ACCPAY invoice summaries...\")\n            filter_str = 'Type==\"ACCPAY\"'\n            invoices_page = self._retry_on_unauthorized(\n                self.xero.invoices.filter,\n                raw=filter_str,\n                page=page_number\n            )\n            if not invoices_page:\n                self.logger.debug(f\"\u23f9\ufe0f No invoices found on page {page_number}. Stopping.\")\n                break\n\n            all_invoices_summary.extend(invoices_page)\n            self.logger.debug(f\"\u2705 Retrieved {len(invoices_page)} invoice(s) on page {page_number}.\")\n\n            if len(invoices_page) < page_size:\n                break\n            page_number += 1\n\n        if not all_invoices_summary:\n            self.logger.info(\"\u2139\ufe0f No ACCPAY invoices found in Xero at all.\")\n            return []\n\n        self.logger.info(\n            f\"\ud83d\udd0e Fetched {len(all_invoices_summary)} ACCPAY invoice summaries. Now retrieving full details...\"\n        )\n\n        # Step 2: For each invoice in the summary, retrieve the full invoice by ID\n        detailed_invoices = []\n        for summary_inv in all_invoices_summary:\n            if summary_inv.get(\"Status\") == \"DELETED\":\n                self.logger.debug(f\"\u23e9 Skipping DELETED invoice {summary_inv.get('InvoiceID')}\")\n                continue\n\n            invoice_id = summary_inv.get(\"InvoiceID\")\n            if not invoice_id:\n                self.logger.warning(\"\u26a0\ufe0f Invoice summary is missing InvoiceID; skipping.\")\n                continue\n\n            full_inv_list = self._retry_on_unauthorized(self.xero.invoices.get, invoice_id)\n            if not full_inv_list:\n                self.logger.warning(f\"\u26a0\ufe0f No detailed invoice found for InvoiceID={invoice_id}; skipping.\")\n                continue\n\n            detailed_inv = full_inv_list[0]\n            if detailed_inv.get(\"Status\") == \"DELETED\":\n                self.logger.debug(f\"\u23e9 Skipping DELETED invoice detail {invoice_id}.\")\n                continue\n\n            detailed_invoices.append(detailed_inv)\n\n        self.logger.info(\n            f\"\u2705 Finished retrieving {len(detailed_invoices)} detailed ACCPAY invoices (excluding DELETED).\"\n        )\n        return detailed_invoices"
                    },
                    {
                        "name": "get_acpay_invoices_summary_by_ref",
                        "args": [
                            "self",
                            "reference_substring"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Retrieves a *summary* of ACCPAY (bills) from Xero whose InvoiceNumber\nor Reference contains the given substring. Does NOT include line items.\nExcludes any with Status == \"DELETED\".",
                        "function_body": "    def get_acpay_invoices_summary_by_ref(self, reference_substring: str) -> list:\n        \"\"\"\n        Retrieves a *summary* of ACCPAY (bills) from Xero whose InvoiceNumber\n        or Reference contains the given substring. Does NOT include line items.\n        Excludes any with Status == \"DELETED\".\n        \"\"\"\n        self._refresh_token_if_needed()\n        raw_filter = f'Type==\"ACCPAY\" AND InvoiceNumber!=null && InvoiceNumber.Contains(\"{reference_substring}\")'\n        self.logger.info(\n            f\"\ud83d\udd0e Fetching summary for ACCPAY invoices that match '{reference_substring}' in InvoiceNumber.\"\n        )\n\n        page_number = 1\n        page_size = 100\n        all_summaries = []\n\n        while True:\n            self.logger.debug(f\"\ud83d\udd0d Requesting page {page_number} with filter: {raw_filter}\")\n            current_page = self._retry_on_unauthorized(\n                self.xero.invoices.filter,\n                raw=raw_filter,\n                page=page_number\n            )\n            if not current_page:\n                break\n\n            filtered_page = [inv for inv in current_page if inv.get(\"Status\") != \"DELETED\"]\n            all_summaries.extend(filtered_page)\n\n            if len(current_page) < page_size:\n                break\n            page_number += 1\n\n        self.logger.info(f\"\u2705 Found {len(all_summaries)} ACCPAY invoice summaries (excluding DELETED).\")\n        return all_summaries"
                    },
                    {
                        "name": "get_invoice_details",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Retrieves the *full* invoice with line items by InvoiceID.\nReturns a single invoice dict if found and not DELETED; otherwise None.",
                        "function_body": "    def get_invoice_details(self, invoice_id: str) -> dict:\n        \"\"\"\n        Retrieves the *full* invoice with line items by InvoiceID.\n        Returns a single invoice dict if found and not DELETED; otherwise None.\n        \"\"\"\n        self._refresh_token_if_needed()\n        self.logger.debug(f\"\ud83d\udd0e Fetching detailed invoice for InvoiceID={invoice_id}\")\n\n        invoice_list = self._retry_on_unauthorized(self.xero.invoices.get, invoice_id)\n        if not invoice_list:\n            self.logger.warning(f\"\u26a0\ufe0f No detailed invoice found for InvoiceID={invoice_id}.\")\n            return None\n\n        full_invoice = invoice_list[0]\n        if full_invoice.get(\"Status\") == \"DELETED\":\n            self.logger.debug(f\"\u23e9 Invoice {invoice_id} is DELETED; returning None.\")\n            return None\n\n        return full_invoice"
                    },
                    {
                        "name": "get_contact_by_name",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Retrieve a Xero contact by name. Returns the first match if multiple are found.\nIf none exist, returns None.",
                        "function_body": "    def get_contact_by_name(self, name: str):\n        \"\"\"\n        Retrieve a Xero contact by name. Returns the first match if multiple are found.\n        If none exist, returns None.\n        \"\"\"\n        self._refresh_token_if_needed()\n        self.logger.info(f\"\ud83d\udd0e Attempting to retrieve Xero contact by name: {name}\")\n\n        try:"
                    },
                    {
                        "name": "get_all_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Fetch all contacts from Xero. This may be large for bigger organizations,\nso consider pagination or filtering if performance is a concern.",
                        "function_body": "    def get_all_contacts(self):\n        \"\"\"\n        Fetch all contacts from Xero. This may be large for bigger organizations,\n        so consider pagination or filtering if performance is a concern.\n        \"\"\"\n        self._refresh_token_if_needed()\n        self.logger.info(\"\ud83d\udcc7 Fetching all contacts from Xero...\")\n\n        try:"
                    },
                    {
                        "name": "create_contact",
                        "args": [
                            "self",
                            "contact_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Create a new contact in Xero using the provided contact_data.",
                        "function_body": "    def create_contact(self, contact_data: dict):\n        \"\"\"\n        Create a new contact in Xero using the provided contact_data.\n        \"\"\"\n        self._refresh_token_if_needed()\n        self.logger.info(f\"\ud83d\udc64 Creating a new Xero contact with data: {contact_data}\")\n\n        try:"
                    },
                    {
                        "name": "update_contact",
                        "args": [
                            "self",
                            "contact_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed",
                            "_retry_on_unauthorized"
                        ],
                        "docstring": "Update an existing contact in Xero. The contact_data must include ContactID.",
                        "function_body": "    def update_contact(self, contact_data: dict):\n        \"\"\"\n        Update an existing contact in Xero. The contact_data must include ContactID.\n        \"\"\"\n        cid = contact_data.get('ContactID')\n        self.logger.info(f\"\ud83d\udd04 Attempting to update contact with ContactID={cid}\")\n        self._refresh_token_if_needed()\n\n        try:"
                    },
                    {
                        "name": "update_contact_with_retry",
                        "args": [
                            "self",
                            "contact_data",
                            "max_retries"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": "Attempts to update a Xero contact, retrying if we encounter rate-limit errors.",
                        "function_body": "    def update_contact_with_retry(self, contact_data, max_retries=3):\n        \"\"\"\n        Attempts to update a Xero contact, retrying if we encounter rate-limit errors.\n        \"\"\"\n        cid = contact_data.get(\"ContactID\")\n        self.logger.info(f\"\ud83d\udd04 Attempting to update contact (ID={cid}) with retry up to {max_retries} times.\")\n        self._refresh_token_if_needed()\n\n        for attempt in range(1, max_retries + 1):\n            try:\n                updated = self.xero.contacts.save(contact_data)\n                return updated  # Xero returns a list of updated contacts\n            except XeroRateLimitExceeded:\n                self.logger.warning(\n                    f\"\ud83d\udd03 Rate limit hit. Attempt {attempt} of {max_retries}. \"\n                    f\"Sleeping for 65 seconds before retry...\"\n                )\n                time.sleep(65)\n            except XeroException as xe:\n                self.logger.error(f\"\u274c XeroException while updating contact: {xe}\")\n                return None\n            except Exception as e:\n                self.logger.error(f\"\ud83d\udca5 Unexpected error updating contact: {str(e)}\")\n                return None\n\n        self.logger.error(\"\u274c Failed to update contact after multiple rate-limit retries.\")\n        return None"
                    },
                    {
                        "name": "update_contacts_with_retry",
                        "args": [
                            "self",
                            "contacts_data",
                            "max_retries"
                        ],
                        "decorators": [],
                        "calls": [
                            "_refresh_token_if_needed"
                        ],
                        "docstring": "Attempts to update multiple Xero contacts, retrying if we encounter rate-limit errors.",
                        "function_body": "    def update_contacts_with_retry(self, contacts_data: list[dict], max_retries=3):\n        \"\"\"\n        Attempts to update multiple Xero contacts, retrying if we encounter rate-limit errors.\n        \"\"\"\n        self.logger.info(\n            f\"\ud83d\udd04 Attempting batch update of {len(contacts_data)} contact(s) with up to {max_retries} retries...\"\n        )\n        self._refresh_token_if_needed()\n\n        for attempt in range(1, max_retries + 1):\n            try:\n                updated = self.xero.contacts.save(contacts_data)\n                return updated  # Xero returns a list of updated contacts\n            except XeroRateLimitExceeded:\n                self.logger.warning(\n                    f\"\ud83d\udd03 Rate limit hit (update_contacts_with_retry). Attempt {attempt} of {max_retries}. \"\n                    f\"Sleeping for 65 seconds before retry...\"\n                )\n                time.sleep(65)\n            except XeroException as xe:\n                self.logger.error(f\"\u274c XeroException while updating contacts in batch: {xe}\")\n                return None\n            except Exception as e:\n                self.logger.error(f\"\ud83d\udca5 Unexpected error in batch contact update: {str(e)}\")\n                return None\n\n        self.logger.error(\"\u274c Failed to update contacts after multiple rate-limit retries.\")\n        return None"
                    },
                    {
                        "name": "create_spend_money_in_batch",
                        "args": [
                            "self",
                            "session",
                            "detail_item_ids"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Example of concurrency to create multiple spend money items in parallel.",
                        "function_body": "    def create_spend_money_in_batch(self, session, detail_item_ids: list[int]):\n        \"\"\"\n        Example of concurrency to create multiple spend money items in parallel.\n        \"\"\"\n        self.logger.info(f\"\ud83c\udfce Creating SPEND money in batch for detail_item_ids={detail_item_ids}\")\n        futures = []\n        results = []\n\n        with ThreadPoolExecutor(max_workers=5) as executor:\n            for detail_item_id in detail_item_ids:\n                futures.append(\n                    executor.submit(self.create_spend_money, session, detail_item_id)\n                )\n\n            for future in as_completed(futures):\n                try:\n                    result = future.result()\n                    results.append(result)\n                except Exception as e:\n                    self.logger.error(f\"\ud83d\udca5 Exception in thread for detail_item_id: {str(e)}\")\n\n        self.logger.info(f\"\u2705 Batch creation complete. Results length={len(results)}\")\n        return results"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "xero_api",
                "value": "XeroAPI()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_xero/xero_services.py",
        "functions": [],
        "classes": [
            {
                "name": "XeroServices",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Initialize the XeroServices with references to DatabaseOperations\nand XeroAPI instances.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        Initialize the XeroServices with references to DatabaseOperations\n        and XeroAPI instances.\n        \"\"\"\n        self.database_util = DatabaseOperations()\n        self.xero_api = xero_api\n        self.logger = logging.getLogger(\"xero_logger\")\n        self.logger.debug(\"Initialized XeroServices.\")\n        self._initialized = True"
                    },
                    {
                        "name": "load_spend_money_transactions",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "detail_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_spend_money",
                            "update_spend_money",
                            "create_spend_money"
                        ],
                        "docstring": "Loads Xero SPEND transactions (bankTransactions) into the 'spend_money' table.\n\nArgs:\n    project_id (int, optional): The project ID portion of the reference filter.\n    po_number (int, optional): The PO number portion of the reference filter.\n    detail_number (int, optional): The detail number portion of the reference filter.\n\nUsage example:\n    database_util = DatabaseOperations()\n    xero_api_instance = XeroAPI()\n    xero_services = XeroServices(database_util, xero_api_instance)\n    xero_services.load_spend_money_transactions(project_id=1234, po_number=101, detail_number=2)",
                        "function_body": "    def load_spend_money_transactions(\n            self,\n            project_id: int = None,\n            po_number: int = None,\n            detail_number: int = None\n        ):\n        \"\"\"\n        Loads Xero SPEND transactions (bankTransactions) into the 'spend_money' table.\n\n        Args:\n            project_id (int, optional): The project ID portion of the reference filter.\n            po_number (int, optional): The PO number portion of the reference filter.\n            detail_number (int, optional): The detail number portion of the reference filter.\n\n        Usage example:\n            database_util = DatabaseOperations()\n            xero_api_instance = XeroAPI()\n            xero_services = XeroServices(database_util, xero_api_instance)\n            xero_services.load_spend_money_transactions(project_id=1234, po_number=101, detail_number=2)\n        \"\"\"\n        self.logger.info(\"Retrieving SPEND transactions from Xero...\")\n        xero_spend_transactions = self.xero_api.get_spend_money_by_reference(\n            project_id=project_id,\n            po_number=po_number,\n            detail_number=detail_number\n        )\n\n        if not xero_spend_transactions:\n            self.logger.info(\"No SPEND transactions returned from Xero for the provided filters.\")\n            return\n\n        for tx in xero_spend_transactions:"
                    },
                    {
                        "name": "populate_xero_contacts",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_contacts",
                            "get_all_contacts",
                            "update_contacts_with_retry",
                            "validate_xero_data"
                        ],
                        "docstring": "Retrieve all contacts from the local DB, retrieve all contacts from Xero,\ncompare them, and then perform a single batch update (only for those that need changes).",
                        "function_body": "    def populate_xero_contacts(self):\n        \"\"\"\n        Retrieve all contacts from the local DB, retrieve all contacts from Xero,\n        compare them, and then perform a single batch update (only for those that need changes).\n        \"\"\"\n        self.logger.info(\"\ud83d\ude80 Starting to populate Xero contacts from the local DB in a single batch...\")\n\n        # 1) Retrieve all contacts from the local DB\n        db_contacts = self.database_util.search_contacts()\n        self.logger.info(f\"Found {len(db_contacts)} contacts in the local DB to process.\")\n\n        # 2) Retrieve all contacts from Xero\n        self.logger.info(\"Retrieving all contacts from Xero...\")\n        try:\n            all_xero_contacts = self.xero_api.get_all_contacts()\n        except XeroException as xe:\n            self.logger.error(f\"Failed to retrieve contacts from Xero: {xe}\")\n            return\n\n        # Build a dictionary with contact name as key for quick lookup\n        xero_contacts_dict = {\n            contact[\"Name\"].strip().lower(): contact for contact in all_xero_contacts\n            if isinstance(contact.get(\"Name\"), str) and contact.get(\"Name\").strip()\n        }\n\n        # We'll accumulate all contacts that actually need updating in Xero\n        contacts_to_update = []\n\n        # 3) Compare each DB contact to its counterpart in Xero\n        for db_contact in db_contacts:\n            errors = self.validate_xero_data(db_contact)\n            if errors:\n                self.logger.error(\n                    f\"Skipping contact '{db_contact.get('name', 'Unnamed')}' due to validation errors: {errors}\"\n                )\n                continue\n\n            contact_name = db_contact[\"name\"]\n            self.logger.info(f\"\ud83d\udd0e Checking if there's a matching Xero contact for '{contact_name}'\")\n\n            # Use lowercase to match our dictionary keys\n            xero_match = xero_contacts_dict.get(contact_name.strip().lower())\n\n            if not xero_match:\n                msg = f\"No matching Xero contact found for: '{contact_name}' \u274c\"\n                self.logger.warning(msg)\n                continue\n\n            # Extract the existing Xero data\n            contact_id = xero_match[\"ContactID\"]\n            xero_tax_number = xero_match.get(\"TaxNumber\", \"\") or \"\"\n            xero_addresses = xero_match.get(\"Addresses\", [])\n            xero_email = xero_match.get(\"EmailAddress\") or \"\"\n            # Prepare the fields to update\n            tax_number = str(db_contact.get(\"tax_number\")) if db_contact.get(\"tax_number\") else \"\"\n            email = db_contact[\"email\"]\n            # 3a) Format or handle the SSN if needed\n            # For example, if Xero requires XXX-XX-XXXX but you only have digits:\n            if tax_number and len(tax_number) == 9 and tax_number.isdigit():\n                # Transform 123456789 -> 123-45-6789\n                formatted_ssn = f\"{tax_number[0:3]}-{tax_number[3:5]}-{tax_number[5:]}\"\n                self.logger.debug(f\"Formatting SSN from '{tax_number}' to '{formatted_ssn}' for '{contact_name}'.\")\n                tax_number = formatted_ssn\n\n            address_data = [\n                {\n                    \"AddressType\": \"STREET\",\n                    \"AddressLine1\": db_contact.get(\"address_line_1\", \"\") or \"\",\n                    \"AddressLine2\": db_contact.get(\"address_line_2\", \"\") or \"\",\n                    \"City\": db_contact.get(\"city\", \"\") or \"\",\n                    \"PostalCode\": db_contact.get(\"zip\", \"\") or \"\",\n                    \"Region\": db_contact.get(\"region\", \"\") or \"\",\n                    \"Country\": db_contact.get(\"country\", \"\") or \"\"\n\n                },\n                {\n                    \"AddressType\": \"POBOX\",\n                    \"AddressLine1\": db_contact.get(\"address_line_1\", \"\") or \"\",\n                    \"AddressLine2\": db_contact.get(\"address_line_2\", \"\") or \"\",\n                    \"City\": db_contact.get(\"city\", \"\") or \"\",\n                    \"PostalCode\": db_contact.get(\"zip\", \"\") or \"\",\n                    \"Region\": db_contact.get(\"region\", \"\") or \"\",\n                    \"Country\": db_contact.get(\"country\", \"\") or \"\"\n                }\n            ]\n\n            # 3b) Compare existing Xero data vs. new data\n            need_update = False\n\n            # Compare tax number\n            if xero_tax_number != tax_number:\n                need_update = True\n                self.logger.debug(\n                    f\"Tax number changed for '{contact_name}' from '{xero_tax_number}' to '{tax_number}'.\"\n                )\n\n            if email != xero_email:\n                need_update = True\n                self.logger.debug(\n                    f\"Email changed for '{contact_name}' from '{xero_email}' to '{email}'.\"\n                )\n\n            # Compare addresses\n            # Make sure we have at least 2 in Xero to compare; otherwise, update is needed\n            if len(xero_addresses) < 2:\n                self.logger.debug(\n                    f\"Xero contact '{contact_name}' has fewer than 2 addresses stored. Triggering update.\"\n                )\n                need_update = True\n            else:\n                # Compare the first two addresses\n                for idx in range(2):\n                    old = xero_addresses[idx]\n                    new = address_data[idx]\n                    for field in [\"AddressLine1\", \"AddressLine2\", \"City\", \"PostalCode\", \"Country\", \"Region\"]:\n                        if old.get(field, \"\") != new.get(field, \"\"):\n                            self.logger.debug(\n                                f\"Address {idx} field '{field}' changed for '{contact_name}' \"\n                                f\"from '{old.get(field, '')}' to '{new.get(field, '')}'.\"\n                            )\n                            need_update = True\n                            break\n\n            # 3c) Only add to batch if there's an actual change\n            if need_update:\n                updated_contact_data = {\n                    \"ContactID\": contact_id,\n                    \"Name\": db_contact[\"name\"],\n                    \"Email\": email,\n                    \"TaxNumber\": tax_number,\n                    \"Addresses\": address_data,\n                }\n                contacts_to_update.append(updated_contact_data)\n            else:\n                self.logger.info(f\"\ud83c\udf89  No change needed for '{contact_name}'.\")\n\n        # 4) Perform a single batch update if there are any contacts to update\n        if contacts_to_update:\n            self.logger.info(\n                f\"\ud83d\udcbe Sending a batch update for {len(contacts_to_update)} Xero contacts...\"\n            )\n            try:\n                # Assumes you have a method in xero_api to handle batch updates\n                self.xero_api.update_contacts_with_retry(contacts_to_update)\n                self.logger.info(\n                    f\"\ud83c\udf89 Successfully updated {len(contacts_to_update)} Xero contacts in a single batch.\"\n                )\n            except XeroException as xe:\n                self.logger.error(f\"XeroException while updating contacts in batch: {xe}\")\n            except Exception as e:\n                self.logger.debug(f\"Debugging the exception object: type={type(e)}, repr={repr(e)}\")\n                error_message = f\"\u26a0\ufe0f Error in batch update: {e}\"\n                self.logger.error(error_message)\n        else:\n            self.logger.info(\"No contacts required updating in Xero.\")\n\n        self.logger.info(\"\ud83c\udfc1 Finished populating Xero contacts from the local DB in a single batch.\")"
                    },
                    {
                        "name": "validate_xero_data",
                        "args": [
                            "self",
                            "db_contact"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Validate the DB contact for required fields, address formats, etc.\nReturns a list of error messages, empty if no errors.",
                        "function_body": "    def validate_xero_data(self, db_contact):\n        \"\"\"\n        Validate the DB contact for required fields, address formats, etc.\n        Returns a list of error messages, empty if no errors.\n        \"\"\"\n        errors = []\n\n        # Check mandatory fields\n        if not db_contact.get(\"name\"):\n            errors.append(\"\u2757 Missing or empty name.\")\n\n        # Validate address fields\n        address = {\n            \"AddressLine1\": db_contact.get(\"address_line_1\", \"\"),\n            \"AddressLine2\": db_contact.get(\"address_line_2\", \"\"),\n            \"City\": db_contact.get(\"city\", \"\"),\n            \"PostalCode\": db_contact.get(\"zip\", \"\"),\n        }\n        if len(address[\"AddressLine1\"]) > 255:\n            errors.append(\"\u2757 AddressLine1 exceeds character limit.\")\n        if len(address[\"City\"]) > 255:\n            errors.append(\"\u2757 City exceeds character limit.\")\n        if len(address[\"PostalCode\"]) > 50:  # Example length limit\n            errors.append(\"\u2757 PostalCode exceeds character limit.\")\n\n        # Tax Number validation\n        tax_number = str(db_contact.get(\"tax_number\", \"\"))\n        if tax_number and not tax_number.isalnum():\n            errors.append(\"\u2757 TaxNumber contains invalid characters.\")\n\n        return errors"
                    },
                    {
                        "name": "load_bills",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_bill_line_item",
                            "update_bill_line_item",
                            "get_acpay_invoices_summary_by_ref",
                            "search_xero_bills",
                            "search_bill_line_items",
                            "update_xero_bill",
                            "get_invoice_details",
                            "create_xero_bill"
                        ],
                        "docstring": "1) Retrieve summary of ACCPAY invoices matching project_number in InvoiceNumber.\n2) For each invoice, retrieve full details (line items).\n3) For each line item, match or create a local BillLineItem with parent_xero_id\n   (and project_number, po_number, detail_number, etc.), then link to XeroBill.",
                        "function_body": "    def load_bills(self, project_number: str):\n        \"\"\"\n        1) Retrieve summary of ACCPAY invoices matching project_number in InvoiceNumber.\n        2) For each invoice, retrieve full details (line items).\n        3) For each line item, match or create a local BillLineItem with parent_xero_id\n           (and project_number, po_number, detail_number, etc.), then link to XeroBill.\n        \"\"\"\n        self.logger.info(\n            f\"Retrieving ACCPAY invoices from Xero where InvoiceNumber contains '{project_number}'...\"\n        )\n        # Step 1: fetch summary of matching invoices\n        summaries = self.xero_api.get_acpay_invoices_summary_by_ref(project_number)\n        if not summaries:\n            self.logger.info(\n                f\"No ACCPAY invoices found with InvoiceNumber containing '{project_number}'.\"\n            )\n            return\n\n        for summary_inv in summaries:\n            invoice_id = summary_inv.get(\"InvoiceID\")\n            invoice_number = summary_inv.get(\"InvoiceNumber\", \"\")\n            status = summary_inv.get(\"Status\", \"DRAFT\")\n\n            self.logger.info(\n                f\"Fetching full details for InvoiceNumber={invoice_number} (ID={invoice_id})...\"\n            )\n\n            # Step 2: retrieve full invoice details (line items)\n            full_inv = self.xero_api.get_invoice_details(invoice_id)\n            if not full_inv:\n                self.logger.warning(f\"Skipping InvoiceID={invoice_id}, no line items returned.\")\n                continue\n\n            line_items = full_inv.get(\"LineItems\", [])\n            self.logger.debug(\n                f\"Invoice {invoice_number} has {len(line_items)} line item(s).\"\n            )\n\n            # Derive project_number, po_number, detail_number from invoice_number if in format \"2416_32_1\"\n            parts = invoice_number.split(\"_\")\n            if len(parts) >= 2:\n                try:\n                    project_num = int(parts[0])  # \"2416\"\n                    po_num = int(parts[1])       # \"32\"\n                    if len(parts) >= 3:\n                        detail_num = int(parts[2])\n                    else:\n                        detail_num = 1\n                except ValueError:\n                    self.logger.warning(\n                        f\"InvoiceNumber='{invoice_number}' not in numeric format. Skipping line item match.\"\n                    )\n                    continue\n            else:\n                self.logger.warning(\n                    f\"InvoiceNumber='{invoice_number}' doesn't have at least two parts. Skipping line item match.\"\n                )\n                continue\n\n            # Create or update XeroBill\n            existing_bill = self.database_util.search_xero_bills(\n                column_names=[\"xero_reference_number\"],\n                values=[invoice_number]\n            )\n\n            if not existing_bill:\n                created_bill = self.database_util.create_xero_bill(\n                    xero_reference_number=invoice_number,\n                    xero_id=invoice_id,  # Store the Xero InvoiceID\n                    state=status,\n                    project_number=project_num,\n                    po_number=po_num,\n                    detail_number=detail_num,\n                    xero_link=f\"https://go.xero.com/AccountsPayable/View.aspx?invoiceId={invoice_id}\"\n                )\n                if not created_bill:\n                    self.logger.error(f\"Failed to create xero_bill for {invoice_number}. Skipping line items.\")\n                    continue\n                xero_bill_id = created_bill[\"id\"]\n            else:\n                if isinstance(existing_bill, list):\n                    existing_bill = existing_bill[0]\n                xero_bill_id = existing_bill[\"id\"]\n                self.logger.info(f\"Updating existing xero_bill (ID={xero_bill_id}) to status={status}.\")\n                self.database_util.update_xero_bill(\n                    xero_bill_id,\n                    xero_id=invoice_id,\n                    project_number=project_num,\n                    po_number=po_num,\n                    detail_number=detail_num,\n                    state=status,\n                    xero_link=f\"https://go.xero.com/AccountsPayable/View.aspx?invoiceId={invoice_id}\"\n                )\n\n            # Step 3: For each line item, match or create BillLineItem by parent_xero_id\n            for idx, li in enumerate(line_items):\n                # Extract line item fields from Xero\n                xero_line_number = li.get(\"LineItemID\")  # e.g. '6fe99992-2544-4a3a-b53b-83a2ae70383f'\n                description = li.get(\"Description\")\n                quantity = li.get(\"Quantity\")\n                unit_amount = li.get(\"UnitAmount\")\n                line_amount = li.get(\"LineAmount\")\n                account_code_str = li.get(\"AccountCode\")  # Typically a string\n                account_code = None\n\n                # Convert AccountCode to int if possible\n                if account_code_str:\n                    try:\n                        account_code = int(account_code_str)\n                    except ValueError:\n                        self.logger.warning(f\"AccountCode '{account_code_str}' is not an integer. Using None.\")\n\n                # Try to find an existing BillLineItem by parent_xero_id\n                existing_line = self.database_util.search_bill_line_items(\n                    column_names=[\"parent_xero_id\"],\n                    values=[xero_line_number]\n                )\n\n                if existing_line:\n                    # If multiple found, use the first\n                    if isinstance(existing_line, list):\n                        existing_line = existing_line[0]\n\n                    bill_line_item_id = existing_line[\"id\"]\n\n                    # Update existing BillLineItem\n                    self.logger.info(\n                        f\"Updating existing BillLineItem (ID={bill_line_item_id}) with Xero line data.\"\n                    )\n                    updated_line = self.database_util.update_bill_line_item(\n                        bill_line_item_id,\n                        description=description,\n                        quantity=quantity,\n                        unit_amount=unit_amount,\n                        line_amount=line_amount,\n                        account_code=account_code\n                    )\n                    if updated_line:\n                        self.logger.debug(f\"BillLineItem (ID={bill_line_item_id}) successfully updated.\")\n                    else:\n                        self.logger.error(\n                            f\"Failed to update BillLineItem (ID={bill_line_item_id}).\"\n                        )\n\n                else:\n                    # If no existing record, create new\n                    self.logger.info(f\"No BillLineItem found for parent_xero_id={xero_line_number}. Creating a new one.\")\n\n                    new_line = self.database_util.create_bill_line_item(\n\n                        # In case you also store another parent reference\n                        parent_id=xero_bill_id,\n\n                        # Store the Xero line item ID\n                        parent_xero_id=xero_line_number,\n\n                        # Project/PO/Detail info\n                        project_number=project_num,\n                        po_number=po_num,\n                        detail_number=detail_num,\n\n                        # Possibly store an integer line_number if you want\n                        line_number=idx + 1,\n\n                        # Basic fields from Xero\n                        description=description,\n                        quantity=quantity,\n                        unit_amount=unit_amount,\n                        line_amount=line_amount,\n                        account_code=account_code\n                    )\n                    if new_line:\n                        self.logger.debug(\n                            f\"Created BillLineItem with ID={new_line['id']} and parent_xero_id={xero_line_number}.\"\n                        )\n                    else:\n                        self.logger.error(\n                            f\"Failed to create BillLineItem for parent_xero_id={xero_line_number}.\"\n                        )\n\n        self.logger.info("
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "xero_services",
                "value": "XeroServices()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_webhook_handler.py",
        "functions": [
            {
                "name": "dropbox_webhook",
                "args": [],
                "decorators": [
                    "dropbox_blueprint.route('/')"
                ],
                "calls": [
                    "handle_dropbox_event"
                ],
                "docstring": null,
                "function_body": "def dropbox_webhook():\n    if request.method == 'GET':"
            }
        ],
        "classes": [
            {
                "name": "DropboxWebhookHandler",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "handle_dropbox_event",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [
                            "process_event_data"
                        ],
                        "docstring": "Handle incoming Dropbox webhook event.",
                        "function_body": "    def handle_dropbox_event(self, event):\n        \"\"\"Handle incoming Dropbox webhook event.\"\"\"\n        self.logger.info(\"Received Dropbox event.\")\n        self.process_event_data(event)\n        return jsonify({\"message\": \"Dropbox event processed\"}), 200"
                    },
                    {
                        "name": "process_event_data",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_last_path_component_generic",
                            "list_root_folder",
                            "save_cursor",
                            "list_folder_changes",
                            "determine_file_type",
                            "load_cursor"
                        ],
                        "docstring": "Processes the event data received from Dropbox webhook.\nFetches the latest changes since the last cursor,\ncategorizes them by folder/file and event type (added, deleted),\nlogs the changes, and ensures duplicate events with the same cursor are ignored.",
                        "function_body": "    def process_event_data(self, event_data):\n        \"\"\"\n        Processes the event data received from Dropbox webhook.\n        Fetches the latest changes since the last cursor,\n        categorizes them by folder/file and event type (added, deleted),\n        logs the changes, and ensures duplicate events with the same cursor are ignored.\n        \"\"\"\n        self.logger.info(\"Starting to process event data...\")\n\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_blueprint",
                "value": "Blueprint('files_dropbox', __name__)"
            },
            {
                "name": "dropbox_webhook_handler",
                "value": "DropboxWebhookHandler()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_service.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Initializes the DropboxService singleton, setting up logging, external\nAPIs, and the new DatabaseOperations object for DB interactions.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        Initializes the DropboxService singleton, setting up logging, external\n        APIs, and the new DatabaseOperations object for DB interactions.\n        \"\"\"\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "determine_file_type",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_last_path_component_generic",
                            "process_tax_form",
                            "po_log_orchestrator",
                            "process_invoice",
                            "process_receipt"
                        ],
                        "docstring": "Determine the file type by matching patterns in its name,\nthen route the file to the appropriate process_* handler.\n\n:param path: The Dropbox file path",
                        "function_body": "    def determine_file_type(self, path: str):\n        \"\"\"\n        Determine the file type by matching patterns in its name,\n        then route the file to the appropriate process_* handler.\n\n        :param path: The Dropbox file path\n        \"\"\"\n        self.logger.info(\n            f\"\ud83d\udd0d Checking file type for: {self.dropbox_util.get_last_path_component_generic(path)}\"\n        )\n        filename = os.path.basename(path)\n\n        try:"
                    },
                    {
                        "name": "process_budget",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def process_budget(self, dropbox_path: str):\n        self.logger.info(f\"\ud83d\udcbc Processing budget: {dropbox_path}\")\n        filename = os.path.basename(dropbox_path)\n        try:\n            if not filename.endswith(\".mbb\") or filename.endswith(\".mbb.lck\"):\n                self.logger.info(\"\u274c Not a valid .mbb file.\")\n                return\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error checking extension: {e}\", exc_info=True)\n            return\n\n        # Extract project_number\n        try:\n            segments = dropbox_path.strip(\"/\").split(\"/\")\n            if len(segments) < 4:\n                self.logger.info(\"\u274c Not enough path segments.\")\n                return\n\n            project_folder = segments[0]\n            budget_folder = segments[1]\n            phase_folder = segments[2]\n\n            if budget_folder != \"5. Budget\" or phase_folder not in [\"1.2 Working\", \"1.3 Actuals\"]:\n                self.logger.info(\"\u274c Budget file not in correct folder.\")\n                return\n\n            project_number_match = re.match(r\"^\\d{4}\", project_folder)\n            if not project_number_match:\n                self.logger.info(\"\u274c Can't determine Project ID.\")\n                return\n            project_number = project_number_match.group()\n\n            self.logger.info(f\"\ud83d\udd11 Project ID: {project_number}\")\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error parsing path: {e}\", exc_info=True)\n            return\n\n        try:\n            budget_root = \"/\".join(segments[0:3])\n            po_logs_path = f\"/{budget_root}/1.5 PO Logs\"\n            self.logger.info(f\"\ud83d\uddc2 PO Logs folder: {po_logs_path}\")\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error determining PO Logs folder: {e}\", exc_info=True)\n            return\n\n        # Trigger a server job (if required)\n        import requests\n        server_url = \"http://localhost:5004/enqueue\"\n        self.logger.info(\"\ud83d\udda8 Triggering ShowbizPoLogPrinter via server with file URL...\")\n        try:\n            response = requests.post(\n                server_url,\n                json={\"project_number\": project_number, \"file_path\": dropbox_path},\n                timeout=10\n            )\n            if response.status_code == 200:\n                job_id = response.json().get(\"job_id\")\n                self.logger.info(f\"\ud83c\udf89 Triggered server job with job_id: {job_id}\")\n            else:\n                self.logger.error(\n                    f\"\u274c Failed to trigger server job. Status: {response.status_code}, Response: {response.text}\")\n                return\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error triggering server job: {e}\", exc_info=True)\n            return\n\n        self.logger.info(\"\u2705 process_budget completed successfully, server job triggered with file URL.\")"
                    },
                    {
                        "name": "po_log_orchestrator",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_project_number",
                            "download_file_from_dropbox",
                            "add_po_data_to_db",
                            "extract_data_from_po_log"
                        ],
                        "docstring": "Process a PO log file from Dropbox, parse it, then store the results in the DB.\nThis includes adding Contacts, PurchaseOrders, and DetailItems.",
                        "function_body": "    def po_log_orchestrator(self, path: str):\n        \"\"\"\n        Process a PO log file from Dropbox, parse it, then store the results in the DB.\n        This includes adding Contacts, PurchaseOrders, and DetailItems.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udcdd Processing PO log: {path}\")\n        temp_file_path = f\"./temp_files/{os.path.basename(path)}\"\n        project_number = self.extract_project_number(temp_file_path)\n        self.PROJECT_NUMBER = project_number\n\n        # Download from Dropbox if we are NOT using a preexisting temp file\n        if not self.USE_TEMP_FILE:\n            if not self.download_file_from_dropbox(path, temp_file_path):\n                return\n\n        # Parse the PO log (extract main_items, detail_items, contacts)\n        main_items, detail_items, contacts = self.extract_data_from_po_log(temp_file_path, project_number)\n\n        # Otherwise, process in DB asynchronously\n        self.add_po_data_to_db(main_items, detail_items, contacts, project_number)\n\n        #db_future = self.executor.submit(self.add_po_data_to_db, main_items, detail_items, contacts)\n        #db_future.add_done_callback(self.callback_add_po_data_to_DB)\n\n        self.logger.info(\"\ud83d\udd27 DB and Monday processing dispatched to background threads.\")"
                    },
                    {
                        "name": "extract_data_from_po_log",
                        "args": [
                            "self",
                            "temp_file_path",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "parse_showbiz_po_log"
                        ],
                        "docstring": "Parse the local PO log file to extract main_items, detail_items, and contacts.\n\n:param temp_file_path: The local file path\n:param project_number: The project ID\n:return: (main_items, detail_items, contacts)",
                        "function_body": "    def extract_data_from_po_log(self, temp_file_path: str, project_number: str):\n        \"\"\"\n        Parse the local PO log file to extract main_items, detail_items, and contacts.\n\n        :param temp_file_path: The local file path\n        :param project_number: The project ID\n        :return: (main_items, detail_items, contacts)\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "add_po_data_to_db",
                        "args": [
                            "self",
                            "main_items",
                            "detail_items",
                            "contacts",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_find_or_create_contact",
                            "update_purchase_order_by_keys",
                            "search_contacts",
                            "create_detail_item_by_keys",
                            "update_detail_item_by_keys",
                            "create_purchase_order_by_keys",
                            "search_detail_items",
                            "search_purchase_orders"
                        ],
                        "docstring": "\ud83d\ude80 DB Processing Method\n----------------------\n*New Batch Logic*:\n1) Convert project_number to an int.\n2) Fetch all existing POs with that project_number in one shot.\n3) For each main_item (PO), decide if it's new or existing (based on po_number).\n   Then batch create or update accordingly ONLY if data has changed.\n4) Fetch all existing DetailItems with that same project_number in one shot.\n5) For each detail_item, decide if new or existing (based on (po_number, detail_number, line_number)).\n   Then batch create or update accordingly ONLY if data has changed (and unless it's in a final state).\n6) Link contact if needed. We skip manual `project_id` lookups.",
                        "function_body": "    def add_po_data_to_db(self, main_items, detail_items, contacts, project_number: str):\n        \"\"\"\n        \ud83d\ude80 DB Processing Method\n        ----------------------\n        *New Batch Logic*:\n        1) Convert project_number to an int.\n        2) Fetch all existing POs with that project_number in one shot.\n        3) For each main_item (PO), decide if it's new or existing (based on po_number).\n           Then batch create or update accordingly ONLY if data has changed.\n        4) Fetch all existing DetailItems with that same project_number in one shot.\n        5) For each detail_item, decide if new or existing (based on (po_number, detail_number, line_number)).\n           Then batch create or update accordingly ONLY if data has changed (and unless it's in a final state).\n        6) Link contact if needed. We skip manual `project_id` lookups.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd27 [NEW BATCH LOGIC] Processing project_number={project_number} with batch queries.\")\n        pn_int = int(project_number)\n\n        # region 1) Process Contacts (Optional)\n        all_db_contacts = self.database_util.search_contacts()\n        self.logger.info(f\"\u2705 Retrieved {len(all_db_contacts) if isinstance(all_db_contacts, list) else 1} contacts.\")\n\n        # region 2) Fetch all existing POs for this project_number\n        existing_pos = self.database_util.search_purchase_orders(\n            column_names=[\"project_number\"], values=[pn_int]\n        )\n        if existing_pos is None:\n            existing_pos = []\n        elif isinstance(existing_pos, dict):\n            existing_pos = [existing_pos]\n\n        pos_by_number = {po[\"po_number\"]: po for po in existing_pos}\n        self.logger.info(f\"\u2705 Found {len(existing_pos)} existing POs for project_number={pn_int}.\")\n\n        # Helper function to check if PO data has changed\n        def _po_has_changes(existing_po, new_data, contact_id):\n            \"\"\"\n            Compare relevant PO fields to see if there's a difference\n            between what's in the database (existing_po) and\n            the incoming data (new_data).\n            \"\"\"\n            if existing_po.get(\"description\") != new_data.get(\"description\"):\n                return True\n            if existing_po.get(\"po_type\") != new_data.get(\"po_type\"):\n                return True\n            if existing_po.get(\"contact_id\") != contact_id:\n                return True\n            return False\n\n        # region 3) Create or update each main_item\n        for i, item in enumerate(main_items):\n            try:\n                # Skip if PO number is below debug threshold\n                if self.DEBUG_STARTING_PO_NUMBER and int(item[\"po_number\"]) < self.DEBUG_STARTING_PO_NUMBER:\n                    continue\n\n                # 3a) Find or create the contact\n                contact_id = self._find_or_create_contact(item, contacts, i, all_db_contacts)\n\n                po_number = int(item[\"po_number\"])\n                existing_po = pos_by_number.get(po_number)\n\n                # 3b) If existing, check for changes and update if needed\n                if existing_po:\n                    if _po_has_changes(existing_po, item, contact_id):\n                        self.logger.info(f\"\ud83d\udd04 Updating existing PO {po_number} for project {pn_int}.\")\n                        updated_po = self.database_util.update_purchase_order_by_keys(\n                            project_number=pn_int,\n                            po_number=po_number,\n                            description=item.get(\"description\"),\n                            po_type=item.get(\"po_type\"),\n                            contact_id=contact_id\n                        )\n                        if updated_po:\n                            pos_by_number[po_number] = updated_po  # refresh our dict\n                    else:\n                        self.logger.debug(f\"\u23ed No changes detected for existing PO {po_number}. Skipping update.\")\n                else:\n                    # 3c) Create\n                    self.logger.info(f\"\ud83c\udd95 Creating new PO {po_number} for project {pn_int}.\")\n                    new_po = self.database_util.create_purchase_order_by_keys(\n                        project_number=pn_int,\n                        po_number=po_number,\n                        description=item.get(\"description\"),\n                        po_type=item.get(\"po_type\"),\n                        contact_id=contact_id\n                    )\n                    if new_po:\n                        pos_by_number[po_number] = new_po  # add it to our dict so detail items can see it\n            except Exception as ex:\n                self.logger.error(\n                    f\"\ud83d\udca5 Error processing PO creation/update for po_number={item.get('po_number')}: {ex}\",\n                    exc_info=True\n                )\n\n        # region 4) Fetch all existing DetailItems for that project_number\n        existing_details = self.database_util.search_detail_items([\"project_number\"], [pn_int])\n        if existing_details is None:\n            existing_details = []\n        elif isinstance(existing_details, dict):\n            existing_details = [existing_details]\n\n        # Dictionary keyed by (po_number, detail_number, line_number)\n        detail_dict = {}\n        for d in existing_details:\n            key = (d[\"po_number\"], d[\"detail_number\"], d[\"line_number\"])\n            detail_dict[key] = d\n        self.logger.info(f\"\u2705 Found {len(existing_details)} existing DetailItems for project_number={pn_int}.\")\n\n        # A set of final states:\n        COMPLETED_STATUSES = {\"PAID\", \"LOGGED\", \"RECONCILED\", \"REVIEWED\"}\n\n        # Helper function to check if Detail Item data has changed\n        def _detail_item_has_changes(existing_di, new_data):\n            \"\"\"\n            Compare relevant DetailItem fields to see if there's any difference\n            between what's in the database (existing_di) and the incoming data (new_data).\n\n            **Date fields are compared by day/month/year only, ignoring time.**\n            \"\"\"\n            from datetime import datetime\n\n            def to_date(value):\n                \"\"\"\n                Safely convert a string or datetime value to a date (YYYY-MM-DD).\n                If parsing fails or value is None, return the raw value or None.\n                \"\"\"\n                if not value:\n                    return None\n                if isinstance(value, datetime):\n                    return value.date()\n                if isinstance(value, str):\n                    # Try ISO format first\n                    try:\n                        parsed_dt = datetime.fromisoformat(value)\n                        return parsed_dt.date()\n                    except ValueError:\n                        # Fallback to a basic YYYY-MM-DD parse\n                        try:\n                            parsed_dt = datetime.strptime(value, \"%Y-%m-%d\")\n                            return parsed_dt.date()\n                        except:\n                            # If all else fails, return the raw string\n                            return value\n                return value\n\n            old_date = to_date(existing_di.get(\"transaction_date\"))\n            new_date = to_date(new_data.get(\"date\"))\n            if old_date != new_date:\n                return True\n\n            old_due = to_date(existing_di.get(\"due_date\"))\n            new_due = to_date(new_data.get(\"due date\"))\n            if old_due != new_due:\n                return True\n\n            # Compare numeric/string fields directly\n            if existing_di.get(\"vendor\") != new_data.get(\"vendor\"):\n                return True\n            if existing_di.get(\"description\") != new_data.get(\"description\"):\n                return True\n            if float(existing_di.get(\"rate\", 0)) != float(new_data.get(\"rate\", 0)):\n                return True\n            if float(existing_di.get(\"quantity\", 1)) != float(new_data.get(\"quantity\", 1)):\n                return True\n            if float(existing_di.get(\"ot\", 0)) != float(new_data.get(\"OT\", 0)):\n                return True\n            if float(existing_di.get(\"fringes\", 0)) != float(new_data.get(\"fringes\", 0)):\n                return True\n            if (existing_di.get(\"state\") or \"\").upper() != (new_data.get(\"state\") or \"\").upper():\n                return True\n            if existing_di.get(\"account_code\") != new_data.get(\"account\"):\n                return True\n            if existing_di.get(\"payment_type\") != new_data.get(\"payment_type\"):\n                return True\n\n            return False\n\n        # region 5) Create or update each detail_item\n        for sub_item in detail_items:\n            po_number = None\n            detail_number = None\n            line_number = None\n            try:\n                # Skip if PO number is below debug threshold\n                if self.DEBUG_STARTING_PO_NUMBER and int(sub_item[\"po_number\"]) < self.DEBUG_STARTING_PO_NUMBER:\n                    continue\n\n                po_number = int(sub_item[\"po_number\"])\n                detail_number = int(sub_item[\"detail_item_id\"])\n                line_number = int(sub_item[\"line_number\"])\n                key = (po_number, detail_number, line_number)\n                existing_di = detail_dict.get(key)\n\n                # If existing => update, unless in final state\n                if existing_di:\n                    current_state = (existing_di[\"state\"] or \"\").upper()\n                    if current_state in COMPLETED_STATUSES:\n                        self.logger.info(\n                            f\"\u23ed DetailItem {key} is in final state '{current_state}'. Skipping update.\"\n                        )\n                        continue  # Skip any updates\n\n                    if _detail_item_has_changes(existing_di, sub_item):\n                        self.logger.info(f\"\ud83d\udd04 Updating existing DetailItem {key} in the database.\")\n                        updated_di = self.database_util.update_detail_item_by_keys(\n                            project_number=pn_int,\n                            po_number=po_number,\n                            detail_number=detail_number,\n                            line_number=line_number,\n                            vendor=sub_item.get(\"vendor\"),\n                            description=sub_item.get(\"description\"),\n                            transaction_date=sub_item.get(\"date\"),\n                            due_date=sub_item.get(\"due date\"),\n                            rate=sub_item.get(\"rate\", 0),\n                            quantity=sub_item.get(\"quantity\", 1),\n                            ot=sub_item.get(\"OT\", 0),\n                            fringes=sub_item.get(\"fringes\", 0),\n                            state=sub_item[\"state\"],\n                            account_code=sub_item[\"account\"],\n                            payment_type=sub_item[\"payment_type\"]\n                        )\n                        if updated_di:\n                            detail_dict[key] = updated_di  # refresh local dict\n                    else:\n                        self.logger.debug(f\"\u23ed No changes detected for existing DetailItem {key}. Skipping update.\")\n                else:\n                    # Create new detail item\n                    self.logger.debug(f\"\ud83c\udd95 Creating detail item {key}\")\n                    new_di = self.database_util.create_detail_item_by_keys(\n                        project_number=pn_int,\n                        po_number=po_number,\n                        detail_number=detail_number,\n                        line_number=line_number,\n                        vendor=sub_item.get(\"vendor\"),\n                        description=sub_item.get(\"description\"),\n                        transaction_date=sub_item.get(\"date\"),\n                        due_date=sub_item.get(\"due date\"),\n                        rate=sub_item.get(\"rate\", 0),\n                        quantity=sub_item.get(\"quantity\", 1),\n                        ot=sub_item.get(\"OT\", 0),\n                        fringes=sub_item.get(\"fringes\", 0),\n                        state=sub_item[\"state\"],\n                        account_code=sub_item[\"account\"],\n                        payment_type=sub_item[\"payment_type\"]\n                    )\n                    if new_di:\n                        detail_dict[key] = new_di\n            except Exception as ex:\n                self.logger.error(\n                    f\"\ud83d\udca5 Error processing DetailItem creation/update for PO={po_number}, \"\n                    f\"detail={detail_number}, line={line_number}: {ex}\",\n                    exc_info=True\n                )\n\n        self.logger.info(\"\u2705 [NEW BATCH LOGIC] Completed batch PO & DetailItem processing.\")\n        return main_items"
                    },
                    {
                        "name": "_find_or_create_contact",
                        "args": [
                            "self",
                            "item",
                            "contacts",
                            "index",
                            "all_db_contacts"
                        ],
                        "decorators": [],
                        "calls": [
                            "find_contact_close_match",
                            "create_minimal_contact"
                        ],
                        "docstring": "Helper to match or create a contact from the 'main_items' list\n(or any data structure containing 'contact_name').",
                        "function_body": "    def _find_or_create_contact(self, item, contacts, index, all_db_contacts):\n        \"\"\"\n        Helper to match or create a contact from the 'main_items' list\n        (or any data structure containing 'contact_name').\n        \"\"\"\n        contact_name = item.get(\"contact_name\")\n        if not contact_name:\n            return None\n\n        self.logger.info(f\"\ud83d\udd0d Checking for Contact: {contact_name}\")\n        contact_search = self.database_util.find_contact_close_match(contact_name, all_db_contacts)\n        if contact_search:\n            if isinstance(contact_search, list):\n                contact_search = contact_search[0]\n            contact_id = contact_search[\"id\"]\n        else:\n            self.logger.info(f\"\ud83c\udd95 Creating Contact: {contact_name}\")\n            new_contact = self.database_util.create_minimal_contact(contact_name)\n            contact_id = new_contact[\"id\"] if new_contact else None\n\n        return contact_id    # endregion"
                    },
                    {
                        "name": "callback_add_po_data_to_DB",
                        "args": [
                            "self",
                            "fut"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def callback_add_po_data_to_DB(self, fut):\n        return fut.result()"
                    },
                    {
                        "name": "process_invoice",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_invoice_by_keys",
                            "extract_text",
                            "create_invoice",
                            "get_file_link",
                            "download_file_from_dropbox",
                            "update_invoice",
                            "cleanup_temp_file",
                            "extract_info_with_openai"
                        ],
                        "docstring": "Minimal 'process_invoice' that only inserts or updates an 'invoice' record\nin the DB (plus a share link). All other logic (detail item linking, sum checks,\nRTP vs. MISMATCH, etc.) is handled by the triggers in invoice_receipt_triggers.py.",
                        "function_body": "    def process_invoice(self, dropbox_path: str):\n        \"\"\"\n        Minimal 'process_invoice' that only inserts or updates an 'invoice' record\n        in the DB (plus a share link). All other logic (detail item linking, sum checks,\n        RTP vs. MISMATCH, etc.) is handled by the triggers in invoice_receipt_triggers.py.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udcc4 Processing invoice: {dropbox_path}\")\n        filename = os.path.basename(dropbox_path)\n\n        # 1) Extract project_number, po_number, invoice_number from filename\n        try:\n            match = re.match(r\"^(\\d{4})_(\\d{1,2})(?:_(\\d{1,2}))?\", filename)\n            if not match:\n                self.logger.warning(f\"\u26a0\ufe0f Invoice filename '{filename}' doesn't match the expected pattern.\")\n                return\n            project_number_str = match.group(1)\n            po_number_str = match.group(2)\n            invoice_number_str = match.group(3) or \"1\"\n\n            project_number = int(project_number_str)\n            po_number = int(po_number_str)\n            invoice_number = int(invoice_number_str)\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error parsing invoice filename '{filename}': {e}\", exc_info=True)\n            return\n\n        # 2) Try to get the Dropbox share link *first* so we can store it at creation/update time\n        try:\n            file_share_link = self.dropbox_util.get_file_link(dropbox_path)\n            self.logger.info(f\"\ud83d\udd17 Obtained Dropbox link for invoice: {file_share_link}\")\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error retrieving Dropbox link: {e}\", exc_info=True)\n            file_share_link = None\n\n        # 3) Download file from Dropbox\n        temp_file_path = f\"./temp_files/{filename}\"\n        if not self.download_file_from_dropbox(dropbox_path, temp_file_path):\n            self.logger.error(f\"\u274c Could not download invoice file: {dropbox_path}\")\n            return\n\n        # 4) Attempt to parse out invoice fields (date, term, total) via OCR\n        transaction_date, term, total = None, 30, 0.0\n        try:\n            self.logger.info(\"\ud83d\udd0e Scanning invoice file for data with OCRService + OpenAI...\")\n            extracted_text = self.ocr_service.extract_text(temp_file_path)\n            info, err = self.ocr_service.extract_info_with_openai(extracted_text)\n            if err or not info:\n                self.logger.warning(f\"\u274c Could not parse invoice data from OpenAI. Using defaults. Error: {err}\")\n            else:\n                # Date\n                date_str = info.get(\"invoice_date\")\n                try:\n                    if date_str:\n                        transaction_date = datetime.strptime(date_str, \"%Y-%m-%d\")\n                except (ValueError, TypeError):\n                    transaction_date = None\n\n                # Total\n                total_str = info.get(\"total_amount\")\n                try:\n                    total = float(total_str) if total_str else 0.0\n                except (ValueError, TypeError):\n                    total = 0.0\n\n                # Term\n                term_str = info.get(\"payment_term\")\n                if term_str:\n                    digits_only = re.sub(r\"[^0-9]\", \"\", term_str)\n                    try:\n                        t_val = int(digits_only) if digits_only else 30\n                        if 7 <= t_val <= 60:\n                            term = t_val\n                    except Exception:\n                        term = 30\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error extracting invoice data: {e}\", exc_info=True)\n\n        # 5) Create/update the Invoice record (including the share link) in one go\n        try:\n            existing_invoice = self.database_util.search_invoice_by_keys(project_number=str(project_number),\n                                                                         po_number=str(po_number),\n                                                                         invoice_number=str(invoice_number))\n            if existing_invoice is None:\n                self.logger.info(\n                    f\"\ud83c\udd95 Creating new invoice #{invoice_number} for PO {po_number} (project {project_number}).\"\n                )\n                new_invoice = self.database_util.create_invoice(\n                    project_number=project_number,\n                    po_number=po_number,\n                    invoice_number=invoice_number,\n                    transaction_date=transaction_date,\n                    term=term,\n                    total=total,\n                    file_link=file_share_link  # Store link here at creation\n                )\n                invoice_id = new_invoice[\"id\"] if new_invoice else None\n            else:\n                if isinstance(existing_invoice, list):\n                    invoice_id = existing_invoice[0][\"id\"]\n                else:\n                    invoice_id = existing_invoice[\"id\"]\n                self.logger.info(\n                    f\"\ud83d\udd04 Updating existing invoice #{invoice_number} for PO {po_number}.\"\n                )\n                self.database_util.update_invoice(\n                    invoice_id=invoice_id,\n                    transaction_date=transaction_date,\n                    term=term,\n                    total=total,\n                    file_link=file_share_link  # Update link here at the same time\n                )\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error creating/updating invoice in DB: {e}\", exc_info=True)\n            self.cleanup_temp_file(temp_file_path)\n            return\n\n        # 6) Clean up the local temp file\n        self.cleanup_temp_file(temp_file_path)\n        self.logger.info(f\"\u2705 Minimal invoice processing complete for: {dropbox_path}\")"
                    },
                    {
                        "name": "process_receipt",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_receipt",
                            "_extract_text_via_ocr",
                            "update_detail_item_by_keys",
                            "get_file_link",
                            "_extract_text_from_pdf",
                            "download_file_from_dropbox",
                            "search_receipts",
                            "search_detail_item_by_keys",
                            "update_receipt_by_keys",
                            "extract_receipt_info_with_openai",
                            "cleanup_temp_file"
                        ],
                        "docstring": "\ud83e\uddfe process_receipt\n-----------------\n1) Parse file name (project_number, po_number, detail_number, vendor_name).\n2) Download the receipt file from Dropbox.\n3) If PDF, try text extraction via PyPDF2. If that fails (or not a PDF), do OCR.\n4) Use OCRService's 'extract_receipt_info_with_openai' to parse total, date, description.\n5) Generate file link in Dropbox.\n6) Create or update the 'receipt' table, linking to the appropriate detail item *via project_number, po_number, detail_number*.\n7) Update the corresponding subitem in Monday with the link.\n8) # ADDED/CHANGED: After we create or update the receipt, update that detail item with the `receipt_id`.",
                        "function_body": "    def process_receipt(self, dropbox_path: str):\n        \"\"\"\n        \ud83e\uddfe process_receipt\n        -----------------\n        1) Parse file name (project_number, po_number, detail_number, vendor_name).\n        2) Download the receipt file from Dropbox.\n        3) If PDF, try text extraction via PyPDF2. If that fails (or not a PDF), do OCR.\n        4) Use OCRService's 'extract_receipt_info_with_openai' to parse total, date, description.\n        5) Generate file link in Dropbox.\n        6) Create or update the 'receipt' table, linking to the appropriate detail item *via project_number, po_number, detail_number*.\n        7) Update the corresponding subitem in Monday with the link.\n        8) # ADDED/CHANGED: After we create or update the receipt, update that detail item with the `receipt_id`.\n        \"\"\"\n\n        self.logger.info(f\"\ud83e\uddfe Processing receipt: {dropbox_path}\")\n        temp_file_path = f\"./temp_files/{os.path.basename(dropbox_path)}\"\n\n        filename = os.path.basename(dropbox_path)\n\n        # ---------------------------------------------\n        # 1) Detect if it's petty cash or credit card\n        # ---------------------------------------------\n        is_petty_cash = (\n            \"3. Petty Cash\" in dropbox_path\n            or \"Crew PC Folders\" in dropbox_path\n            or filename.startswith(\"PC_\")\n        )\n\n        # ---------------------------------------------\n        # 2) Regex pattern\n        # ---------------------------------------------\n        pattern = r'^(?:PC_)?(\\d{4})_(\\d{2})_(\\d{2})\\s+(.*?)\\s+Receipt\\.(pdf|jpe?g|png)$'\n        match = re.match(pattern, filename, re.IGNORECASE)\n\n        if not match:\n            self.logger.warning(f\"\u274c Filename '{filename}' does not match receipt pattern.\")\n            return\n\n        project_number_str = match.group(1)\n        group2_str = match.group(2).lstrip(\"0\")\n        group3_str = match.group(3).lstrip(\"0\")\n        vendor_name = match.group(4)\n        file_ext = match.group(5).lower()\n\n        # ---------------------------------------------\n        # 3) Determine PO #, detail #, line #\n        # ---------------------------------------------\n        if is_petty_cash:\n            po_number_str = \"1\"\n            detail_item_str = group2_str\n            line_number_str = group3_str\n        else:\n            po_number_str = group2_str\n            detail_item_str = group3_str\n            line_number_str = \"1\"\n\n        project_number = int(project_number_str)\n        po_number = int(po_number_str)\n        detail_number = int(detail_item_str)\n        line_number_number = int(line_number_str)\n\n        try:"
                    },
                    {
                        "name": "process_tax_form",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Stub function for processing a tax form from Dropbox.\nCould perform OCR, fill out contact tax_form_link, etc.",
                        "function_body": "    def process_tax_form(self, dropbox_path: str):\n        \"\"\"\n        Stub function for processing a tax form from Dropbox.\n        Could perform OCR, fill out contact tax_form_link, etc.\n        \"\"\"\n        self.logger.info(f\"\ud83d\uddc2 Processing Tax Form: {dropbox_path}\")\n        # ...\n        pass"
                    },
                    {
                        "name": "folder_tax_conact_trigger",
                        "args": [
                            "self",
                            "fut"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_monday_tax_form_link",
                            "search_contacts",
                            "create_pos_in_monday",
                            "search_projects",
                            "update_po_folder_link",
                            "update_po_tax_form_links",
                            "search_purchase_orders"
                        ],
                        "docstring": "Callback for when the DB process is complete.\nPossibly triggers Monday or Dropbox tasks next.",
                        "function_body": "    def folder_tax_conact_trigger(self, fut):\n        \"\"\"\n        Callback for when the DB process is complete.\n        Possibly triggers Monday or Dropbox tasks next.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "update_po_folder_link",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_project_po_folders_with_link",
                            "search_purchase_order_by_keys",
                            "update_purchase_order"
                        ],
                        "docstring": null,
                        "function_body": "    def update_po_folder_link(self, project_number, po_number):\n        logger = self.logger\n        logger.info(f\"\ud83d\ude80Finding folder link for PO: {project_number}_{str(po_number).zfill(2)}\")\n\n        try:"
                    },
                    {
                        "name": "update_po_tax_form_links",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_order_by_keys",
                            "update_contact",
                            "get_po_tax_form_link"
                        ],
                        "docstring": "\ud83d\ude80 Update or set the tax_form_link for a PurchaseOrder in Dropbox if needed.\nStub method to illustrate how you'd update the 'tax_form_link' column.",
                        "function_body": "    def update_po_tax_form_links(self, project_number, po_number):\n        \"\"\"\n        \ud83d\ude80 Update or set the tax_form_link for a PurchaseOrder in Dropbox if needed.\n        Stub method to illustrate how you'd update the 'tax_form_link' column.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "create_pos_in_monday",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_account_codes",
                            "update_purchase_order",
                            "update_purchase_order_by_keys",
                            "update_detail_item_by_keys",
                            "search_invoices",
                            "is_main_item_different",
                            "search_purchase_order_by_keys",
                            "get_subitems_in_board",
                            "subitem_column_values_formatter",
                            "get_items_in_project",
                            "search_detail_item_by_keys",
                            "_batch_create_subitems",
                            "is_sub_item_different",
                            "po_column_values_formatter",
                            "search_contacts",
                            "extract_subitem_identifiers",
                            "search_receipts",
                            "batch_create_or_update_items",
                            "_batch_update_subitems"
                        ],
                        "docstring": "Demonstrates how to fetch all subitems once from Monday,\nthen process them locally to avoid multiple queries.",
                        "function_body": "    def create_pos_in_monday(self, project_number):\n        \"\"\"\n        Demonstrates how to fetch all subitems once from Monday,\n        then process them locally to avoid multiple queries.\n        \"\"\"\n        self.logger.info(\"\ud83c\udf10 Processing PO data in Monday.com...\")\n\n        # -------------------------------------------------------------------------\n        # 1) FETCH MAIN ITEMS FROM MONDAY & FROM DB\n        # -------------------------------------------------------------------------\n        monday_items = self.monday_api.get_items_in_project(project_id=project_number)\n        processed_items = self.database_util.search_purchase_order_by_keys(project_number=project_number)\n\n        # Build a map for main items\n        monday_items_map = {}\n        for mi in monday_items:\n            pid = mi[\"column_values\"].get(self.monday_util.PO_PROJECT_ID_COLUMN)[\"text\"]\n            pono = mi[\"column_values\"].get(self.monday_util.PO_NUMBER_COLUMN)[\"text\"]\n            if pid and pono:\n                monday_items_map[(int(pid), int(pono))] = mi\n\n        # -------------------------------------------------------------------------\n        # 2) FETCH ALL SUBITEMS AT ONCE (FOR ENTIRE SUBITEM BOARD)\n        # -------------------------------------------------------------------------\n        all_subitems = self.monday_api.get_subitems_in_board(project_number=project_number)\n\n        # -------------------------------------------------------------------------\n        # 3) BUILD A GLOBAL DICTIONARY FOR SUBITEM LOOKUP\n        #    Keyed by (project_number, po_number, detail_number, line_number)\n        # -------------------------------------------------------------------------\n        global_subitem_map = {}\n        for msub in all_subitems:\n            identifiers = self.monday_util.extract_subitem_identifiers(msub)\n            if identifiers is not None:\n                global_subitem_map[identifiers] = msub\n\n        # -------------------------------------------------------------------------\n        # 4) DETERMINE WHICH MAIN ITEMS NEED CREATION/UPDATE\n        # -------------------------------------------------------------------------\n        items_to_create = []\n        items_to_update = []\n\n        for db_item in processed_items:\n            contact_item = self.database_util.search_contacts(['id'], [db_item[\"contact_id\"]])\n            db_item[\"contact_pulse_id\"] = contact_item[\"pulse_id\"]\n            db_item[\"contact_name\"] = contact_item[\"name\"]\n            db_item[\"project_number\"] = project_number\n\n            p_id = project_number\n            po_no = int(db_item[\"po_number\"])\n\n            column_values_str = self.monday_util.po_column_values_formatter(\n                project_id=str(project_number),\n                po_number=db_item[\"po_number\"],\n                description=db_item.get(\"description\"),\n                contact_pulse_id=db_item[\"contact_pulse_id\"],\n                folder_link=db_item.get(\"folder_link\"),\n                producer_id=None,\n                name=db_item[\"contact_name\"]\n            )\n            new_vals = json.loads(column_values_str)\n\n            key = (p_id, po_no)\n            if key in monday_items_map:\n                monday_item = monday_items_map[key]\n                differences = self.monday_util.is_main_item_different(db_item, monday_item)\n                if differences:\n                    self.logger.debug(f\"Item differs for PO {po_no}. Differences: {differences}\")\n                    items_to_update.append({\n                        \"db_item\": db_item,\n                        \"column_values\": new_vals,\n                        \"monday_item_id\": monday_item[\"id\"]\n                    })\n                else:\n                    self.logger.debug(f\"No changes for PO {po_no}, skipping update.\")\n            else:\n                items_to_create.append({\n                    \"db_item\": db_item,\n                    \"column_values\": new_vals,\n                    \"monday_item_id\": None\n                })\n\n        # -------------------------------------------------------------------------\n        # 5) CREATE/UPDATE MAIN ITEMS\n        # -------------------------------------------------------------------------\n        if items_to_create:\n            self.logger.info(f\"\ud83c\udd95 Need to create {len(items_to_create)} main items on Monday.\")\n            created_mapping = self.monday_api.batch_create_or_update_items(\n                items_to_create, project_id=project_number, create=True\n            )\n            for itm in created_mapping:\n                db_item = itm[\"db_item\"]\n                monday_item_id = itm[\"monday_item_id\"]\n                self.database_util.update_purchase_order(db_item[\"id\"], pulse_id=monday_item_id)\n                db_item[\"pulse_id\"] = monday_item_id\n                p = project_number\n                po = int(db_item[\"po_number\"])\n                monday_items_map[(p, po)] = {\n                    \"id\": monday_item_id,\n                    \"name\": f\"PO #{po}\",\n                    \"column_values\": itm[\"column_values\"]\n                }\n\n        if items_to_update:\n            self.logger.info(f\"\u270f\ufe0f Need to update {len(items_to_update)} main items on Monday.\")\n            updated_mapping = self.monday_api.batch_create_or_update_items(\n                items_to_update, project_id=project_number, create=False\n            )\n            for itm in updated_mapping:\n                db_item = itm[\"db_item\"]\n                monday_item_id = itm[\"monday_item_id\"]\n                self.database_util.update_purchase_order_by_keys(\n                    project_number, db_item[\"po_number\"], pulse_id=monday_item_id\n                )\n                db_item[\"pulse_id\"] = monday_item_id\n                p = project_number\n                po = int(db_item[\"po_number\"])\n                monday_items_map[(p, po)][\"column_values\"] = itm[\"column_values\"]\n\n        # Ensure all main items have pulse_ids\n        for db_item in processed_items:\n            p_id = project_number\n            po_no = int(db_item[\"po_number\"])\n            main_monday_item = monday_items_map.get((p_id, po_no))\n            if main_monday_item and not db_item.get(\"pulse_id\"):\n                monday_item_id = main_monday_item[\"id\"]\n                updated = self.database_util.update_purchase_order_by_keys(\n                    project_number, db_item[\"po_number\"], pulse_id=monday_item_id\n                )\n                if updated:\n                    db_item[\"pulse_id\"] = monday_item_id\n                    self.logger.info(f\"\ud83d\uddc2 PO {po_no} now has pulse_id {monday_item_id} in DB\")\n\n        # -------------------------------------------------------------------------\n        # 6) CREATE/UPDATE SUBITEMS\n        # -------------------------------------------------------------------------\n        for db_item in processed_items:\n            p_id = project_number\n            po_no = int(db_item[\"po_number\"])\n            main_monday_item = monday_items_map.get((p_id, po_no))\n            if not main_monday_item:\n                self.logger.warning(f\"\u274c No Monday main item found for PO {po_no}, skipping subitems.\")\n                continue\n\n            main_monday_id = main_monday_item[\"id\"]\n            sub_items_db = self.database_util.search_detail_item_by_keys(project_number, db_item[\"po_number\"])\n\n            if isinstance(sub_items_db, dict):\n                sub_items_db = [sub_items_db]\n\n            subitems_to_create = []\n            subitems_to_update = []\n            if not sub_items_db:\n                pass\n\n            for sdb in sub_items_db:\n                # Attempt to look up an account code if present\n                if sdb.get(\"account_code_id\"):\n                    account_row = self.database_util.search_account_codes([\"id\"], [sdb[\"account_code_id\"]])\n                    sdbcode = account_row[\"code\"] if account_row else None\n                else:\n                    sdb[\"account_code\"] = None\n\n                # --------------------------\n                # # CHANGED or ADDED:\n                # Always see if there's a receipt or invoice link we can attach\n                # --------------------------\n                file_link_for_subitem = \"\"\n                if db_item[\"po_type\"] in [\"PC\", \"CC\"]:\n                    receipt_id = sdb.get(\"receipt_id\")\n                    if receipt_id:\n                        existing_receipt = self.database_util.search_receipts([\"id\"], [receipt_id])\n                        if existing_receipt and existing_receipt.get(\"file_link\"):\n                            file_link_for_subitem = existing_receipt[\"file_link\"]\n                    else:\n                        # Possibly there's a newly discovered receipt:\n                        existing_receipts = self.database_util.search_receipts(\n                            [\"project_number\", \"po_number\", \"detail_number\", \"line_number\"],\n                            [project_number, int(po_no), sdb[\"detail_number\"], sdb[\"line_number\"]]\n                        )\n                        if existing_receipts:\n                            first_receipt = existing_receipts[0] if isinstance(existing_receipts, list) else existing_receipts\n                            file_link_for_subitem = first_receipt.get(\"file_link\", \"\")\n                            rid = first_receipt.get(\"id\")\n                            # update DB detail_item with that receipt_id\n                            self.database_util.update_detail_item_by_keys(\n                                project_number=p_id,\n                                po_number=db_item[\"po_number\"],\n                                detail_number=sdb[\"detail_number\"],\n                                line_number=sdb[\"line_number\"],\n                                receipt_id=rid\n                            )\n                            sdb[\"receipt_id\"] = rid\n                elif db_item[\"po_type\"] in [\"INV\", \"PROJ\"]:\n                    # Possibly there's a newly discovered invoice:\n                    invoice_id = sdb.get(\"invoice_id\")\n                    if invoice_id:\n                        existing_invoice = self.database_util.search_invoices([\"id\"], [invoice_id])\n                        if existing_invoice and existing_invoice.get(\"file_link\"):\n                            file_link_for_subitem = existing_invoice[\"file_link\"]\n                    else:\n                        # If this detail item doesn't have an invoice_id yet, let's look it up\n                        existing_invoices = self.database_util.search_invoices(\n                            [\"project_number\", \"po_number\", \"invoice_number\", ],\n                            [project_number, int(po_no), sdb[\"detail_number\"]]\n                        )\n                        if existing_invoices:\n                            first_invoice = existing_invoices[0] if isinstance(existing_invoices, list) else existing_invoices\n                            file_link_for_subitem = first_invoice.get(\"file_link\", \"\")\n                            inv_id = first_invoice.get(\"id\")\n                            # Update DB detail_item with that invoice_id\n                            self.database_util.update_detail_item_by_keys(\n                                project_number=p_id,\n                                po_number= str(po_no),\n                                detail_number=sdb[\"detail_number\"],\n                                line_number=sdb[\"line_number\"],\n                                invoice_id=inv_id\n                            )\n                            sdb[\"invoice_id\"] = inv_id\n\n                # Build the subitem column values\n                sub_col_values_str = self.monday_util.subitem_column_values_formatter(\n                    project_id=project_number,\n                    po_number=db_item[\"po_number\"],\n                    detail_number=sdb[\"detail_number\"],\n                    line_number=sdb[\"line_number\"],\n                    status=sdb.get(\"state\"),\n                    description=sdb.get(\"description\"),\n                    quantity=sdb.get(\"quantity\"),\n                    rate=sdb.get(\"rate\"),\n                    date=sdb.get(\"transaction_date\"),\n                    due_date=sdb.get(\"due_date\"),\n                    account_number=sdb[\"account_code\"],\n                    link=file_link_for_subitem,\n                    OT=sdb.get(\"ot\"),\n                    fringes=sdb.get(\"fringes\")\n                )\n                new_sub_vals = json.loads(sub_col_values_str)\n\n                sub_key = (project_number, db_item[\"po_number\"], sdb[\"detail_number\"], sdb[\"line_number\"])\n\n                if sub_key in global_subitem_map:\n                    # Possibly update\n                    msub = global_subitem_map[sub_key]\n\n                    # Tag extra info\n                    sdb[\"project_number\"] = db_item[\"project_number\"]\n                    sdb[\"po_number\"] = db_item[\"po_number\"]\n                    sdb[\"file_link\"] = file_link_for_subitem\n                    payment_type = db_item[\"po_type\"]\n\n                    # Compare local data vs Monday subitem\n                    differences = self.monday_util.is_sub_item_different(sdb, msub)\n\n                    if differences:\n                        self.logger.debug(\n                            f\"Sub-item differs for detail #{sdb['detail_number']} (PO {po_no}). {differences}\"\n                        )\n                        subitems_to_update.append({\n                            \"db_sub_item\": sdb,\n                            \"column_values\": new_sub_vals,\n                            \"parent_id\": main_monday_id,\n                            \"monday_item_id\": msub[\"id\"]\n                        })\n                    else:\n                        # -------------------------------------\n                        # NO COLUMN CHANGES => CHECK sdb PULSE\n                        # -------------------------------------\n                        self.logger.debug(\n                            f\"No changes for detail #{sdb['detail_number']} (PO {po_no}).\"\n                        )\n                        sub_pulse_id = msub[\"id\"]\n\n                        # Only update DB if sdb doesn't have the correct pulse_id/parent_pulse_id\n                        current_pulse_id = sdb.get(\"pulse_id\")\n                        current_parent_id = sdb.get(\"parent_pulse_id\")\n\n                        if current_pulse_id != int(sub_pulse_id) or current_parent_id != int(main_monday_id):\n                            self.logger.debug(\n                                f\"Pulse mismatch for detail #{sdb['detail_number']} (PO {po_no}). \"\n                                f\"DB has pulse_id={current_pulse_id}, parent_pulse_id={current_parent_id}; \"\n                                f\"Monday is {sub_pulse_id}, {main_monday_id}.\"\n                            )\n                            self.database_util.update_detail_item_by_keys(\n                                project_number=project_number,\n                                po_number=db_item[\"po_number\"],\n                                detail_number=sdb[\"detail_number\"],\n                                line_number=sdb[\"line_number\"],\n                                pulse_id=sub_pulse_id,\n                                parent_pulse_id=main_monday_id\n                            )\n                            sdb[\"pulse_id\"] = sub_pulse_id\n                            sdb[\"parent_pulse_id\"] = main_monday_id\n                        else:\n                            self.logger.debug(\n                                f\"Pulse IDs already match for detail #{sdb['detail_number']} (PO {po_no}), no DB update needed.\"\n                            )\n                else:\n                    # Need to create\n                    subitems_to_create.append({\n                        \"db_sub_item\": sdb,\n                        \"column_values\": new_sub_vals,\n                        \"parent_id\": main_monday_id\n                    })\n\n            # -----------------------\n            # SUB-ITEM CREATE (BATCH)\n            # -----------------------\n            if subitems_to_create:\n                self.logger.info(f\"\ud83c\udd95 Need to create {len(subitems_to_create)} sub-items for PO {po_no}.\")\n                self._batch_create_subitems(subitems_to_create, main_monday_id, project_number, db_item)\n\n            # -----------------------\n            # SUB-ITEM UPDATE (BATCH)\n            # -----------------------\n            if subitems_to_update:\n                self.logger.info(f\"\u270f\ufe0f Need to update {len(subitems_to_update)} sub-items for PO {po_no}.\")\n                self._batch_update_subitems(subitems_to_update, main_monday_id, project_number, db_item)\n\n        self.logger.info(\"\u2705 Monday.com processing of PO data complete.\")\n        return processed_items"
                    },
                    {
                        "name": "_batch_create_subitems",
                        "args": [
                            "self",
                            "subitems_to_create",
                            "parent_item_id",
                            "project_number",
                            "db_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item_by_keys"
                        ],
                        "docstring": "Creates subitems in chunks, then updates DB with the new subitem IDs.",
                        "function_body": "    def _batch_create_subitems(self, subitems_to_create, parent_item_id, project_number, db_item):\n        \"\"\"\n        Creates subitems in chunks, then updates DB with the new subitem IDs.\n        \"\"\"\n        from concurrent.futures import ThreadPoolExecutor, as_completed\n\n        chunk_size = 10\n        create_chunks = [\n            subitems_to_create[i: i + chunk_size]\n            for i in range(0, len(subitems_to_create), chunk_size)\n        ]\n\n        all_created_subs = []\n        with ThreadPoolExecutor() as executor:\n            future_to_index = {}\n            for idx, chunk in enumerate(create_chunks):\n                future = executor.submit(\n                    self.monday_api.batch_create_or_update_subitems,\n                    chunk,\n                    parent_item_id=parent_item_id,\n                    create=True\n                )\n                future_to_index[future] = idx\n\n            for future in as_completed(future_to_index):\n                idx = future_to_index[future]\n                try:\n                    chunk_result = future.result()\n                    self.logger.debug(f\"Subitems create-chunk #{idx + 1} completed.\")\n                    all_created_subs.extend(chunk_result)\n                except Exception as e:\n                    self.logger.exception(f\"\u274c Error creating subitems in chunk {idx + 1}: {e}\")\n                    raise\n\n        # Update DB with newly-created subitem IDs\n        for csub in all_created_subs:"
                    },
                    {
                        "name": "_batch_update_subitems",
                        "args": [
                            "self",
                            "subitems_to_update",
                            "parent_item_id",
                            "project_number",
                            "db_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item_by_keys"
                        ],
                        "docstring": "Updates subitems in chunks, then updates DB with any new data (e.g., if we changed the link).",
                        "function_body": "    def _batch_update_subitems(self, subitems_to_update, parent_item_id, project_number, db_item):\n        \"\"\"\n        Updates subitems in chunks, then updates DB with any new data (e.g., if we changed the link).\n        \"\"\"\n        from concurrent.futures import ThreadPoolExecutor, as_completed\n\n        chunk_size = 10\n        update_chunks = [\n            subitems_to_update[i: i + chunk_size]\n            for i in range(0, len(subitems_to_update), chunk_size)\n        ]\n\n        all_updated_subs = []\n        with ThreadPoolExecutor() as executor:\n            future_to_index = {}\n            for idx, chunk in enumerate(update_chunks):\n                future = executor.submit(\n                    self.monday_api.batch_create_or_update_subitems,\n                    chunk,\n                    parent_item_id=parent_item_id,\n                    create=False\n                )\n                future_to_index[future] = idx\n\n            for future in as_completed(future_to_index):\n                idx = future_to_index[future]\n                try:\n                    chunk_result = future.result()\n                    self.logger.debug(f\"Subitems update-chunk #{idx + 1} completed.\")\n                    all_updated_subs.extend(chunk_result)\n                except Exception as e:\n                    self.logger.exception(f\"\u274c Error updating subitems in chunk {idx + 1}: {e}\")\n                    raise\n\n        # Update DB with newly-updated subitem data\n        for usub in all_updated_subs:"
                    },
                    {
                        "name": "download_file_from_dropbox",
                        "args": [
                            "self",
                            "path",
                            "temp_file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Download a file from Dropbox to a local temp_file_path.",
                        "function_body": "    def download_file_from_dropbox(self, path: str, temp_file_path: str) -> bool:\n        \"\"\"\n        Download a file from Dropbox to a local temp_file_path.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "_parse_tax_number",
                        "args": [
                            "self",
                            "tax_str"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Remove any hyphens from tax_str (e.g. SSN '123-45-6789' or EIN '12-3456789')\nand convert to integer. If parsing fails, return None.",
                        "function_body": "    def _parse_tax_number(self, tax_str: str) -> Optional[int]:\n        \"\"\"\n        Remove any hyphens from tax_str (e.g. SSN '123-45-6789' or EIN '12-3456789')\n        and convert to integer. If parsing fails, return None.\n        \"\"\"\n        if not tax_str:\n            return None\n\n        cleaned = tax_str.replace('-', '')\n        try:"
                    },
                    {
                        "name": "cleanup_temp_file",
                        "args": [
                            "self",
                            "temp_file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Attempt to remove a temporary file.",
                        "function_body": "    def cleanup_temp_file(self, temp_file_path: str):\n        \"\"\"\n        Attempt to remove a temporary file.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "extract_project_number",
                        "args": [
                            "self",
                            "file_name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_project_number(self, file_name: str) -> str:\n        digit_sequences = re.findall(r'\\d+', file_name)\n\n        if not digit_sequences:\n            raise ValueError(f\"\u2757 No digits found in file name: '{file_name}' \u2757\")\n\n        all_digits = ''.join(digit_sequences)\n\n        if len(all_digits) < 4:\n            raise ValueError(f\"\u2757 File name '{file_name}' does not contain at least four digits for project_id. \u2757\")\n\n        project_number = all_digits[:4]\n        return project_number"
                    },
                    {
                        "name": "_extract_text_from_pdf",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "_extract_text_via_ocr",
                            "extract_text"
                        ],
                        "docstring": null,
                        "function_body": "    def _extract_text_from_pdf(self, file_data: bytes) -> str:\n        import PyPDF2\n        import fitz\n        from io import BytesIO\n        from PIL import Image\n\n        Image.MAX_IMAGE_PIXELS = 200_000_000\n\n        self.logger.debug(f\"_extract_text_from_pdf: PDF data length={len(file_data)} bytes.\")\n\n        try:"
                    },
                    {
                        "name": "_extract_text_via_ocr",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_receipt"
                        ],
                        "docstring": null,
                        "function_body": "    def _extract_text_via_ocr(self, file_data: bytes) -> str:\n        try:"
                    },
                    {
                        "name": "scan_project_receipts",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_scan_and_process_receipts_in_folder",
                            "find_project_folder"
                        ],
                        "docstring": "Scans both credit-card/vendor receipt folders (under 1. Purchase Orders)\nand petty-cash receipt folders (under 3. Petty Cash/1. Crew PC Folders)\nfor the specified project_number, then processes matching receipts.",
                        "function_body": "    def scan_project_receipts(self, project_number: str):\n        \"\"\"\n        Scans both credit-card/vendor receipt folders (under 1. Purchase Orders)\n        and petty-cash receipt folders (under 3. Petty Cash/1. Crew PC Folders)\n        for the specified project_number, then processes matching receipts.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd0e Starting receipt scan for project_number={project_number}\")\n\n        # 1) Locate the *exact* project folder path under '2024' that contains the text \"project_number\"\n        #    Example folder name might be \"2416 - Whop Keynote\"\n        project_folder_path = self.dropbox_api.find_project_folder(project_number, namespace=\"2024\")\n        if not project_folder_path:\n            self.logger.warning(f\"\u274c Could not find a matching project folder for '{project_number}' under 2024.\")\n            return\n\n        self.logger.info(f\"\ud83d\udcc2 Project folder resolved: {project_folder_path}\")\n\n        # 2) Paths to check (relative to the found project folder):\n        #    - '1. Purchase Orders' for vendor/credit card receipts\n        #    - '3. Petty Cash/1. Crew PC Folders' for petty cash receipts\n        #    We will search each subfolder recursively for matching files.\n\n        purchase_orders_path = f\"{project_folder_path}/1. Purchase Orders\"\n        petty_cash_path = f\"{project_folder_path}/3. Petty Cash/1. Crew PC Folders\"\n\n        # 3) Recursively scan both directories:\n        #    We'll gather all 'receipt' files from vendor subfolders and petty-cash subfolders, then process them.\n        self._scan_and_process_receipts_in_folder(purchase_orders_path, project_number)\n        self._scan_and_process_receipts_in_folder(petty_cash_path, project_number)\n\n        self.logger.info(f\"\u2705 Finished scanning receipts for project_number={project_number}.\")"
                    },
                    {
                        "name": "_scan_and_process_receipts_in_folder",
                        "args": [
                            "self",
                            "folder_path",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_list_folder_recursive",
                            "process_receipt"
                        ],
                        "docstring": "Recursively scans the given folder_path and its subfolders, and whenever\nit finds a file that looks like a 'receipt' (based on your naming pattern),\ncalls process_receipt(...).",
                        "function_body": "    def _scan_and_process_receipts_in_folder(self, folder_path: str, project_number: str):\n        \"\"\"\n        Recursively scans the given folder_path and its subfolders, and whenever\n        it finds a file that looks like a 'receipt' (based on your naming pattern),\n        calls process_receipt(...).\n        \"\"\"\n        # 1) List all items (files + folders) in the current folder\n        entries = self._list_folder_recursive(folder_path)\n        if not entries:\n            self.logger.debug(f\"\ud83d\udcc2 No entries found under '{folder_path}'\")\n            return\n\n        # 2) For each file, see if it matches your existing naming pattern:\n        #    e.g. \"2416_04_03 Some Vendor Receipt.pdf\" OR \"PC_2416_04_03 Some Vendor Receipt.png\"\n        for entry in entries:"
                    },
                    {
                        "name": "_list_folder_recursive",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Recursively lists all entries (files and subfolders) under folder_path.\nReturn a list of entries, each entry is a dict containing\n{\n  \"name\": str,\n  \"path_lower\": str,\n  \"path_display\": str,\n  \"is_folder\": bool\n}",
                        "function_body": "    def _list_folder_recursive(self, folder_path: str):\n        \"\"\"\n        Recursively lists all entries (files and subfolders) under folder_path.\n        Return a list of entries, each entry is a dict containing\n        {\n          \"name\": str,\n          \"path_lower\": str,\n          \"path_display\": str,\n          \"is_folder\": bool\n        }\n        \"\"\"\n        from dropbox import files\n        results = []\n\n        try:\n            dbx = self.dropbox_client.dbx\n            # Initial request\n            res = dbx.files_list_folder(folder_path, recursive=True)\n\n            # Accumulate results\n            entries = res.entries\n            while res.has_more:\n                res = dbx.files_list_folder_continue(res.cursor)\n                entries.extend(res.entries)\n\n            # Convert each entry to a dict\n            for e in entries:\n                if isinstance(e, files.FolderMetadata):\n                    results.append({\n                        \"name\": e.name,\n                        \"path_lower\": e.path_lower,\n                        \"path_display\": e.path_display,\n                        \"is_folder\": True\n                    })\n                elif isinstance(e, files.FileMetadata):\n                    results.append({\n                        \"name\": e.name,\n                        \"path_lower\": e.path_lower,\n                        \"path_display\": e.path_display,\n                        \"is_folder\": False\n                    })\n        except Exception as ex:\n            self.logger.warning(f\"\u26a0\ufe0f Could not list folder recursively: {folder_path}, Error: {ex}\")\n\n        return results"
                    },
                    {
                        "name": "_scan_po_folder_for_invoices",
                        "args": [
                            "self",
                            "folder_path",
                            "project_number",
                            "folder_po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_list_folder_recursive",
                            "process_invoice"
                        ],
                        "docstring": "Given a subfolder that definitely references a valid PO with type='INV',\nscan the folder's files for invoice docs. Then call process_invoice(...)\nfor each matching file.",
                        "function_body": "    def _scan_po_folder_for_invoices(self, folder_path: str, project_number: str, folder_po_number: str):\n        \"\"\"\n        Given a subfolder that definitely references a valid PO with type='INV',\n        scan the folder's files for invoice docs. Then call process_invoice(...)\n        for each matching file.\n        \"\"\"\n        entries = self._list_folder_recursive(folder_path)\n        if not entries:\n            return\n\n        for entry in entries:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_service",
                "value": "DropboxService()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_util.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "parse_file_name",
                        "args": [
                            "self",
                            "file_name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse the file name to extract metadata.",
                        "function_body": "    def parse_file_name(self, file_name: str) -> Dict[str, str]:\n        \"\"\"Parse the file name to extract metadata.\"\"\"\n        # Assuming file name format: PO123_VendorName_20231118_invoice.pdf\n        parts = file_name.split('_')\n        if len(parts) < 4:\n            raise ValueError(\"Invalid file name format.\")\n        po_number = parts[0]\n        file_type = parts[-1].split('.')[0]  # 'invoice.pdf' -> 'invoice'\n        return {'po_number': po_number, 'file_type': file_type}"
                    },
                    {
                        "name": "is_po_folder",
                        "args": [
                            "self",
                            "local_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Determines if the specified folder path is a valid PO folder within the correct project structure.\n\nExpected structure:\n    .../<Project Folder>/1. Purchase Orders/<PO Folder>\n\nArgs:\n    local_path (str): The path to the folder or file to check.\n\nReturns:\n    bool: True if the folder is a PO folder within the correct project structure, False otherwise.",
                        "function_body": "    def is_po_folder(self, local_path):\n        \"\"\"\n        Determines if the specified folder path is a valid PO folder within the correct project structure.\n\n        Expected structure:\n            .../<Project Folder>/1. Purchase Orders/<PO Folder>\n\n        Args:\n            local_path (str): The path to the folder or file to check.\n\n        Returns:\n            bool: True if the folder is a PO folder within the correct project structure, False otherwise.\n        \"\"\"\n        # Normalize path to use forward slashes\n        normalized_path = local_path.replace('\\\\', '/')\n        path_parts = normalized_path.strip('/').split('/')\n\n        # If the path points to a file, extract the parent folder\n        if '.' in path_parts[-1]:\n            folder_path = os.path.dirname(normalized_path)\n            path_parts = folder_path.strip('/').split('/')\n            self.logger.debug(\"Detected file path. Extracted parent folder path.\")\n        else:\n            folder_path = normalized_path\n\n        self.logger.debug(f\"Normalized Path Parts: {path_parts}\")\n\n        # Adjust path depth check based on your actual structure\n        if len(path_parts) < 3:\n            self.logger.debug(f\"Path '{local_path}' does not have enough parts to be a valid PO folder.\")\n            return False\n\n        # Extract key components from the path\n        folder_name = path_parts[-1]  # PO folder name\n        purchase_orders_folder = path_parts[-2]  # Should be \"1. Purchase Orders\"\n        project_folder = path_parts[-3]  # Project folder name\n\n        self.logger.debug(\n            f\"Checking PO folder: Project='{project_folder}', Purchase Orders='{purchase_orders_folder}', PO Folder='{folder_name}'\")\n\n        # Check if the folder name matches the expected PO folder pattern\n        po_folder_pattern = r'^(\\d+)[_-](\\d+)\\s+.*$'\n        if not re.match(po_folder_pattern, folder_name):\n            self.logger.debug(f\"Folder name '{folder_name}' does not match PO folder pattern.\")\n            return False\n\n        # Check if the \"1. Purchase Orders\" folder is correct (case-insensitive)\n        if purchase_orders_folder.lower() != \"1. purchase orders\":\n            self.logger.debug(f\"Expected '1. Purchase Orders', but found '{purchase_orders_folder}'.\")\n            return False\n\n        # Check if the project folder starts with a numeric project ID\n        project_pattern = r'^\\d+\\s*[-_]\\s*.*'\n        if not re.match(project_pattern, project_folder):\n            self.logger.debug(f\"Project folder '{project_folder}' does not match project pattern.\")\n            return False\n\n        # If all conditions are met, it's a valid PO folder in the correct structure\n        self.logger.debug(f\"Path '{local_path}' is a valid PO folder.\")\n        return True"
                    },
                    {
                        "name": "parse_folder_path",
                        "args": [
                            "self",
                            "local_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parses the folder path to extract the Project ID, PO Number, Vendor Name,\nand PO Type (vendor or cc).\n\nExpected folder structure: .../2024/Project Folder/Purchase Order Folder/...\nExample: '/Users/.../2024/2416 - Whop Keynote/1. Purchase Orders/2416_02 AMEX 8738/\n\nReturns:\n    Tuple (project_id, po_number, vendor_name, po_type) if found, else (None, None, None, None)",
                        "function_body": "    def parse_folder_path(self, local_path):\n        \"\"\"\n        Parses the folder path to extract the Project ID, PO Number, Vendor Name,\n        and PO Type (vendor or cc).\n\n        Expected folder structure: .../2024/Project Folder/Purchase Order Folder/...\n        Example: '/Users/.../2024/2416 - Whop Keynote/1. Purchase Orders/2416_02 AMEX 8738/\n\n        Returns:\n            Tuple (project_id, po_number, vendor_name, po_type) if found, else (None, None, None, None)\n        \"\"\"\n        # Split the path into parts\n        path_parts = local_path.split(os.sep)\n        self.logger.debug(f\"Path parts for parsing: {path_parts}\")\n        # Reverse to start searching from the deepest directory\n        path_parts_reversed = path_parts[::-1]\n\n        project_id = None\n        po_number = None\n        vendor_name = None\n        po_type = \"vendor\"  # default to vendor unless it's a credit card (cc) folder\n\n        self.logger.debug(f\"Parsing folder path: {local_path}\")\n\n        for part in path_parts_reversed:\n            self.logger.debug(f\"Checking folder part: '{part}'\")\n\n            # Match PO folder: e.g., '2416_02 AMEX 8738' or '2416-02 AMEX 8738'\n            po_match = re.match(r'^(\\d+)[_-](\\d+)\\s+(.*?)(\\d{4})?$', part)\n            if po_match:\n                po_number = po_match.group(2)\n                credit_card_digits = po_match.group(4)\n                vendor_name = po_match.group(3).strip()\n\n                # Check if the last four digits are present, indicating a credit card folder\n                if credit_card_digits:\n                    po_type = \"cc\"\n                    vendor_name += \" \" + credit_card_digits\n\n                self.logger.debug(\n                    f\"Found PO Number: '{po_number}', Vendor Name: '{vendor_name}', PO Type: '{po_type}' in folder part: '{part}'\")\n                continue\n\n            # Match Project folder: e.g., '2416 - Whop Keynote' or '2416_Whop Keynote'\n            project_match = re.match(r'^(\\d+)\\s*[-_]\\s*.*', part)\n            if project_match:\n                project_id = project_match.group(1)\n                self.logger.debug(f\"Found Project ID: '{project_id}' in folder part: '{part}'\")\n                continue\n\n            # If both Project ID and PO Number have been found, break\n            if project_id and po_number:\n                break\n\n        if project_id and po_number:"
                    },
                    {
                        "name": "parse_filename",
                        "args": [
                            "self",
                            "filename"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parses the filename to extract project_id, po_number, receipt_number (optional), vendor_name, file_type, and invoice_number.\nExpected filename formats:\n- '2417_10 Vendor Name Invoice.pdf'\n- '2417_10 Vendor Name Invoice 3.pdf'\n- '2417_10_03 Citibank Receipt.pdf'",
                        "function_body": "    def parse_filename(self, filename):\n        \"\"\"\n        Parses the filename to extract project_id, po_number, receipt_number (optional), vendor_name, file_type, and invoice_number.\n        Expected filename formats:\n        - '2417_10 Vendor Name Invoice.pdf'\n        - '2417_10 Vendor Name Invoice 3.pdf'\n        - '2417_10_03 Citibank Receipt.pdf'\n        \"\"\"\n        pattern = r'(?i)^(\\d+)_(\\d+)(?:_(\\d+))?\\s+(.+?)\\s+(Invoice|W9|Receipt|W8-BEN|W8-BEN-E)(?:\\s*(\\d+))?\\.(pdf|png|jpg|jpeg|tiff|bmp|heic)$'\n        match = re.match(pattern, filename, re.IGNORECASE)\n        if match:"
                    },
                    {
                        "name": "get_parent_path",
                        "args": [
                            "self",
                            "path_display"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Extracts the parent directory path from a given Dropbox path.\n\nArgs:\n    path_display (str): The full Dropbox path to a file or folder.\n\nReturns:\n    str: The parent directory path. Returns an empty string if no parent exists.",
                        "function_body": "    def get_parent_path(self, path_display):\n        \"\"\"\n        Extracts the parent directory path from a given Dropbox path.\n\n        Args:\n            path_display (str): The full Dropbox path to a file or folder.\n\n        Returns:\n            str: The parent directory path. Returns an empty string if no parent exists.\n        \"\"\"\n        if not path_display:\n            self.logger.error(\"Empty path_display provided to get_parent_path.\")\n            return \"\"\n\n        # Normalize the path to ensure consistent separators\n        normalized_path = path_display.replace('\\\\', '/').rstrip('/')\n\n        # Split the path into parts\n        path_parts = normalized_path.split('/')\n\n        if len(path_parts) <= 1:\n            # No parent directory exists\n            self.logger.debug(f\"No parent directory for path: '{path_display}'. Returning empty string.\")\n            return \"\"\n\n        # Extract the parent path by joining all parts except the last one\n        parent_path = '/'.join(path_parts[:-1])\n        self.logger.debug(f\"Extracted parent path: '{parent_path}' from path: '{path_display}'\")\n        return parent_path"
                    },
                    {
                        "name": "get_last_path_component_generic",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_last_path_component_generic(self, path):\n        return Path(path).parts[-1]"
                    },
                    {
                        "name": "get_file_link",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "retrieve_existing_shared_link"
                        ],
                        "docstring": null,
                        "function_body": "    def get_file_link(self, dropbox_path: str) -> str:\n        dbx = dropbox_client.dbx\n        try:"
                    },
                    {
                        "name": "retrieve_existing_shared_link",
                        "args": [
                            "self",
                            "dbx",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieve an existing shared link for the specified file.",
                        "function_body": "    def retrieve_existing_shared_link(self, dbx, dropbox_path: str) -> str:\n        \"\"\"\n        Retrieve an existing shared link for the specified file.\n        \"\"\"\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_util",
                "value": "DropboxUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_database_util.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxDatabaseUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger(\"dropbox_logger\")\n        self.dropbox_util = dropbox_util\n        self.logger.info(\"\ud83d\udce6 Dropbox Database Util initialized \ud83c\udf1f\")"
                    },
                    {
                        "name": "add_invoice_link_to_detail_items",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "invoice_number",
                            "file_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def add_invoice_link_to_detail_items(self, project_id: str, po_number: str, invoice_number: int, file_link: str):\n        with get_db_session() as session:"
                    },
                    {
                        "name": "create_or_update_invoice",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "invoice_number",
                            "transaction_date",
                            "term",
                            "total",
                            "file_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def create_or_update_invoice(self, project_id: str, po_number: str, invoice_number: int,\n                                 transaction_date: str, term: int, total: float, file_link: str):\n        # Convert transaction_date to datetime if needed\n        tx_date = None\n        if transaction_date:\n            # Expecting YYYY-MM-DD format\n            try:\n                tx_date = datetime.strptime(transaction_date, \"%Y-%m-%d\")\n            except ValueError:\n                self.logger.warning(f\"Transaction date '{transaction_date}' not in expected format YYYY-MM-DD.\")\n\n        with get_db_session() as session:"
                    },
                    {
                        "name": "get_detail_item_pulse_ids_for_invoice",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "invoice_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session"
                        ],
                        "docstring": null,
                        "function_body": "    def get_detail_item_pulse_ids_for_invoice(self, project_id: str, po_number: str, invoice_number: int):\n        with get_db_session() as session:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_database_util",
                "value": "DropboxDatabaseUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_client.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxClient",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_access_token",
                            "start_token_refresher"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):\n            # Set up logging\n            self._initialized = True\n\n            self.logger = logging.getLogger(\"dropbox_logger\")\n            self.OAUTH_TOKEN_URL = \"https://api.dropboxapi.com/oauth2/token\"\n            self.DROPBOX_REFRESH_TOKEN = os.getenv(\"DROPBOX_REFRESH_TOKEN\")\n            self.DROPBOX_APP_KEY = os.getenv(\"DROPBOX_APP_KEY\")\n            self.DROPBOX_APP_SECRET = os.getenv(\"DROPBOX_APP_SECRET\")\n            self.MY_EMAIL = os.getenv(\"MY_EMAIL\")\n            self.NAMESPACE_NAME = os.getenv(\"NAMESPACE_NAME\")\n            self.CURSOR_DIR = '../cursors'\n            os.makedirs(self.CURSOR_DIR, exist_ok=True)\n            self._internal_lock = threading.Lock()\n            # Initialize access token\n            self.access_token = self.get_access_token()\n            self.logger.info(\"Dropbox Client Initialized\")\n\n        try:"
                    },
                    {
                        "name": "get_new_access_token",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "save_access_token"
                        ],
                        "docstring": "Use the refresh token to get a new access token.",
                        "function_body": "    def get_new_access_token(self):\n        \"\"\"\n        Use the refresh token to get a new access token.\n        \"\"\"\n        data = {\n            'grant_type': 'refresh_token',\n            'refresh_token': self.DROPBOX_REFRESH_TOKEN,\n            'client_id': self.DROPBOX_APP_KEY,\n            'client_secret': self.DROPBOX_APP_SECRET\n        }\n\n        response = requests.post(self.OAUTH_TOKEN_URL, data=data)\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "save_access_token",
                        "args": [
                            "self",
                            "access_token",
                            "expires_in"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Store the access token and its expiration time.",
                        "function_body": "    def save_access_token(self, access_token, expires_in):\n        \"\"\"\n        Store the access token and its expiration time.\n        \"\"\"\n        self.token_expiry_time = time.time() + expires_in  # Token expiration time\n        token_data = {\n            \"access_token\": access_token,\n            \"expires_at\": self.token_expiry_time\n        }\n\n        # Save token data to a file securely\n        with open('../token.json', 'w') as token_file:"
                    },
                    {
                        "name": "load_access_token",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Load the access token from storage.",
                        "function_body": "    def load_access_token(self):\n        \"\"\"\n        Load the access token from storage.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "get_access_token",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "load_access_token",
                            "get_new_access_token"
                        ],
                        "docstring": "Get the valid access token, refreshing it if necessary.",
                        "function_body": "    def get_access_token(self):\n        \"\"\"\n        Get the valid access token, refreshing it if necessary.\n        \"\"\"\n        access_token = self.load_access_token()\n        if not access_token:\n            # Token expired or not found, refresh it\n            self.logger.info(\"Refreshing access token.\")\n            access_token = self.get_new_access_token()\n        return access_token"
                    },
                    {
                        "name": "list_root_folder",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists the contents of the root folder to verify connection.",
                        "function_body": "    def list_root_folder(self):\n        \"\"\"\n        Lists the contents of the root folder to verify connection.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "list_folder_changes",
                        "args": [
                            "self",
                            "cursor"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists changes in the specified folder using the provided cursor.\nReturns a tuple of (changes, new_cursor).",
                        "function_body": "    def list_folder_changes(self, cursor):\n        \"\"\"\n        Lists changes in the specified folder using the provided cursor.\n        Returns a tuple of (changes, new_cursor).\n        \"\"\"\n        with self._internal_lock:"
                    },
                    {
                        "name": "load_cursor",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_cursor_file_path"
                        ],
                        "docstring": "Load the cursor for the member.",
                        "function_body": "    def load_cursor(self):\n        \"\"\"\n        Load the cursor for the member.\n        \"\"\"\n        cursor_file = self.get_cursor_file_path()\n        if not os.path.exists(cursor_file):\n            self.logger.info(f\"No cursor file found for member ID {self.member_id}. Initializing cursor.\")\n            return None\n        try:"
                    },
                    {
                        "name": "save_cursor",
                        "args": [
                            "self",
                            "cursor"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_cursor_file_path"
                        ],
                        "docstring": "Save the cursor for the member.",
                        "function_body": "    def save_cursor(self, cursor):\n        \"\"\"\n        Save the cursor for the member.\n        \"\"\"\n        cursor_file = self.get_cursor_file_path()\n        temp_fd, temp_path = tempfile.mkstemp()\n        try:"
                    },
                    {
                        "name": "get_cursor_file_path",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Get the file path for storing the cursor.",
                        "function_body": "    def get_cursor_file_path(self):\n        \"\"\"\n        Get the file path for storing the cursor.\n        \"\"\"\n        safe_member_id = self.member_id.replace(\":\", \"_\")\n        return os.path.join(self.CURSOR_DIR, f'cursor_{safe_member_id}.json')"
                    },
                    {
                        "name": "start_token_refresher",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Starts a background thread to refresh the access token before it expires.",
                        "function_body": "    def start_token_refresher(self):\n        \"\"\"\n        Starts a background thread to refresh the access token before it expires.\n        \"\"\"\n        refresher_thread = threading.Thread(target=self.token_refresher, daemon=True)\n        refresher_thread.start()\n        self.logger.info(\"Token refresher thread started.\")"
                    },
                    {
                        "name": "token_refresher",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_new_access_token"
                        ],
                        "docstring": "Refreshes the access token periodically before it expires.",
                        "function_body": "    def token_refresher(self):\n        \"\"\"\n        Refreshes the access token periodically before it expires.\n        \"\"\"\n        while True:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_client",
                "value": "DropboxClient()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/ocr_service.py",
        "functions": [],
        "classes": [
            {
                "name": "OCRService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "extract_text_from_file",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Extract text from a file (invoice, receipt, or W-9).",
                        "function_body": "    def extract_text_from_file(self, file_data: bytes) -> str:\n        \"\"\"Extract text from a file (invoice, receipt, or W-9).\"\"\"\n        try:"
                    },
                    {
                        "name": "extract_text_from_invoice",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_file"
                        ],
                        "docstring": "Extract text specifically from an invoice file.",
                        "function_body": "    def extract_text_from_invoice(self, file_data: bytes) -> str:\n        \"\"\"Extract text specifically from an invoice file.\"\"\"\n        return self.extract_text_from_file(file_data)"
                    },
                    {
                        "name": "parse_invoice_details",
                        "args": [
                            "self",
                            "text_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse invoice details from extracted text.",
                        "function_body": "    def parse_invoice_details(self, text_data: str) -> dict:\n        \"\"\"Parse invoice details from extracted text.\"\"\"\n        details = {}\n        lines = text_data.split('\\n')\n        for line in lines:\n            if 'Invoice Number:' in line:\n                details['invoice_number'] = line.split(':')[1].strip()\n            elif 'Total Amount:' in line:\n                details['total_amount'] = float(line.split(':')[1].strip().replace('$', ''))\n        return details"
                    },
                    {
                        "name": "extract_text_from_w9",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_file"
                        ],
                        "docstring": "Extract text from a W-9 form.",
                        "function_body": "    def extract_text_from_w9(self, file_data: bytes) -> str:\n        \"\"\"Extract text from a W-9 form.\"\"\"\n        return self.extract_text_from_file(file_data)"
                    },
                    {
                        "name": "parse_w9_details",
                        "args": [
                            "self",
                            "text_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse details from a W-9 form.",
                        "function_body": "    def parse_w9_details(self, text_data: str) -> dict:\n        \"\"\"Parse details from a W-9 form.\"\"\"\n        details = {}\n        lines = text_data.split('\\n')\n        for i, line in enumerate(lines):\n            if 'Name' in line:\n                details['name'] = lines[i + 1].strip()\n            if 'Tax ID' in line:\n                details['tax_id'] = lines[i + 1].strip()\n        return details"
                    },
                    {
                        "name": "extract_text_from_receipt",
                        "args": [
                            "self",
                            "file_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text_from_file"
                        ],
                        "docstring": "Extract text from a receipt.",
                        "function_body": "    def extract_text_from_receipt(self, file_data: bytes) -> str:\n        \"\"\"Extract text from a receipt.\"\"\"\n        return self.extract_text_from_file(file_data)"
                    },
                    {
                        "name": "parse_receipt_details",
                        "args": [
                            "self",
                            "text_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Parse receipt details from extracted text.",
                        "function_body": "    def parse_receipt_details(self, text_data: str) -> dict:\n        \"\"\"Parse receipt details from extracted text.\"\"\"\n        details = {}\n        # Implement parsing logic specific to receipts\n        return details"
                    },
                    {
                        "name": "extract_info_with_openai",
                        "args": [
                            "self",
                            "text"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_info_with_openai(self, text):\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an AI assistant that extracts information from financial documents for a production company / digital creative studio. Extract the following details from the text:\n                   Invoice Date (Formatted as YYYY-MM-DD),  Total Amount, Payment Term.\n                   Respond with pure, parsable, JSON (no leading or trailing apostrophes) with keys: 'invoice_date', 'total_amount', 'payment_term' If any fields are empty make their value None\"\"\"\n            },\n            {\"role\": \"user\", \"content\": text}\n        ]\n\n        response = self.client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",  # or 'gpt-4' if you have access\n            messages=messages,\n            max_tokens=1000,\n            temperature=0\n        )\n\n        extracted_info = response.choices[0].message.content.strip()\n        # print(\"OPEN AI INFO\", extracted_info)\n        # Parse the JSON response\n\n        try:"
                    },
                    {
                        "name": "extract_receipt_info_with_openai",
                        "args": [
                            "self",
                            "text"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_receipt_info_with_openai(self, text):\n\n        messages = [\n            {\n                \"role\": \"system\",\n                \"content\": \"\"\"You are an AI assistant that extracts information from receipts.\n                    Extract the following details from the text: \n                    Total Amount (numbers only, no symbols), \n                    Date of purchase (format YYYY-MM-DD), and \n                    generate a description (summarize to 20 characters maximum). \n                    If the total is a refund then the value should be negative. \n                    Provide the information in JSON format with keys: 'total_amount', 'description', 'date'.\"\"\"\n            },\n            {\"role\": \"user\", \"content\": text}\n        ]\n\n        response = self.client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",  # or 'gpt-4' if you have access\n            messages=messages,\n            max_tokens=1000,\n            temperature=0\n        )\n\n        extracted_info = response.choices[0].message.content.strip()\n        # print(\"RAW DATA\", extracted_info)\n        extracted_info_clean = extracted_info.replace(\"```json\", \"\").replace(\"```\", \"\").strip()\n\n        # Parse the JSON response\n        try:"
                    },
                    {
                        "name": "extract_text",
                        "args": [
                            "self",
                            "local_file_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "extract_text"
                        ],
                        "docstring": "Extracts text from a PDF or image file using OCR or direct PDF text extraction.\n\n:param local_file_path: The local file path of the document or image.\n:return: A string containing all text extracted from the file.",
                        "function_body": "    def extract_text(self, local_file_path: str) -> str:\n        \"\"\"\n        Extracts text from a PDF or image file using OCR or direct PDF text extraction.\n\n        :param local_file_path: The local file path of the document or image.\n        :return: A string containing all text extracted from the file.\n        \"\"\"\n        # Basic file extension check\n        _, ext = os.path.splitext(local_file_path.lower())\n        text_content = \"\"\n\n        try:\n            # If it's a PDF, try using pdfplumber\n            if ext == \".pdf\":\n                logging.info(f\"\ud83d\udd0e [OCRService] Processing PDF with pdfplumber: {local_file_path}\")\n                with pdfplumber.open(local_file_path) as pdf:\n                    for page in pdf.pages:\n                        page_text = page.extract_text() or \"\"\n                        text_content += page_text + \"\\n\"\n            else:\n                # Otherwise, treat it as an image and use pytesseract\n                logging.info(f\"\ud83d\udd0e [OCRService] Processing image with pytesseract: {local_file_path}\")\n                image = Image.open(local_file_path)\n                text_content = pytesseract.image_to_string(image)\n        except Exception as e:\n            logging.error(f\"\u274c [OCRService] Failed to extract text from file {local_file_path}: {e}\", exc_info=True)\n\n        return text_content.strip()"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('dropbox_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_dropbox/dropbox_api.py",
        "functions": [],
        "classes": [
            {
                "name": "DropboxAPI",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "upload_file",
                        "args": [
                            "self",
                            "file_path",
                            "destination_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Uploads a file to Dropbox.",
                        "function_body": "    def upload_file(self, file_path: str, destination_path: str):\n        \"\"\"Uploads a file to Dropbox.\"\"\"\n        with open(file_path, 'rb') as f:"
                    },
                    {
                        "name": "download_file",
                        "args": [
                            "self",
                            "file_path",
                            "local_destination"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Downloads a file from Dropbox.",
                        "function_body": "    def download_file(self, file_path: str, local_destination: str):\n        \"\"\"Downloads a file from Dropbox.\"\"\"\n        try:"
                    },
                    {
                        "name": "get_file_metadata",
                        "args": [
                            "self",
                            "file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves metadata for a file.",
                        "function_body": "    def get_file_metadata(self, file_path: str):\n        \"\"\"Retrieves metadata for a file.\"\"\"\n        try:"
                    },
                    {
                        "name": "list_folder_contents",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists the contents of a folder.",
                        "function_body": "    def list_folder_contents(self, folder_path: str):\n        \"\"\"Lists the contents of a folder.\"\"\"\n        try:"
                    },
                    {
                        "name": "create_folder",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a folder in Dropbox.",
                        "function_body": "    def create_folder(self, folder_path: str):\n        \"\"\"Creates a folder in Dropbox.\"\"\"\n        try:"
                    },
                    {
                        "name": "delete_file_or_folder",
                        "args": [
                            "self",
                            "path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Deletes a file or folder in Dropbox.",
                        "function_body": "    def delete_file_or_folder(self, path: str):\n        \"\"\"Deletes a file or folder in Dropbox.\"\"\"\n        try:"
                    },
                    {
                        "name": "list_files_in_folder",
                        "args": [
                            "self",
                            "folder_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists all files under the given folder_path and returns a list of dicts\ncontaining 'file_name' and 'file_link' for each file.",
                        "function_body": "    def list_files_in_folder(self, folder_path: str) -> list:\n        \"\"\"\n        Lists all files under the given folder_path and returns a list of dicts\n        containing 'file_name' and 'file_link' for each file.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udcc2 Listing files under '{folder_path}'\")\n        files_data = []\n\n        try:\n            result = self.dbx.files_list_folder(path=folder_path, recursive=False)\n            entries = result.entries\n\n            while result.has_more:\n                result = self.dbx.files_list_folder_continue(result.cursor)\n                entries.extend(result.entries)\n\n            for entry in entries:\n                if isinstance(entry, FileMetadata):\n                    files_data.append({\n                        'file_name': entry.name,\n                    })\n\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Error listing files in '{folder_path}': {e}\", exc_info=True)\n\n        return files_data"
                    },
                    {
                        "name": "get_po_tax_form_link",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "list_files_in_folder",
                            "list_all_projects",
                            "list_project_po_folders",
                            "create_share_link",
                            "find_project_folder"
                        ],
                        "docstring": "Retrieves PO folders and their shared links based on provided parameters.\n\nArgs:\n    project_number (str, optional): The ID of the project. Defaults to None.\n    po_number (str, optional): The number of the PO. Defaults to None.\n\nReturns:\n    List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                            'po_folder_path', and 'po_folder_link'.",
                        "function_body": "    def get_po_tax_form_link(self,\n         project_number: Optional[str] = None,\n         po_number: Optional[str] = None\n     ) -> List[Dict[str, str]]:\n        \"\"\"\n        Retrieves PO folders and their shared links based on provided parameters.\n\n        Args:\n            project_number (str, optional): The ID of the project. Defaults to None.\n            po_number (str, optional): The number of the PO. Defaults to None.\n\n        Returns:\n            List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                                    'po_folder_path', and 'po_folder_link'.\n        \"\"\"\n        project_po_data = []\n\n        try:\n            if project_number is None:\n                # Scenario 1: No arguments provided - Retrieve all PO folders in the '2024' namespace\n                self.logger.info(\"\ud83d\udcc1 No project_number provided. Retrieving all PO folders under the '2024' namespace.\")\n                all_projects = self.list_all_projects(namespace=\"2024\")\n                if not all_projects:\n                    self.logger.warning(\"\u26a0\ufe0f No projects found under the '2024' namespace.\")\n                    return []\n\n                for project in all_projects:\n                    current_project_number = project['id']\n                    project_folder_path = project['path']\n                    po_base_path = f\"{project_folder_path}/1. Purchase Orders\"\n\n                    po_folders = self.list_project_po_folders(po_base_path)\n                    if not po_folders:\n                        self.logger.info(f\"\u2139\ufe0f No PO folders found for project_number={current_project_number} at '{po_base_path}'\")\n                        continue\n\n                    for po_folder in po_folders:\n                        # check if there's a tax form\n                        files = self.list_files_in_folder(po_folder[\"path\"])\n                        tax_form_link = \"\"\n                        form_type = \"\"\n                        for file in files:\n                            match = re.search(self.TAX_FORM_REGEX, file['file_name'].lower(), re.IGNORECASE)\n                            if match:\n                                self.logger.info(f\"\ud83d\udcbc Identified as tax form: {file['file_name']}\")\n                                # get the share link\n                                tax_form_link = self.create_share_link(po_folder[\"path\"])\n                                if match.group(1):\n                                    form_type = \"W-9\"\n                                elif match.group(2):\n                                    form_type = \"W-8BEN\"\n                                elif match.group(3):\n                                    form_type = \"W-8BEN-E\"\n                                elif match.group(4):\n                                    form_type = \"W-8BEN-E\"\n\n                                self.logger.info(f\"\ud83d\udcbc Identified as tax form: {file['file_name']} ({form_type})\")\n                        project_po_data.append({\n                            'po_folder_name': po_folder['name'],\n                            'po_folder_path': po_folder['path'],\n                            'po_tax_form_link': tax_form_link,\n                            'form_type': form_type\n                        })\n\n            elif project_number and po_number is None:\n                # Scenario 2: Only project_number provided - Retrieve all PO folders for the specified project\n                self.logger.info(f\"\ud83d\udcc1 Retrieving PO folders for project_number={project_number}\")\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f\"\u26a0\ufe0f Unable to find project folder for project_number={project_number}\")\n                    return []\n\n                po_base_path = f\"{project_folder_path}/1. Purchase Orders\"\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"\u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n\n                for po_folder in po_folders:\n                    # check if there's a tax form\n                    files = self.list_files_in_folder(po_folder[\"path\"])\n                    tax_form_link = \"\"\n                    form_type = \"\"\n                    for file in files:\n                        match = re.search(self.TAX_FORM_REGEX, file['file_name'].lower(), re.IGNORECASE)\n                        if match:\n                            self.logger.info(f\"\ud83d\udcbc Identified as tax form: {file['file_name']}\")\n                            # get the share link\n                            tax_form_link = self.create_share_link(po_folder[\"path\"])\n                            if match.group(1):\n                                form_type = \"W-9\"\n                            elif match.group(2):\n                                form_type = \"W-8BEN\"\n                            elif match.group(3):\n                                form_type = \"W-8BEN-E\"\n                            elif match.group(4):\n                                form_type = \"W-8BEN-E\"\n\n                            self.logger.info(f\"\ud83d\udcbc Identified as tax form: {file['file_name']} ({form_type})\")\n                    project_po_data.append({\n                        'po_folder_name': po_folder['name'],\n                        'po_folder_path': po_folder['path'],\n                        'po_tax_form_link': tax_form_link,\n                        'form_type': form_type\n                    })\n\n            elif project_number and po_number:\n                # Scenario 3: Both project_number and po_number provided - Retrieve specific PO folder\n                self.logger.info(f\"\ud83d\udcc1 Retrieving PO folder for project_number={project_number} and po_number={po_number}\")\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f\"\u26a0\ufe0f Unable to find project folder for project_number={project_number}\")\n                    return []\n\n                # Ensure po_number has leading zero if it's a single digit\n                formatted_po_number = f\"{int(po_number):02}\"\n                self.logger.debug(f\"\ud83d\udccc Formatted po_number: {formatted_po_number}\")\n\n                po_base_path = f\"{project_folder_path}/1. Purchase Orders\"\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"\u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n\n                # Search for the specific PO folder\n                specific_po_folder = next(\n                    (po for po in po_folders if po['name'].startswith(f\"{project_number}_{formatted_po_number}\")),\n                    None\n                )\n                po_path = specific_po_folder['path'] + \"/\"\n                files = self.list_files_in_folder(po_path)\n                tax_form_link = \"\"\n                form_type = \"\"\n                for file in files:\n                    match = re.search(self.TAX_FORM_REGEX, file[\"file_name\"], re.IGNORECASE)\n                    if match:\n                        self.logger.info(f\"\ud83d\udcbc Identified as tax form: {file['file_name']}\")\n                        # get the share link\n                        tax_form_link = self.create_share_link(po_path + file[\"file_name\"])\n                        if match.group(1):\n                            form_type = \"W-9\"\n                        elif match.group(2):\n                            form_type = \"W-8BEN\"\n                        elif match.group(3):\n                            form_type = \"W-8BEN-E\"\n                        elif match.group(4):\n                            form_type = \"W-8BEN-E\"\n\n                        self.logger.info(f\"\ud83d\udcbc Identified as tax form: {file['file_name']} ({form_type})\")\n                        continue\n                project_po_data.append({\n                    'po_folder_name': specific_po_folder[\"name\"],\n                    'po_folder_path': specific_po_folder[\"path\"],\n                    'po_tax_form_link': tax_form_link,\n                    'form_type': form_type\n                })\n            else:\n                self.logger.error(\"\u2757 Invalid combination of parameters provided.\")\n                return []\n\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 An error occurred while retrieving PO folders: {e}\")\n            return []\n\n        self.logger.info(f\"\u2705 Retrieved {len(project_po_data)} PO folders based on the provided parameters.\")\n        return project_po_data"
                    },
                    {
                        "name": "get_project_po_folders_with_link",
                        "args": [
                            "self",
                            "project_number",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "list_all_projects",
                            "list_project_po_folders",
                            "create_share_link",
                            "find_project_folder"
                        ],
                        "docstring": "Retrieves PO folders and their shared links based on provided parameters.\n\nArgs:\n    project_number (str, optional): The ID of the project. Defaults to None.\n    po_number (str, optional): The number of the PO. Defaults to None.\n\nReturns:\n    List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                            'po_folder_path', and 'po_folder_link'.",
                        "function_body": "    def get_project_po_folders_with_link(\n        self,\n        project_number: Optional[str] = None,\n        po_number: Optional[str] = None\n    ) -> List[Dict[str, str]]:\n        \"\"\"\n        Retrieves PO folders and their shared links based on provided parameters.\n\n        Args:\n            project_number (str, optional): The ID of the project. Defaults to None.\n            po_number (str, optional): The number of the PO. Defaults to None.\n\n        Returns:\n            List[Dict[str, str]]: A list of dictionaries containing 'po_folder_name',\n                                    'po_folder_path', and 'po_folder_link'.\n        \"\"\"\n        project_po_data = []\n\n        try:\n            if project_number is None:\n                # Scenario 1: No arguments provided - Retrieve all PO folders in the '2024' namespace\n                self.logger.info(\"\ud83d\udcc1 No project_number provided. Retrieving all PO folders under the '2024' namespace.\")\n                all_projects = self.list_all_projects(namespace=\"2024\")\n                if not all_projects:\n                    self.logger.warning(\"\u26a0\ufe0f No projects found under the '2024' namespace.\")\n                    return []\n\n                for project in all_projects:\n                    current_project_number = project['id']\n                    project_folder_path = project['path']\n                    po_base_path = f\"{project_folder_path}/1. Purchase Orders\"\n\n                    po_folders = self.list_project_po_folders(po_base_path)\n                    if not po_folders:\n                        self.logger.info(f\"\u2139\ufe0f No PO folders found for project_number={current_project_number} at '{po_base_path}'\")\n                        continue\n\n                    for po_folder in po_folders:\n                        po_link = self.create_share_link(po_folder[\"path\"])\n                        project_po_data.append({\n                            'po_folder_name': po_folder['name'],\n                            'po_folder_path': po_folder['path'],\n                            'po_folder_link': po_link\n                        })\n\n            elif project_number and po_number is None:\n                # Scenario 2: Only project_number provided - Retrieve all PO folders for the specified project\n                self.logger.info(f\"\ud83d\udcc1 Retrieving PO folders for project_number={project_number}\")\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f\"\u26a0\ufe0f Unable to find project folder for project_number={project_number}\")\n                    return []\n\n                po_base_path = f\"{project_folder_path}/1. Purchase Orders\"\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"\u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n\n                for po_folder in po_folders:\n                    po_link = self.create_share_link(po_folder[\"path\"])\n                    project_po_data.append({\n                        'po_folder_name': po_folder['name'],\n                        'po_folder_path': po_folder['path'],\n                        'po_folder_link': po_link\n                    })\n\n            elif project_number and po_number:\n                # Scenario 3: Both project_number and po_number provided - Retrieve specific PO folder\n                self.logger.info(f\"\ud83d\udcc1 Retrieving PO folder for project_number={project_number} and po_number={po_number}\")\n                project_folder_path = self.find_project_folder(project_number)\n                if not project_folder_path:\n                    self.logger.warning(f\"\u26a0\ufe0f Unable to find project folder for project_number={project_number}\")\n                    return []\n\n                # Ensure po_number has leading zero if it's a single digit\n                formatted_po_number = f\"{int(po_number):02}\"\n                self.logger.debug(f\"\ud83d\udccc Formatted po_number: {formatted_po_number}\")\n\n                po_base_path = f\"{project_folder_path}/1. Purchase Orders\"\n                po_folders = self.list_project_po_folders(po_base_path)\n                if not po_folders:\n                    self.logger.info(f\"\u2139\ufe0f No PO folders found for project_number={project_number} at '{po_base_path}'\")\n                    return []\n\n                # Search for the specific PO folder\n                specific_po_folder = next(\n                    (po for po in po_folders if po['name'].startswith(f\"{project_number}_{formatted_po_number}\")),\n                    None\n                )\n\n                if specific_po_folder:\n                    po_link = self.create_share_link(specific_po_folder[\"path\"])\n                    project_po_data.append({\n                        'po_folder_name': specific_po_folder['name'],\n                        'po_folder_path': specific_po_folder['path'],\n                        'po_folder_link': po_link\n                    })\n                else:\n                    self.logger.warning(f\"\u26a0\ufe0f PO folder with po_number={formatted_po_number} not found in project_number={project_number}\")\n                    return []\n\n            else:\n                self.logger.error(\"\u2757 Invalid combination of parameters provided.\")\n                return []\n\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 An error occurred while retrieving PO folders: {e}\")\n            return []\n\n        self.logger.info(f\"\u2705 Retrieved {len(project_po_data)} PO folders based on the provided parameters.\")\n        return project_po_data"
                    },
                    {
                        "name": "list_all_projects",
                        "args": [
                            "self",
                            "namespace"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists all project folders under the specified namespace.\n\nArgs:\n    namespace (str): The namespace (e.g., '2024') under which all projects reside.\n\nReturns:\n    List[Dict[str, str]]: A list of projects, each dict with 'id' and 'path'.",
                        "function_body": "    def list_all_projects(self, namespace: str) -> List[Dict[str, str]]:\n        \"\"\"\n        Lists all project folders under the specified namespace.\n\n        Args:\n            namespace (str): The namespace (e.g., '2024') under which all projects reside.\n\n        Returns:\n            List[Dict[str, str]]: A list of projects, each dict with 'id' and 'path'.\n        \"\"\"\n        # Construct the path root for the namespace\n        dbx_namespaced = self.dbx.with_path_root(common.PathRoot.namespace_id(self.dbx_client.namespace_id))\n        base_path = \"\"\n\n        try:"
                    },
                    {
                        "name": "find_project_folder",
                        "args": [
                            "self",
                            "project_number",
                            "namespace"
                        ],
                        "decorators": [],
                        "calls": [
                            "list_all_projects"
                        ],
                        "docstring": "Searches for a folder whose name (or metadata) contains the given project_number under the specified namespace.\n\nArgs:\n    project_number (str): The ID of the project.\n    namespace (str): The namespace under which projects are stored. Defaults to '2024'.\n\nReturns:\n    Optional[str]: The path_lower of the matched project folder if found, else None.",
                        "function_body": "    def find_project_folder(self, project_number: str, namespace: str = \"2024\") -> Optional[str]:\n        \"\"\"\n        Searches for a folder whose name (or metadata) contains the given project_number under the specified namespace.\n\n        Args:\n            project_number (str): The ID of the project.\n            namespace (str): The namespace under which projects are stored. Defaults to '2024'.\n\n        Returns:\n            Optional[str]: The path_lower of the matched project folder if found, else None.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd0d Searching for project folder with project_number='{project_number}' in namespace='{namespace}'.\")\n\n        # First, list all projects under the given namespace\n        all_projects = self.list_all_projects(namespace=namespace)\n        if not all_projects:\n            self.logger.warning(f\"\u26a0\ufe0f No projects found in namespace='{namespace}'.\")\n            return None\n\n        # Attempt to find a project folder that matches the given project_number\n        # Assuming that `project_number` is either exactly the folder name or a substring of the folder name.\n        for project in all_projects:\n            if str(project_number) in project['id']:\n                self.logger.debug(f\"\u2705 Found project folder: '{project['id']}' at '{project['path']}'\")\n                return project['path']\n\n        self.logger.warning(f\"\u26a0\ufe0f Project folder with project_number='{project_number}' not found in namespace='{namespace}'.\")\n        return None"
                    },
                    {
                        "name": "create_share_link",
                        "args": [
                            "self",
                            "dropbox_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a shared link for the specified Dropbox path within the team namespace.\n\nArgs:\n    dropbox_path (str): The path in Dropbox for which to create a share link.\n\nReturns:\n    Optional[str]: The shared link if successful, else None.",
                        "function_body": "    def create_share_link(self, dropbox_path: str) -> Optional[str]:\n        \"\"\"\n        Creates a shared link for the specified Dropbox path within the team namespace.\n\n        Args:\n            dropbox_path (str): The path in Dropbox for which to create a share link.\n\n        Returns:\n            Optional[str]: The shared link if successful, else None.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "list_project_po_folders",
                        "args": [
                            "self",
                            "po_base_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Lists all PO folders under the given project's Purchase Orders directory.\nThis method was already provided, but in case it wasn't implemented, here is a sample implementation.\n\nArgs:\n    po_base_path (str): The path to the project's \"1. Purchase Orders\" directory in Dropbox.\n\nReturns:\n    list: A list of dictionaries representing PO folders, each dict containing 'name' and 'path'.",
                        "function_body": "    def list_project_po_folders(self, po_base_path: str) -> list:\n        \"\"\"\n        Lists all PO folders under the given project's Purchase Orders directory.\n        This method was already provided, but in case it wasn't implemented, here is a sample implementation.\n\n        Args:\n            po_base_path (str): The path to the project's \"1. Purchase Orders\" directory in Dropbox.\n\n        Returns:\n            list: A list of dictionaries representing PO folders, each dict containing 'name' and 'path'.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udcc2 Listing PO folders under '{po_base_path}'\")\n        all_entries = []\n        dbx_namespaced = self.dbx.with_path_root(common.PathRoot.namespace_id(self.dbx_client.namespace_id))\n\n        try:\n            # Initial list_folder call\n            result = dbx_namespaced.files_list_folder(path=po_base_path, recursive=False)\n\n            # Accumulate all entries\n            all_entries.extend(result.entries)\n\n            # If there's more, continue listing\n            while result.has_more:\n                result = dbx_namespaced.files_list_folder_continue(result.cursor)\n                all_entries.extend(result.entries)\n\n        except ApiError as e:\n            self.logger.exception(f\"\ud83d\udca5 Error listing PO folders in Dropbox under {po_base_path}: {e}\", exc_info=True)\n            return []\n        except Exception as e:\n            self.logger.exception(f\"\ud83d\udca5 Unexpected error listing PO folders under {po_base_path}: {e}\", exc_info=True)\n            return []\n\n        # Filter only folder metadata and build the return list\n        folders = []\n        for entry in all_entries:\n            if isinstance(entry, FolderMetadata):\n                folder_path = entry.path_lower if entry.path_lower else entry.path_display\n                folders.append({\n                    \"name\": entry.name,\n                    \"path\": folder_path\n                })\n\n        self.logger.debug(f\"\u2705 Found {len(folders)} folders under '{po_base_path}'.\")\n        return folders"
                    },
                    {
                        "name": "_update_monday_tax_form_link",
                        "args": [
                            "self",
                            "pulse_id",
                            "new_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item"
                        ],
                        "docstring": "Update Monday contact's tax_form_link column with the new link.",
                        "function_body": "    def _update_monday_tax_form_link(self, pulse_id, new_link):\n        \"\"\"\n        Update Monday contact's tax_form_link column with the new link.\n        \"\"\"\n        if not pulse_id:\n            self.logger.warning(\"No pulse_id to update Monday link.\")\n            return\n\n        # Monday typically wants a JSON string: {\"url\": \"...\", \"text\": \"...\"}\n        link_value = {\"url\": new_link, \"text\": \"Tax Form\"}\n        column_values = {\n            \"tax_form_link_column\": json.dumps(link_value)\n        }\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "dropbox_api",
                "value": "DropboxAPI()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_util.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "retrieve_subitem_board_id"
                        ],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "SUBITEM_BOARD_ID",
                        "args": [
                            "self"
                        ],
                        "decorators": [
                            "property"
                        ],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def SUBITEM_BOARD_ID(self):\n        return self._subitem_board_id"
                    },
                    {
                        "name": "retrieve_subitem_board_id",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_subitem_board_id",
                            "get_subitems_column_id"
                        ],
                        "docstring": "Retrieves the subitem board ID by first fetching the subitems column ID\nand then extracting the board ID from its settings.\n\nReturns:\n    str: The subitem board ID.\n\nRaises:\n    Exception: If unable to retrieve the subitem board ID.",
                        "function_body": "    def retrieve_subitem_board_id(self):\n        \"\"\"\n        Retrieves the subitem board ID by first fetching the subitems column ID\n        and then extracting the board ID from its settings.\n\n        Returns:\n            str: The subitem board ID.\n\n        Raises:\n            Exception: If unable to retrieve the subitem board ID.\n        \"\"\"\n        subitems_column_id = self.get_subitems_column_id(self.PO_BOARD_ID)\n        subitem_board_id = self.get_subitem_board_id(subitems_column_id)\n        return subitem_board_id"
                    },
                    {
                        "name": "get_subitems_column_id",
                        "args": [
                            "self",
                            "parent_board_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the column ID for subitems in a given board.\n\nArgs:\n    parent_board_id (str): The ID of the parent board.\n\nReturns:\n    str: The column ID for subitems.\n\nRaises:\n    Exception: If the subitems column is not found or the API request fails.",
                        "function_body": "    def get_subitems_column_id(self, parent_board_id):\n        \"\"\"\n        Retrieves the column ID for subitems in a given board.\n\n        Args:\n            parent_board_id (str): The ID of the parent board.\n\n        Returns:\n            str: The column ID for subitems.\n\n        Raises:\n            Exception: If the subitems column is not found or the API request fails.\n        \"\"\"\n        query = f'''\n        query {{\n            boards(ids: {parent_board_id}) {{\n                columns {{\n                    id\n                    type\n                }}\n            }}\n        }}\n        '''\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers, json={'query': query})\n        data = response.json()\n\n        if response.status_code == 200 and 'data' in data:"
                    },
                    {
                        "name": "get_subitem_board_id",
                        "args": [
                            "self",
                            "subitems_column_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the subitem board ID for a given subitems column ID.\n\nArgs:\n    subitems_column_id (str): The ID of the subitems column.\n\nReturns:\n    str: The subitem board ID.\n\nRaises:\n    Exception: If the subitem board ID cannot be retrieved.",
                        "function_body": "    def get_subitem_board_id(self, subitems_column_id):\n        \"\"\"\n        Retrieves the subitem board ID for a given subitems column ID.\n\n        Args:\n            subitems_column_id (str): The ID of the subitems column.\n\n        Returns:\n            str: The subitem board ID.\n\n        Raises:\n            Exception: If the subitem board ID cannot be retrieved.\n        \"\"\"\n        query = f'''\n        query {{\n            boards(ids: {self.PO_BOARD_ID}) {{\n                columns(ids: \"{subitems_column_id}\") {{\n                    settings_str\n                }}\n            }}\n        }}\n        '''\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers, json={'query': query})\n        data = response.json()\n\n        if response.status_code == 200 and 'data' in data:"
                    },
                    {
                        "name": "_handle_date_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Date handler for columns, extracting a single date.",
                        "function_body": "    def _handle_date_column(self, event):\n        \"\"\"\n        Date handler for columns, extracting a single date.\n        \"\"\"\n        return event.get('value', {}).get('date', {})"
                    },
                    {
                        "name": "_handle_link_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handles link column type and extracts URL.",
                        "function_body": "    def _handle_link_column(self, event):\n        \"\"\"\n        Handles link column type and extracts URL.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "_handle_dropdown_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handles dropdown column type and extracts chosen values.",
                        "function_body": "    def _handle_dropdown_column(self, event):\n        \"\"\"\n        Handles dropdown column type and extracts chosen values.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "_handle_default_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Default handler for columns, extracting a single text label.",
                        "function_body": "    def _handle_default_column(self, event):\n        \"\"\"\n        Default handler for columns, extracting a single text label.\n        \"\"\"\n        if not event or not event.get('value'):\n            return None\n        return event['value'].get('value')"
                    },
                    {
                        "name": "_handle_status_column",
                        "args": [
                            "self",
                            "event"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Handles status column type and extracts the label text.",
                        "function_body": "    def _handle_status_column(self, event):\n        \"\"\"\n        Handles status column type and extracts the label text.\n        \"\"\"\n        return event.get('value', {}).get('label', {}).get('text')"
                    },
                    {
                        "name": "get_column_handler",
                        "args": [
                            "self",
                            "column_type"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieves the appropriate handler method based on the column type.",
                        "function_body": "    def get_column_handler(self, column_type):\n        \"\"\"\n        Retrieves the appropriate handler method based on the column type.\n        \"\"\"\n        handler_name = self.COLUMN_TYPE_HANDLERS.get(column_type, \"handle_default_column\")\n        return getattr(self, f\"_{handler_name}\")"
                    },
                    {
                        "name": "create_item",
                        "args": [
                            "self",
                            "group_id",
                            "item_name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a new item in Monday.com within the specified group.\n\nArgs:\n    group_id (str): The ID of the group where the item will be created.\n    item_name (str): The name of the new item.\n    column_values (dict): A dictionary of column IDs and their corresponding values.\n\nReturns:\n    str or None: The ID of the created item if successful, else None.",
                        "function_body": "    def create_item(self, group_id, item_name, column_values):\n        \"\"\"\n        Creates a new item in Monday.com within the specified group.\n\n        Args:\n            group_id (str): The ID of the group where the item will be created.\n            item_name (str): The name of the new item.\n            column_values (dict): A dictionary of column IDs and their corresponding values.\n\n        Returns:\n            str or None: The ID of the created item if successful, else None.\n        \"\"\"\n        query = '''\n        mutation ($board_id: ID!, $group_id: String!, $item_name: String!, $column_values: JSON!) {\n            create_item(\n                board_id: $board_id,\n                group_id: $group_id,\n                item_name: $item_name,\n                column_values: $column_values\n            ) {\n                id\n                name\n            }\n        }\n        '''\n\n        # Serialize `column_values` to JSON string format\n        serialized_column_values = json.dumps(column_values)\n\n        variables = {\n            'board_id': self.PO_BOARD_ID,\n            'group_id': group_id,\n            'item_name': item_name,\n            'column_values': serialized_column_values  # Pass serialized values here\n        }\n        self.logger.info(f\"Creating item with variables: {variables}\")\n\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers,\n                                 json={'query': query, 'variables': variables})\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "update_item_columns",
                        "args": [
                            "self",
                            "item_id",
                            "column_values",
                            "board"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Updates multiple columns of an item in Monday.com.\n\nArgs:\n    item_id (str): The ID of the item to update.\n    column_values (dict): A dictionary of column IDs and their corresponding values.\n\nReturns:\n    bool: True if the update was successful, False otherwise.\n    :param item_id:\n    :param column_values:\n    :param board:",
                        "function_body": "    def update_item_columns(self, item_id, column_values, board=\"po\"):\n        \"\"\"\n        Updates multiple columns of an item in Monday.com.\n\n        Args:\n            item_id (str): The ID of the item to update.\n            column_values (dict): A dictionary of column IDs and their corresponding values.\n\n        Returns:\n            bool: True if the update was successful, False otherwise.\n            :param item_id:\n            :param column_values:\n            :param board:\n        \"\"\"\n        # Convert the column values to JSON\n        column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n        if board == \"po\":\n            board_id = self.PO_BOARD_ID\n        elif board == \"contact\":\n            board_id = self.CONTACT_BOARD_ID\n        elif board == \"subitem\":\n            board_id = self.SUBITEM_BOARD_ID\n        else:\n            board_id = self.PO_BOARD_ID\n\n        query = f'''\n        mutation {{\n            change_multiple_column_values(\n                board_id: {board_id},\n                item_id: {item_id},\n                column_values: \"{column_values_json}\"\n            ) {{\n                id\n            }}\n        }}\n        '''\n\n        self.logger.info(f\"Updating item {item_id} with columns: {column_values}\")\n\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers, json={'query': query})\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "po_column_values_formatter",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "tax_id",
                            "description",
                            "contact_pulse_id",
                            "folder_link",
                            "status",
                            "producer_id",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def po_column_values_formatter(self, project_id=None, po_number=None, tax_id=None, description=None,\n                                   contact_pulse_id=None, folder_link=None, status=None, producer_id=None, name=None):\n        column_values = {}\n        if project_id:\n            column_values[self.PO_PROJECT_ID_COLUMN] = project_id\n        if name:\n            # Ensure `name` is not a set\n            column_values[\"name\"] = list(name) if isinstance(name, set) else name\n        if po_number:\n            column_values[self.PO_NUMBER_COLUMN] = po_number\n        if tax_id:\n            column_values[self.PO_TAX_COLUMN_ID] = tax_id\n        if description:\n            column_values[self.PO_DESCRIPTION_COLUMN_ID] = description\n        if contact_pulse_id:\n            column_values[self.PO_CONTACT_CONNECTION_COLUMN_ID] = {'item_ids': [contact_pulse_id]}\n        if folder_link:\n            column_values[self.PO_FOLDER_LINK_COLUMN_ID] = {'url': folder_link, 'text': '\ud83d\udce6'}\n        if producer_id:\n            column_values[self.PO_PRODUCER_COLUMN_ID] = {'personsAndTeams': [{'id': producer_id, 'kind': 'person'}]}\n\n        # Ensure all values are JSON-serializable\n        for key, value in column_values.items():\n            if isinstance(value, set):\n                column_values[key] = list(value)\n\n        return json.dumps(column_values)"
                    },
                    {
                        "name": "prep_po_log_item_for_monday",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def prep_po_log_item_for_monday(self, item):\n        pass"
                    },
                    {
                        "name": "subitem_column_values_formatter",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "detail_number",
                            "line_number",
                            "notes",
                            "status",
                            "description",
                            "quantity",
                            "rate",
                            "date",
                            "due_date",
                            "account_number",
                            "link",
                            "OT",
                            "fringes",
                            "xero_link"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def subitem_column_values_formatter(self, project_id=None, po_number=None, detail_number=None, line_number=None,\n                                        notes=None, status=None, description=None,\n                                        quantity=None, rate=None, date=None, due_date=None,\n                                        account_number=None, link=None, OT=None, fringes=None, xero_link=None):\n        column_values = {}\n\n        if notes: column_values[self.SUBITEM_NOTES_COLUMN_ID] = notes\n        if status: column_values[self.SUBITEM_STATUS_COLUMN_ID] = {'label': status}\n        if description: column_values[self.SUBITEM_DESCRIPTION_COLUMN_ID] = description\n\n        if quantity is not None:\n            try:\n                cleaned_quantity = float(str(quantity).replace(',', '').strip())\n                column_values[self.SUBITEM_QUANTITY_COLUMN_ID] = float(cleaned_quantity)\n            except (ValueError) as e:\n                self.logger.error(f\"Invalid quantity '{quantity}': {e}\")\n                column_values[self.SUBITEM_QUANTITY_COLUMN_ID] = None\n\n        if rate is not None:\n            try:\n                cleaned_rate = float(str(rate).replace(',', '').strip())\n                column_values[self.SUBITEM_RATE_COLUMN_ID] = float(cleaned_rate)\n            except (ValueError) as e:\n                self.logger.error(f\"Invalid rate '{rate}': {e}\")\n                column_values[self.SUBITEM_RATE_COLUMN_ID] = None\n\n        if OT is not None:\n            try:\n                cleaned_OT = float(str(OT).replace(',','').strip())\n                column_values[self.SUBITEM_OT_COLUMN_ID] = float(cleaned_OT)\n            except (ValueError) as e:\n                self.logger.error(f\"Invalid OT '{OT}': {e}\")\n                column_values[self.SUBITEM_OT_COLUMN_ID] = None\n\n        if fringes is not None:\n            try:\n                cleaned_fringe = float(str(fringes).replace(',', '').strip())\n                column_values[self.SUBITEM_FRINGE_COLUMN_ID] = float(cleaned_fringe)\n            except (ValueError) as e:\n                self.logger.error(f\"Invalid fringes '{fringes}': {e}\")\n                column_values[self.SUBITEM_FRINGE_COLUMN_ID] = None\n\n        if date:\n            try:\n                if isinstance(date, str) and date.strip():\n                    parsed_date = parser.parse(date.strip())\n                elif isinstance(date, datetime):\n                    parsed_date = date\n                else:\n                    raise ValueError(\"Unsupported date format\")\n                column_values[self.SUBITEM_DATE_COLUMN_ID] = {'date': parsed_date.strftime('%Y-%m-%d')}\n            except Exception as e:\n                self.logger.error(f\"Error parsing date '{date}': {e}\")\n\n        if due_date:\n            try:\n                # Check and handle both string and datetime object formats\n                if isinstance(due_date, str) and due_date.strip():\n                    parsed_due_date = parser.parse(due_date.strip())\n                elif isinstance(due_date, datetime):\n                    parsed_due_date = due_date\n                else:\n                    raise ValueError(\"Unsupported due_date format\")\n\n                # Add the parsed due_date to column_values\n                column_values[self.SUBITEM_DUE_DATE_COLUMN_ID] = {'date': parsed_due_date.strftime('%Y-%m-%d')}\n            except Exception as e:\n                # Log and re-raise the exception for better debugging\n                self.logger.error(f\"Error parsing due_date '{due_date}': {e}\")\n                raise  # Re-raise to identify issues during debugging\n\n        if account_number:\n            try:\n                cleaned_account_number = re.sub(r'[^\\d]', '', str(account_number).strip())\n                if cleaned_account_number:\n                    column_values[self.SUBITEM_ACCOUNT_NUMBER_COLUMN_ID] = int(cleaned_account_number)\n                else:\n                    raise ValueError(f\"Account number '{account_number}' invalid after cleaning.\")\n            except (ValueError, TypeError) as e:\n                self.logger.error(f\"Invalid account number '{account_number}': {e}\")\n                column_values[self.SUBITEM_ACCOUNT_NUMBER_COLUMN_ID] = None\n\n        if link:\n            column_values[self.SUBITEM_LINK_COLUMN_ID] = {'url': link, 'text': '\ud83e\uddfe'}\n\n        if link:\n            column_values[self.SUBITEM_XERO_LINK_COLUMN_ID] = {'url': xero_link, 'text': '\ud83d\udcca'}\n\n        if po_number is not None:\n            column_values[self.SUBITEM_PO_COLUMN_ID] = po_number\n\n        if detail_number is not None:\n            column_values[self.SUBITEM_ID_COLUMN_ID] = float(detail_number)\n\n        if line_number is not None:\n            column_values[self.SUBITEM_line_number_COLUMN_ID] = int(line_number)\n\n        if project_id is not None:\n            column_values[self.SUBITEM_PROJECT_ID_COLUMN_ID] = project_id\n\n        # Ensure all values are JSON-serializable\n        for key, value in column_values.items():\n            if isinstance(value, set):\n                column_values[key] = list(value)\n\n        return json.dumps(column_values)"
                    },
                    {
                        "name": "create_subitem",
                        "args": [
                            "self",
                            "parent_item_id",
                            "subitem_name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Creates a subitem in Monday.com under a given parent item.\n\nArgs:\n    parent_item_id (str): The ID of the parent item to attach the subitem to.\n    subitem_name (str): The name of the subitem.\n    column_values (dict): A dictionary of column IDs and their corresponding values.\n\nReturns:\n    str or None: The ID of the created subitem if successful, else None.",
                        "function_body": "    def create_subitem(self, parent_item_id, subitem_name, column_values):\n        \"\"\"\n        Creates a subitem in Monday.com under a given parent item.\n\n        Args:\n            parent_item_id (str): The ID of the parent item to attach the subitem to.\n            subitem_name (str): The name of the subitem.\n            column_values (dict): A dictionary of column IDs and their corresponding values.\n\n        Returns:\n            str or None: The ID of the created subitem if successful, else None.\n        \"\"\"\n        # Remove any None values from the column values\n        column_values = {k: v for k, v in column_values.items() if v is not None}\n\n        # Convert column_values to JSON string and escape it for GraphQL\n        column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n        # GraphQL mutation for creating the subitem\n        query = f'''\n        mutation {{\n            create_subitem (\n                parent_item_id: \"{parent_item_id}\",\n                item_name: \"{subitem_name}\",\n                column_values: \"{column_values_json}\"\n            ) {{\n                id\n            }}\n        }}\n        '''\n\n        self.logger.info(f\"Creating subitem under parent {parent_item_id} with name '{subitem_name}'.\")\n\n        # Execute the request and handle the response\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers, json={'query': query})\n        data = response.json()\n\n        # Process response\n        if response.status_code == 200:"
                    },
                    {
                        "name": "update_subitem_columns",
                        "args": [
                            "self",
                            "subitem_id",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Updates the specified columns of a subitem in Monday.com.\n\nArgs:\n    subitem_id (str): The ID of the subitem to update.\n    column_values (dict): A dictionary where keys are column IDs and values are the new values for those columns.\n\nReturns:\n    bool: True if the update was successful, False otherwise.",
                        "function_body": "    def update_subitem_columns(self, subitem_id, column_values):\n        \"\"\"\n        Updates the specified columns of a subitem in Monday.com.\n\n        Args:\n            subitem_id (str): The ID of the subitem to update.\n            column_values (dict): A dictionary where keys are column IDs and values are the new values for those columns.\n\n        Returns:\n            bool: True if the update was successful, False otherwise.\n        \"\"\"\n        # Convert the column values to a JSON string and escape double quotes for GraphQL\n        column_values_json = json.dumps(column_values).replace('\"', '\\\\\"')\n\n        # GraphQL mutation to update the subitem's columns\n        mutation = f'''\n        mutation {{\n            change_multiple_column_values(\n                board_id: {self.SUBITEM_BOARD_ID},\n                item_id: {subitem_id},\n                column_values: \"{column_values_json}\"\n            ) {{\n                id\n            }}\n        }}\n        '''\n\n        self.logger.info(f\"Updating subitem {subitem_id} with columns: {column_values}\")\n\n        # Send the GraphQL request to update the subitem's columns\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers, json={'query': mutation})\n        data = response.json()\n\n        if response.status_code == 200:"
                    },
                    {
                        "name": "prep_po_log_detail_for_monday",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def prep_po_log_detail_for_monday(self, item):\n        pass"
                    },
                    {
                        "name": "link_contact_to_po_item",
                        "args": [
                            "self",
                            "po_item_id",
                            "contact_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Links a contact item from the Contacts board to a PO item in the PO board using the Connect Boards column.\n\nArgs:\n    po_item_id (str): The ID of the PO item in the PO board.\n    contact_item_id (str): The ID of the contact item in the Contacts board.\n\nReturns:\n    bool: True if the link was successful, False otherwise.",
                        "function_body": "    def link_contact_to_po_item(self, po_item_id, contact_item_id):\n        \"\"\"\n        Links a contact item from the Contacts board to a PO item in the PO board using the Connect Boards column.\n\n        Args:\n            po_item_id (str): The ID of the PO item in the PO board.\n            contact_item_id (str): The ID of the contact item in the Contacts board.\n\n        Returns:\n            bool: True if the link was successful, False otherwise.\n        \"\"\"\n        # Define the Connect Boards column ID in the PO board\n        connect_boards_column_id = self.PO_CONTACT_CONNECTION_COLUMN_ID\n\n        # Prepare the value for the Connect Boards column\n        column_value = {\n            \"item_ids\": [contact_item_id]\n        }\n\n        # Convert the column value to a JSON string\n        column_value_json = json.dumps(column_value).replace('\"', '\\\\\"')\n\n        # GraphQL mutation to update the Connect Boards column\n        mutation = f'''\n        mutation {{\n            change_column_value(\n                board_id: {self.PO_BOARD_ID},\n                item_id: {po_item_id},\n                column_id: \"{connect_boards_column_id}\",\n                value: \"{column_value_json}\"\n            ) {{\n                id\n            }}\n        }}\n        '''\n\n        self.logger.info(f\"Linking contact {contact_item_id} to PO item {po_item_id}.\")\n\n        # Send the GraphQL request to the Monday.com API\n        response = requests.post(self.MONDAY_API_URL, headers=self.headers, json={'query': mutation})\n        data = response.json()\n\n        # Check if the request was successful\n        if response.status_code == 200:"
                    },
                    {
                        "name": "prep_po_log_contact_for_monday",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def prep_po_log_contact_for_monday(self, item):\n        pass"
                    },
                    {
                        "name": "validate_monday_request",
                        "args": [
                            "self",
                            "request_headers"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Validates incoming webhook requests from Monday.com using the API token.\n\nArgs:\n    request_headers (dict): The headers from the incoming request.\n\nReturns:\n    bool: True if the request is valid, False otherwise.",
                        "function_body": "    def validate_monday_request(self, request_headers):\n        \"\"\"\n        Validates incoming webhook requests from Monday.com using the API token.\n\n        Args:\n            request_headers (dict): The headers from the incoming request.\n\n        Returns:\n            bool: True if the request is valid, False otherwise.\n        \"\"\"\n        token = request_headers.get('Authorization')\n        if not token:\n            self.logger.warning(\"Missing 'Authorization' header.\")\n            return False\n        # Assuming the token is sent as 'Bearer YOUR_TOKEN'\n        try:\n            received_token = token.split()[1]\n        except IndexError:\n            self.logger.warning(\"Invalid 'Authorization' header format.\")\n            return False\n        if received_token != self.monday_api_token:\n            self.logger.warning(\"Invalid API token.\")\n            return False\n        self.logger.info(\"Request validated successfully.\")\n        return True"
                    },
                    {
                        "name": "get_item_data",
                        "args": [
                            "self",
                            "monday_response"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_item_data(self, monday_response):\n\n        item_dict = monday_response['data']['items'][0]\n        columns_dict = {item['id']: item for item in item_dict['column_values']}\n\n        return item_dict, columns_dict"
                    },
                    {
                        "name": "get_contact_pulse_id",
                        "args": [
                            "self",
                            "columns_dict"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def get_contact_pulse_id(self, columns_dict):\n        parsed_value = json.loads(columns_dict['value'])\n        linked_pulse_id = [item['linkedPulseId'] for item in parsed_value.get('linkedPulseIds', [])]\n        return linked_pulse_id"
                    },
                    {
                        "name": "is_main_item_different",
                        "args": [
                            "self",
                            "db_item",
                            "monday_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def is_main_item_different(self, db_item, monday_item):\n        differences = []\n\n        # Extract Monday column values for easy access\n        col_vals = monday_item[\"column_values\"]\n\n        if \"connect_boards1\" in col_vals and col_vals[\"connect_boards1\"]:\n            # If it\u2019s the new format:\n            if \"value\" in col_vals[\"connect_boards1\"]:\n                if json.loads(col_vals[\"connect_boards1\"][\"value\"]):\n                    if json.loads(col_vals[\"connect_boards1\"][\"value\"]).get(\"linkedPulseIds\"):\n                        linked_pulse_id = json.loads(col_vals[\"connect_boards1\"][\"value\"]).get(\"linkedPulseIds\")[0][\"linkedPulseId\"]\n                    else:\n                        linked_pulse_id = None\n                else:\n                        linked_pulse_id = None\n            else:\n                linked_pulse_id = None\n        else:\n            linked_pulse_id = None\n\n\n        # Define a mapping between DB fields and Monday fields\n        field_map = [\n            {\n                \"field\": \"project_number\",\n                \"db_value\": db_item.get(\"project_number\"),\n                \"monday_value\": col_vals.get(\"project_id\")[\"text\"]\n            },\n            {\n                \"field\": \"contact_name\",\n                \"db_value\": db_item.get(\"contact_name\"),\n                \"monday_value\": monday_item.get(\"name\")\n            },\n            {\n                \"field\": \"PO\",\n                \"db_value\": str(db_item.get(\"po_number\")),\n                \"monday_value\": col_vals.get(\"numeric__1\")[\"text\"]\n            },\n            {\n                \"field\": \"description\",\n                \"db_value\": db_item.get(\"description\"),\n                \"monday_value\": col_vals.get(\"text6\")[\"text\"]\n            },\n            {\n                \"field\": \"Connected Contact\",\n                \"db_value\": db_item.get(\"contact_pulse_id\"),\n                \"monday_value\": linked_pulse_id\n            }\n        ]\n\n        # Compare each mapped field\n        for f in field_map:\n            db_val = f[\"db_value\"] if f[\"db_value\"] is not None else \"\"\n            mon_val = f[\"monday_value\"] if f[\"monday_value\"] is not None else \"\"\n\n            # Convert both sides to strings trimmed of whitespace for uniform comparison\n            db_str = str(db_val).strip()\n            mon_str = str(mon_val).strip()\n\n            if db_str != mon_str:\n                differences.append({\n                    \"field\": f[\"field\"],\n                    \"db_value\": db_str,\n                    \"monday_value\": mon_str\n                })\n\n        return differences"
                    },
                    {
                        "name": "is_sub_item_different",
                        "args": [
                            "self",
                            "db_sub_item",
                            "monday_sub_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def is_sub_item_different(self, db_sub_item, monday_sub_item):\n        differences = []\n\n        col_vals = monday_sub_item[\"column_values\"]\n\n        def safe_str(val):\n            return str(val).strip() if val is not None else \"\"\n\n        def are_values_equal(db_val, monday_val):\n            # Try comparing as numbers if possible\n            try:\n                return float(db_val) == float(monday_val)\n            except ValueError:\n                # Fallback to string comparison\n                return db_val == monday_val\n\n        # mapping for sub-items:\n        # Adjust these mappings to your actual column IDs for sub-items\n        field_map = [\n            {\n                \"field\": \"quantity\",\n                \"db_value\": safe_str(db_sub_item.get(\"quantity\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_QUANTITY_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"file_link\",\n                \"db_value\": safe_str(db_sub_item.get(\"file_link\")),\n                \"monday_value\":\n                    safe_str(json.loads(col_vals.get(self.SUBITEM_LINK_COLUMN_ID)['value'])[\"url\"])\n                    if col_vals.get(self.SUBITEM_LINK_COLUMN_ID)['value']\n                    else ''\n            },\n            {\n                \"field\": \"detail_number\",\n                \"db_value\": safe_str(db_sub_item.get(\"detail_number\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_ID_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"line_number\",\n                \"db_value\": safe_str(db_sub_item.get(\"line_number\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_LINE_NUMBER_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"rate\",\n                \"db_value\": safe_str(db_sub_item.get(\"rate\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_RATE_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"account_code\",\n                \"db_value\": safe_str(db_sub_item.get(\"account_code\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_ACCOUNT_NUMBER_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"ot\",\n                \"db_value\": safe_str(db_sub_item.get(\"ot\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_OT_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"state\",\n                \"db_value\": safe_str(db_sub_item.get(\"state\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_STATUS_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"fringes\",\n                \"db_value\": safe_str(db_sub_item.get(\"fringes\")),\n                \"monday_value\": safe_str(col_vals.get(self.SUBITEM_FRINGE_COLUMN_ID)['text'])\n            },\n            {\n                \"field\": \"transaction_date\",\n                \"db_value\": (\n                    safe_str(db_sub_item.get(\"transaction_date\")).split(\" \")[0]\n                    if safe_str(db_sub_item.get(\"transaction_date\"))\n                    else None\n                ),\n                \"monday_value\": safe_str(\n                    col_vals[self.SUBITEM_DATE_COLUMN_ID][\"text\"]\n                )\n            },\n            {\n                \"field\": \"due_date\",\n                \"db_value\": (\n                    safe_str(db_sub_item.get(\"due_date\")).split(\" \")[0]\n                    if safe_str(db_sub_item.get(\"due_date\"))\n                    else None\n                ),\n                \"monday_value\": safe_str(\n                    col_vals[self.SUBITEM_DUE_DATE_COLUMN_ID][\"text\"]\n                    if isinstance(col_vals[self.SUBITEM_DUE_DATE_COLUMN_ID], dict)\n                    else col_vals[self.SUBITEM_DUE_DATE_COLUMN_ID]\n                )\n            }\n        ]\n\n        # Compare each field and record differences\n        for f in field_map:\n            if not are_values_equal(f[\"db_value\"], f[\"monday_value\"]):\n                differences.append({\n                    \"field\": f[\"field\"],\n                    \"db_value\": f[\"db_value\"],\n                    \"monday_value\": f[\"monday_value\"]\n                })\n\n        return differences"
                    },
                    {
                        "name": "extract_subitem_identifiers",
                        "args": [
                            "self",
                            "monday_sub_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def extract_subitem_identifiers(self, monday_sub_item):\n        col_vals = monday_sub_item[\"column_values\"]\n\n        def safe_int(val):\n            try:\n                return int(val)\n            except (ValueError, TypeError):\n                return None\n\n        project_id = safe_int(float(col_vals[self.SUBITEM_PROJECT_ID_COLUMN_ID]['text']))\n        po_number = safe_int(float(col_vals[self.SUBITEM_PO_COLUMN_ID]['text']))\n        detail_num = safe_int(float(col_vals[self.SUBITEM_ID_COLUMN_ID]['text']))\n        line_number = safe_int(float(col_vals[self.SUBITEM_LINE_NUMBER_COLUMN_ID]['text']))\n\n        if project_id is not None and po_number is not None and detail_num is not None and line_number is not None:"
                    },
                    {
                        "name": "_extract_tax_link_from_monday",
                        "args": [
                            "self",
                            "pulse_id",
                            "all_monday_contacts"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Given a contact's Monday pulse_id, find that contact in `all_monday_contacts`\nand return the link's 'url' if it exists.",
                        "function_body": "    def _extract_tax_link_from_monday(self, pulse_id, all_monday_contacts):\n        \"\"\"\n        Given a contact's Monday pulse_id, find that contact in `all_monday_contacts`\n        and return the link's 'url' if it exists.\n        \"\"\"\n        if not pulse_id:\n            return None\n\n        for c in all_monday_contacts:\n            if c[\"id\"] == str(pulse_id):\n                # Look through column_values for the tax form link column:\n                for col in c.get(\"column_values\", []):\n                    if col[\"id\"] == self.CONTACT_TAX_FORM_LINK:\n                        try:\n                            val = json.loads(col[\"value\"])\n                            return val.get(\"url\")  # or text\n                        except:\n                            return col.get(\"text\")\n        return None"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_util",
                "value": "MondayUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_api.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayAPI",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83c\udfd7\ufe0f Sets up the Monday API singleton with proper logging, token initialization,\nand references to critical board and column IDs.",
                        "function_body": "    def __init__(self):\n        \"\"\"\n        \ud83c\udfd7\ufe0f Sets up the Monday API singleton with proper logging, token initialization,\n        and references to critical board and column IDs.\n        \"\"\"\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "_make_request",
                        "args": [
                            "self",
                            "query",
                            "variables"
                        ],
                        "decorators": [],
                        "calls": [
                            "_handle_graphql_errors",
                            "_log_complexity"
                        ],
                        "docstring": "\ud83d\udd12 Private Method: Executes a GraphQL request against the Monday.com API with:\n  - Complexity query insertion\n  - Retry logic for transient failures (e.g., connection errors)\n  - Handling of 429 (rate-limit) responses\n\n:param query: GraphQL query string\n:param variables: Optional variables dict\n:return: Parsed JSON response from Monday API\n:raises: ConnectionError if MAX_RETRIES exceeded or any unhandled error occurs",
                        "function_body": "    def _make_request(self, query: str, variables: dict = None):\n        \"\"\"\n        \ud83d\udd12 Private Method: Executes a GraphQL request against the Monday.com API with:\n          - Complexity query insertion\n          - Retry logic for transient failures (e.g., connection errors)\n          - Handling of 429 (rate-limit) responses\n\n        :param query: GraphQL query string\n        :param variables: Optional variables dict\n        :return: Parsed JSON response from Monday API\n        :raises: ConnectionError if MAX_RETRIES exceeded or any unhandled error occurs\n        \"\"\"\n        # Inject complexity block if missing\n        if \"complexity\" not in query:\n            insertion_index = query.find('{', query.find('query') if 'query' in query else query.find('mutation'))\n            if insertion_index != -1:\n                query = (query[:insertion_index + 1]\n                         + \" complexity { query before after } \"\n                         + query[insertion_index + 1:])\n\n        headers = {\"Authorization\": self.api_token}\n        attempt = 0\n\n        while attempt < MAX_RETRIES:\n            try:\n                self.logger.debug(f\"\ud83d\udce1 Attempt {attempt + 1}/{MAX_RETRIES}: Sending request to Monday.com\")\n                response = requests.post(\n                    self.api_url,\n                    json={'query': query, 'variables': variables},\n                    headers=headers,\n                    timeout=200\n                )\n                response.raise_for_status()  # Raises HTTPError if status != 200\n                data = response.json()\n\n                # If GraphQL-level errors exist, handle them\n                if \"errors\" in data:\n                    self._handle_graphql_errors(data[\"errors\"])\n\n                # Log the complexity usage\n                self._log_complexity(data)\n                return data\n\n            except requests.exceptions.ConnectionError as ce:\n                self.logger.warning(f\"\u26a0\ufe0f Connection error: {ce}. Attempt {attempt + 1}/{MAX_RETRIES}. Retrying...\")\n                time.sleep(RETRY_BACKOFF_FACTOR ** (attempt + 1))\n                attempt += 1\n\n            except requests.exceptions.HTTPError as he:\n                self.logger.error(f\"\u274c HTTP error encountered: {he}\")\n                if response.status_code == 429:\n                    # Rate limit hit\n                    retry_after = response.headers.get(\"Retry-After\", 10)\n                    self.logger.warning(f\"\ud83d\udd04 Rate limit (429) hit. Waiting {retry_after} seconds before retry.\")\n                    time.sleep(int(retry_after))\n                    attempt += 1\n                else:\n                    raise\n\n            except Exception as e:\n                self.logger.error(f\"\u274c Unexpected exception during request: {e}\")\n                raise\n\n        self.logger.error(\"\u274c Max retries reached without success. Failing the request.\")\n        raise ConnectionError(\"Failed to complete request after multiple retries.\")"
                    },
                    {
                        "name": "_handle_graphql_errors",
                        "args": [
                            "self",
                            "errors"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udd12 Private Method: Handles GraphQL-level errors returned by Monday.com.\nRaises specific exceptions based on error messages for clarity.",
                        "function_body": "    def _handle_graphql_errors(self, errors):\n        \"\"\"\n        \ud83d\udd12 Private Method: Handles GraphQL-level errors returned by Monday.com.\n        Raises specific exceptions based on error messages for clarity.\n        \"\"\"\n        for error in errors:"
                    },
                    {
                        "name": "_log_complexity",
                        "args": [
                            "self",
                            "data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udd12 Private Method: Logs complexity usage if available in the API response data.\nHelps track usage and avoid hitting Monday API limits.",
                        "function_body": "    def _log_complexity(self, data):\n        \"\"\"\n        \ud83d\udd12 Private Method: Logs complexity usage if available in the API response data.\n        Helps track usage and avoid hitting Monday API limits.\n        \"\"\"\n        complexity_info = data.get(\"data\", {}).get(\"complexity\", {})\n        if complexity_info:"
                    },
                    {
                        "name": "create_item",
                        "args": [
                            "self",
                            "board_id",
                            "group_id",
                            "name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83c\udfa8 Create a new item on a board.\n:param board_id: Board ID where the item will be created\n:param group_id: The group_id to place the item in\n:param name: Name of the new item\n:param column_values: Column values in JSON or dict format\n:return: GraphQL response",
                        "function_body": "    def create_item(self, board_id: int, group_id: str, name: str, column_values: dict):\n        \"\"\"\n        \ud83c\udfa8 Create a new item on a board.\n        :param board_id: Board ID where the item will be created\n        :param group_id: The group_id to place the item in\n        :param name: Name of the new item\n        :param column_values: Column values in JSON or dict format\n        :return: GraphQL response\n        \"\"\"\n        self.logger.debug(f\"\ud83c\udd95 Creating item on board {board_id}, group '{group_id}', name='{name}'...\")\n        query = '''\n        mutation ($board_id: ID!, $group_id: String, $item_name: String!, $column_values: JSON) {\n            create_item(board_id: $board_id, group_id: $group_id, item_name: $item_name, column_values: $column_values) {\n                id\n            }\n        }\n        '''\n        variables = {\n            'board_id': int(board_id),\n            'group_id': group_id,\n            'item_name': name,\n            'column_values': column_values\n        }\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "create_subitem",
                        "args": [
                            "self",
                            "parent_item_id",
                            "subitem_name",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83e\udde9 Create a subitem (child item) under a given parent item.\n:param parent_item_id: The parent item's ID\n:param subitem_name: Subitem name\n:param column_values: Column values in JSON or dict format\n:return: GraphQL response",
                        "function_body": "    def create_subitem(self, parent_item_id: int, subitem_name: str, column_values: dict):\n        \"\"\"\n        \ud83e\udde9 Create a subitem (child item) under a given parent item.\n        :param parent_item_id: The parent item's ID\n        :param subitem_name: Subitem name\n        :param column_values: Column values in JSON or dict format\n        :return: GraphQL response\n        \"\"\"\n        self.logger.debug(f\"\ud83c\udd95 Creating subitem under parent {parent_item_id} with name='{subitem_name}'...\")\n        query = '''\n        mutation ($parent_item_id: ID!, $subitem_name: String!, $column_values: JSON!) {\n            create_subitem(parent_item_id: $parent_item_id, item_name: $subitem_name, column_values: $column_values) {\n                id\n            }\n        }\n        '''\n        variables = {\n            'parent_item_id': parent_item_id,\n            'subitem_name': subitem_name,\n            'column_values': column_values\n        }\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "create_contact",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\uddc2\ufe0f Create a new contact in the 'Contacts' board.\n:param name: Contact Name\n:return: GraphQL response with ID and name",
                        "function_body": "    def create_contact(self, name):\n        \"\"\"\n        \ud83d\uddc2\ufe0f Create a new contact in the 'Contacts' board.\n        :param name: Contact Name\n        :return: GraphQL response with ID and name\n        \"\"\"\n        self.logger.debug(f\"\ud83c\udd95 Creating contact with name='{name}'...\")\n        query = '''\n        mutation ($board_id: ID!, $item_name: String!) {\n            create_item(board_id: $board_id, item_name: $item_name) {\n                id,\n                name\n            }\n        }\n        '''\n        variables = {\n            'board_id': int(self.CONTACT_BOARD_ID),\n            'item_name': name,\n        }\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "update_item",
                        "args": [
                            "self",
                            "item_id",
                            "column_values",
                            "type"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd27 Updates an existing item, subitem, or contact.\n:param item_id: Pulse (item) ID to update\n:param column_values: Dict/JSON of column values to update\n:param type: 'main', 'subitem', or 'contact' to determine board\n:return: GraphQL response",
                        "function_body": "    def update_item(self, item_id: str, column_values, type=\"main\"):\n        \"\"\"\n        \ud83d\udd27 Updates an existing item, subitem, or contact.\n        :param item_id: Pulse (item) ID to update\n        :param column_values: Dict/JSON of column values to update\n        :param type: 'main', 'subitem', or 'contact' to determine board\n        :return: GraphQL response\n        \"\"\"\n        self.logger.debug(f\"\u2699\ufe0f Updating item {item_id} on type='{type}' board...\")\n        query = '''\n        mutation ($board_id: ID!, $item_id: ID!, $column_values: JSON!) {\n            change_multiple_column_values(board_id: $board_id, item_id: $item_id, column_values: $column_values) {\n                id\n            }\n        }\n        '''\n\n        # Determine board_id based on 'type'\n        if type == \"main\":\n            board_id = self.PO_BOARD_ID\n        elif type == \"subitem\":\n            board_id = self.SUBITEM_BOARD_ID\n        elif type == \"contact\":\n            board_id = self.CONTACT_BOARD_ID\n        else:\n            # fallback, though it's unusual: pass \"main\" or raise an error\n            board_id = self.PO_BOARD_ID\n\n        variables = {\n            'board_id': str(board_id),\n            'item_id': str(item_id),\n            'column_values': column_values\n        }\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "fetch_all_items",
                        "args": [
                            "self",
                            "board_id",
                            "limit"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetches all items from a given board using cursor-based pagination.\n:param board_id: Board ID to fetch items from\n:param limit: # of items to fetch per query\n:return: List of item dicts as returned by Monday",
                        "function_body": "    def fetch_all_items(self, board_id, limit=200):\n        \"\"\"\n        \ud83d\udd0e Fetches all items from a given board using cursor-based pagination.\n        :param board_id: Board ID to fetch items from\n        :param limit: # of items to fetch per query\n        :return: List of item dicts as returned by Monday\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udce5 Fetching all items from board {board_id} with limit={limit}...\")\n        all_items = []\n        cursor = None\n\n        while True:\n            if cursor:\n                # Fetch next page\n                query = \"\"\"\n                query ($cursor: String!, $limit: Int!) {\n                    complexity { query before after }\n                    next_items_page(cursor: $cursor, limit: $limit) {\n                        cursor\n                        items {\n                            id\n                            name\n                            column_values {\n                                id\n                                text\n                                value\n                            }\n                        }\n                    }\n                }\n                \"\"\"\n                variables = {'cursor': cursor, 'limit': limit}\n            else:\n                # Initial page\n                query = \"\"\"\n                query ($board_id: [ID!]!, $limit: Int!) {\n                    complexity { query before after }\n                    boards(ids: $board_id) {\n                        items_page(limit: $limit) {\n                            cursor\n                            items {\n                                id\n                                name\n                                column_values {\n                                    id\n                                    text\n                                    value\n                                }\n                            }\n                        }\n                    }\n                }\n                \"\"\"\n                variables = {'board_id': str(board_id), 'limit': limit}\n\n            try:\n                response = self._make_request(query, variables)\n            except Exception as e:\n                self.logger.error(f\"\u274c Error fetching items: {e}\")\n                break\n\n            if cursor:\n                items_data = response.get('data', {}).get('next_items_page', {})\n            else:\n                boards_data = response.get('data', {}).get('boards', [])\n                if not boards_data:\n                    self.logger.warning(f\"\u26a0\ufe0f No boards found for board_id {board_id}. Check your permissions or ID.\")\n                    break\n                items_data = boards_data[0].get('items_page', {})\n\n            items = items_data.get('items', [])\n            all_items.extend(items)\n            cursor = items_data.get('cursor')\n\n            if not cursor:\n                self.logger.debug(\"\u2705 No more pages left to fetch for this board.\")\n                break\n\n            self.logger.info(f\"\ud83d\udcc4 Fetched {len(items)} items from board {board_id}. Continuing pagination...\")\n\n        return all_items"
                    },
                    {
                        "name": "fetch_all_sub_items",
                        "args": [
                            "self",
                            "limit"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch all subitems from the subitem board, filtering out those without a parent_item.\nReturns only valid subitems that have a parent.",
                        "function_body": "    def fetch_all_sub_items(self, limit=100):\n        \"\"\"\n        \ud83d\udd0e Fetch all subitems from the subitem board, filtering out those without a parent_item.\n        Returns only valid subitems that have a parent.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udce5 Fetching all subitems from subitem board {self.SUBITEM_BOARD_ID}, limit={limit}...\")\n        all_items = []\n        cursor = None\n\n        while True:\n            if cursor:\n                query = \"\"\"\n                query ($cursor: String!, $limit: Int!) {\n                    complexity { query before after }\n                    next_items_page(cursor: $cursor, limit: $limit) {\n                        cursor\n                        items  {\n                            id\n                            name\n                            parent_item {\n                                id\n                                name\n                            }\n                            column_values {\n                                id\n                                text\n                                value\n                            }\n                        }\n                    }\n                }\n                \"\"\"\n                variables = {'cursor': cursor, 'limit': limit}\n            else:\n                query = \"\"\"\n                query ($board_id: [ID!]!, $limit: Int!) {\n                    complexity { query before after }\n                    boards(ids: $board_id) {\n                        items_page(limit: $limit) {\n                            cursor\n                            items {\n                                id\n                                name\n                                parent_item {\n                                    id\n                                    name\n                                }\n                                column_values {\n                                    id\n                                    text\n                                    value\n                                }\n                            }\n                        }\n                    }\n                }\n                \"\"\"\n                variables = {'board_id': str(self.SUBITEM_BOARD_ID), 'limit': limit}\n\n            try:\n                response = self._make_request(query, variables)\n            except Exception as e:\n                self.logger.error(f\"\u274c Error fetching subitems: {e}\")\n                break\n\n            if cursor:\n                items_data = response.get('data', {}).get('next_items_page', {})\n            else:\n                boards_data = response.get('data', {}).get('boards', [])\n                if not boards_data:\n                    self.logger.warning(\n                        f\"\u26a0\ufe0f No boards found for board_id {self.SUBITEM_BOARD_ID}. Check your permissions or ID.\"\n                    )\n                    break\n                items_data = boards_data[0].get('items_page', {})\n\n            items = items_data.get('items', [])\n            valid_items = [item for item in items if item.get('parent_item') is not None]\n\n            all_items.extend(valid_items)\n            cursor = items_data.get('cursor')\n\n            if not cursor:\n                self.logger.debug(\"\u2705 No more subitem pages left to fetch.\")\n                break\n\n            self.logger.info(f\"\ud83d\udcc4 Fetched {len(valid_items)} valid subitems from board {self.SUBITEM_BOARD_ID}. Continuing...\")\n\n        return all_items"
                    },
                    {
                        "name": "get_subitems_in_board",
                        "args": [
                            "self",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "Fetches subitems from the subitem board (self.SUBITEM_BOARD_ID).\n\n- If project_number is None, returns all subitems from the subitem board.\n- If project_number is provided, returns all subitems whose\n  project_id column (self.monday_util.SUBITEM_PROJECT_ID_COLUMN_ID)\n  matches the given project_number.\n\nFor each subitem, we transform its 'column_values' list into a dict:\n  \"column_values\": {\n      <column_id>: {\n          \"text\": <string>,\n          \"value\": <raw JSON string or None>\n      },\n      ...\n  }\n\nReturns: a list of subitem dicts like:\n[\n  {\n    \"id\": <subitem_id>,\n    \"name\": <subitem_name>,\n    \"parent_item\": {\n        \"id\": <parent_item_id>,\n        \"name\": <parent_item_name>\n    },\n    \"column_values\": {\n        \"<col_id>\": { \"text\": ..., \"value\": ... },\n        ...\n    }\n  },\n  ...\n]",
                        "function_body": "    def get_subitems_in_board(self, project_number=None):\n        \"\"\"\n        Fetches subitems from the subitem board (self.SUBITEM_BOARD_ID).\n\n        - If project_number is None, returns all subitems from the subitem board.\n        - If project_number is provided, returns all subitems whose\n          project_id column (self.monday_util.SUBITEM_PROJECT_ID_COLUMN_ID)\n          matches the given project_number.\n\n        For each subitem, we transform its 'column_values' list into a dict:\n          \"column_values\": {\n              <column_id>: {\n                  \"text\": <string>,\n                  \"value\": <raw JSON string or None>\n              },\n              ...\n          }\n\n        Returns: a list of subitem dicts like:\n        [\n          {\n            \"id\": <subitem_id>,\n            \"name\": <subitem_name>,\n            \"parent_item\": {\n                \"id\": <parent_item_id>,\n                \"name\": <parent_item_name>\n            },\n            \"column_values\": {\n                \"<col_id>\": { \"text\": ..., \"value\": ... },\n                ...\n            }\n          },\n          ...\n        ]\n        \"\"\"\n        board_id = self.SUBITEM_BOARD_ID\n        column_id = self.monday_util.SUBITEM_PROJECT_ID_COLUMN_ID\n        limit = 200\n\n        self.logger.info(\n            f\"\ud83d\udce5 Fetching subitems from board_id={board_id}, project_number={project_number}\"\n        )\n\n        all_items = []\n        cursor = None\n\n        # ---------------------------\n        # If no project_number, fetch everything\n        # ---------------------------\n        if project_number is None:"
                    },
                    {
                        "name": "fetch_all_contacts",
                        "args": [
                            "self",
                            "limit"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch all contacts from the 'Contacts' board with pagination.\n:param limit: number of items to fetch per page\n:return: List of contact items",
                        "function_body": "    def fetch_all_contacts(self, limit: int = 250) -> list:\n        \"\"\"\n        \ud83d\udd0e Fetch all contacts from the 'Contacts' board with pagination.\n        :param limit: number of items to fetch per page\n        :return: List of contact items\n        \"\"\"\n        self.logger.info(\"\ud83d\udce5 Fetching all contacts from the Contacts board...\")\n        all_items = []\n        cursor = None\n\n        while True:\n            if cursor:\n                query = \"\"\"\n                query ($cursor: String!, $limit: Int!) {\n                    complexity { query before after }\n                    next_items_page(cursor: $cursor, limit: $limit) {\n                        cursor\n                        items {\n                            id\n                            name\n                            column_values {\n                                id\n                                text\n                                value\n                            }\n                        }\n                    }\n                }\n                \"\"\"\n                variables = {'cursor': cursor, 'limit': limit}\n            else:\n                query = \"\"\"\n                query ($board_id: [ID!]!, $limit: Int!) {\n                    complexity { query before after }\n                    boards(ids: $board_id) {\n                        items_page(limit: $limit) {\n                            cursor\n                            items {\n                                id\n                                name\n                                column_values {\n                                    id\n                                    text\n                                    value\n                                }\n                            }\n                        }\n                    }\n                }\n                \"\"\"\n                variables = {'board_id': str(self.monday_util.CONTACT_BOARD_ID), 'limit': limit}\n\n            try:\n                response = self._make_request(query, variables)\n            except Exception as e:\n                self.logger.error(f\"\u274c Error fetching contacts: {e}\")\n                break\n\n            if cursor:\n                items_data = response.get(\"data\", {}).get(\"next_items_page\", {})\n            else:\n                boards_data = response.get('data', {}).get('boards', [])\n                if not boards_data:\n                    self.logger.warning(\n                        f\"\u26a0\ufe0f No boards found for board_id {self.monday_util.CONTACT_BOARD_ID}. Check your permissions or ID.\"\n                    )\n                    break\n                items_data = boards_data[0].get('items_page', {})\n\n            items = items_data.get('items', [])\n            all_items.extend(items)\n            cursor = items_data.get('cursor')\n\n            if not cursor:\n                self.logger.debug(\"\u2705 All contacts fetched successfully.\")\n                break\n\n            self.logger.debug(f\"\ud83d\udd04 Fetched {len(items)} contacts so far. Continuing pagination...\")\n\n        return all_items"
                    },
                    {
                        "name": "fetch_item_by_ID",
                        "args": [
                            "self",
                            "id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a single item by ID.\n:param id: Item (pulse) ID\n:return: The item dict, or None if not found",
                        "function_body": "    def fetch_item_by_ID(self, id: str):\n        \"\"\"\n        \ud83d\udd0e Fetch a single item by ID.\n        :param id: Item (pulse) ID\n        :return: The item dict, or None if not found\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd75\ufe0f Searching for item by ID '{id}'...\")\n        try:"
                    },
                    {
                        "name": "fetch_group_ID",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetches the group ID whose title contains the given project_id.\n:param project_id: The project identifier string\n:return: Group ID as string or None if no match",
                        "function_body": "    def fetch_group_ID(self, project_id):\n        \"\"\"\n        \ud83d\udd0e Fetches the group ID whose title contains the given project_id.\n        :param project_id: The project identifier string\n        :return: Group ID as string or None if no match\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd75\ufe0f Searching for group ID matching project_id='{project_id}' on board {self.PO_BOARD_ID}...\")\n        query = f'''\n        query {{\n            complexity {{ query before after }}\n            boards (ids: {self.PO_BOARD_ID}) {{\n                groups {{\n                  title\n                  id\n                }}\n            }}\n        }}\n        '''\n        response = self._make_request(query, {})\n        groups = response[\"data\"][\"boards\"][0][\"groups\"]\n        for group in groups:\n            if group[\"title\"] and project_id in group[\"title\"]:\n                self.logger.debug(f\"\u2705 Found group '{group['title']}' with ID '{group['id']}'.\")\n                return group[\"id\"]\n        self.logger.debug(\"\ud83d\udd75\ufe0f No matching group found.\")\n        return None"
                    },
                    {
                        "name": "fetch_subitem_by_receipt_and_line",
                        "args": [
                            "self",
                            "receipt_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch subitem matching receipt_number & line_number from subitem board.\nReplace 'receipt_number_column_id' and 'line_number_column_id' with your real subitem board columns.",
                        "function_body": "    def fetch_subitem_by_receipt_and_line(self, receipt_number, line_number):\n        \"\"\"\n        \ud83d\udd0e Fetch subitem matching receipt_number & line_number from subitem board.\n        Replace 'receipt_number_column_id' and 'line_number_column_id' with your real subitem board columns.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd0d Searching subitem by receipt_number='{receipt_number}', line_number='{line_number}'...\")\n        receipt_number_column_id = \"numeric__1\"\n        line_number_column_id = \"numbers_Mjj5uYts\"\n\n        query = f'''\n        query ($board_id: ID!, $receipt_number: String!, $line_number: String!) {{\n            complexity {{ query before after }}\n            items_page_by_column_values(\n                board_id: $board_id, \n                columns: [\n                  {{column_id: \"{receipt_number_column_id}\", column_values: [$receipt_number]}}, \n                  {{column_id: \"{line_number_column_id}\", column_values: [$line_number]}}\n                ], \n                limit: 1\n            ) {{\n                items {{\n                    id\n                    column_values {{\n                        id\n                        text\n                        value\n                    }}\n                }}\n            }}\n        }}\n        '''\n        variables = {\n            'board_id': int(self.SUBITEM_BOARD_ID),\n            'receipt_number': str(receipt_number),\n            'line_number': str(line_number)\n        }\n\n        response = self._make_request(query, variables)\n        items = response.get(\"data\", {}).get(\"items_page_by_column_values\", {}).get(\"items\", [])\n        return items[0] if items else None"
                    },
                    {
                        "name": "fetch_item_by_po_and_project",
                        "args": [
                            "self",
                            "project_id",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a main item by matching project_id and po_number columns.\n:param project_id: The project identifier\n:param po_number: The Purchase Order number\n:return: GraphQL response with item(s) in 'data.items_page_by_column_values.items'",
                        "function_body": "    def fetch_item_by_po_and_project(self, project_id, po_number):\n        \"\"\"\n        \ud83d\udd0e Fetch a main item by matching project_id and po_number columns.\n        :param project_id: The project identifier\n        :param po_number: The Purchase Order number\n        :return: GraphQL response with item(s) in 'data.items_page_by_column_values.items'\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd0d Searching for item with project_id='{project_id}', po_number='{po_number}'...\")\n        query = '''\n        query ($board_id: ID!, $po_number: String!, $project_id: String!, $project_id_column: String!, $po_column: String!) {\n            complexity { query before after }\n            items_page_by_column_values (limit: 1, board_id: $board_id, \n                columns: [\n                   {column_id: $project_id_column, column_values: [$project_id]}, \n                   {column_id: $po_column, column_values: [$po_number]}\n                ]) {\n                items {\n                  id\n                  name\n                  column_values {\n                    id\n                    value\n                  }\n                }\n            }\n        }'''\n        variables = {\n            'board_id': int(self.PO_BOARD_ID),\n            'po_number': str(po_number),\n            'project_id': str(project_id),\n            'po_column': str(self.po_number_column),\n            'project_id_column': str(self.project_id_column)\n        }\n        return self._make_request(query, variables)"
                    },
                    {
                        "name": "fetch_subitem_by_po_receipt_line",
                        "args": [
                            "self",
                            "po_number",
                            "receipt_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a subitem by matching PO number, receipt number, and line ID columns.",
                        "function_body": "    def fetch_subitem_by_po_receipt_line(self, po_number, receipt_number, line_number):\n        \"\"\"\n        \ud83d\udd0e Fetch a subitem by matching PO number, receipt number, and line ID columns.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd0d Searching subitem (PO='{po_number}', receipt='{receipt_number}', line_number='{line_number}')...\")\n        po_number_column_id = self.monday_util.SUBITEM_PO_COLUMN_ID\n        receipt_number_column_id = self.monday_util.SUBITEM_ID_COLUMN_ID\n        line_number_column_id = self.monday_util.SUBITEM_LINE_NUMBER_COLUMN_ID\n\n        query = f'''\n        query ($board_id: ID!, $po_number: String!, $receipt_number: String!, $line_number: String!) {{\n            complexity {{ query before after }}\n            items_page_by_column_values(\n                board_id: $board_id, \n                columns: [\n                    {{column_id: \"{po_number_column_id}\", column_values: [$po_number]}},\n                    {{column_id: \"{receipt_number_column_id}\", column_values: [$receipt_number]}},\n                    {{column_id: \"{line_number_column_id}\", column_values: [$line_number]}}\n                ], \n                limit: 1\n            ) {{\n                items {{\n                    id\n                    column_values {{\n                        id\n                        text\n                        value\n                    }}\n                }}\n            }}\n        }}\n        '''\n        variables = {\n            'board_id': int(self.SUBITEM_BOARD_ID),\n            'po_number': str(po_number),\n            'receipt_number': str(receipt_number),\n            'line_number': str(line_number)\n        }\n\n        response = self._make_request(query, variables)\n        items = response.get(\"data\", {}).get(\"items_page_by_column_values\", {}).get(\"items\", [])\n        if items:\n            self.logger.debug(f\"\u2705 Found subitem with ID {items[0]['id']}\")\n        else:\n            self.logger.debug(\"\ud83d\udd75\ufe0f No subitem found for the given PO, receipt, and line.\")\n        return items[0] if items else None"
                    },
                    {
                        "name": "fetch_item_by_name",
                        "args": [
                            "self",
                            "name",
                            "board"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch a single item by 'name' column on the specified board.\n:param name: The item's name to search for\n:param board: 'PO', 'Contacts', or fallback to subitem board\n:return: The single matching item dict or None if not found",
                        "function_body": "    def fetch_item_by_name(self, name, board='PO'):\n        \"\"\"\n        \ud83d\udd0e Fetch a single item by 'name' column on the specified board.\n        :param name: The item's name to search for\n        :param board: 'PO', 'Contacts', or fallback to subitem board\n        :return: The single matching item dict or None if not found\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udd0e Searching item by name='{name}' on '{board}' board...\")\n        query = '''\n        query ($board_id: ID!, $name: String!) {\n            complexity { query before after }\n            items_page_by_column_values (limit: 1, board_id: $board_id, columns: [{column_id: \"name\", column_values: [$name]}]) {\n                items {\n                  id\n                  name\n                  column_values {\n                    id\n                    value\n                  }\n                }\n            }\n        }'''\n\n        if board == \"PO\":\n            board_id = self.PO_BOARD_ID\n        elif board == \"Contacts\":\n            board_id = self.CONTACT_BOARD_ID\n        else:\n            board_id = self.SUBITEM_BOARD_ID\n\n        variables = {'board_id': int(board_id), 'name': str(name)}\n        response = self._make_request(query, variables)\n        item_list = response[\"data\"][\"items_page_by_column_values\"][\"items\"]\n        if len(item_list) != 1:\n            self.logger.debug(\"\ud83d\udd75\ufe0f No single matching item found or multiple matches encountered.\")\n            return None\n        self.logger.debug(f\"\u2705 Found item with ID={item_list[0]['id']}.\")\n        return item_list"
                    },
                    {
                        "name": "_safe_get_text",
                        "args": [
                            "self",
                            "vals_dict",
                            "col_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udee1\ufe0f Safe retrieval of text from column_values dict.\nUseful if the value doesn't exist or is None.",
                        "function_body": "    def _safe_get_text(self, vals_dict, col_id):\n        \"\"\"\n        \ud83d\udee1\ufe0f Safe retrieval of text from column_values dict.\n        Useful if the value doesn't exist or is None.\n        \"\"\"\n        return vals_dict.get(col_id, {}).get(\"text\", \"\")"
                    },
                    {
                        "name": "get_items_in_project",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Retrieve all items from the PO_BOARD_ID that match a given project_id column value.\nUses cursor-based pagination if needed.\n:param project_id: The project identifier (string)\n:return: A list of items with column_values as a dict",
                        "function_body": "    def get_items_in_project(self, project_id):\n        \"\"\"\n        \ud83d\udd0e Retrieve all items from the PO_BOARD_ID that match a given project_id column value.\n        Uses cursor-based pagination if needed.\n        :param project_id: The project identifier (string)\n        :return: A list of items with column_values as a dict\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udce5 Fetching all items in project_id='{project_id}' from board {self.PO_BOARD_ID} ...\")\n        query = '''\n        query ($board_id: ID!, $project_id_column: String!, $project_id_val: String!, $limit: Int, $cursor: String) {\n            items_page_by_column_values(\n                board_id: $board_id,\n                columns: [{column_id: $project_id_column, column_values: [$project_id_val]}],\n                limit: $limit,\n                cursor: $cursor\n            ) {\n                cursor\n                items {\n                    id\n                    name\n                    column_values {\n                        id\n                        text\n                        value\n                    }\n                }\n            }\n        }'''\n\n        variables = {\n            'board_id': self.PO_BOARD_ID,\n            'project_id_column': self.project_id_column,\n            'project_id_val': str(project_id),\n            'limit': 500,\n            'cursor': None\n        }\n\n        all_items = []\n        try:"
                    },
                    {
                        "name": "get_subitems_for_item",
                        "args": [
                            "self",
                            "item_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83d\udd0e Fetch subitems for a given parent item_id in the main board.\n:param item_id: Main item ID\n:return: List of subitem dicts: { \"id\": subitem_id, \"name\": subitem_name, \"column_values\": {..} }",
                        "function_body": "    def get_subitems_for_item(self, item_id):\n        \"\"\"\n        \ud83d\udd0e Fetch subitems for a given parent item_id in the main board.\n        :param item_id: Main item ID\n        :return: List of subitem dicts: { \"id\": subitem_id, \"name\": subitem_name, \"column_values\": {..} }\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udce5 Fetching subitems for item_id={item_id} ...\")\n        query = '''\n        query ($item_id: [ID!]!) {\n            complexity { query before after }\n            items (ids: $item_id) {\n                id\n                name\n                subitems {\n                    id\n                    name\n                    column_values {\n                        id\n                        text\n                    }\n                }\n            }\n        }\n        '''\n        variables = {'item_id': str(item_id)}\n        try:"
                    },
                    {
                        "name": "batch_create_or_update_items",
                        "args": [
                            "self",
                            "batch",
                            "project_id",
                            "create"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item",
                            "create_items_batch"
                        ],
                        "docstring": "\ud83d\udd01 Batch create or update multiple main items (PO items).\n:param batch: List of dicts -> each has {\"db_item\": ..., \"column_values\": {...}, \"monday_item_id\": ...}\n:param project_id: The project ID (for logging or grouping)\n:param create: True -> create new items. False -> update existing.\n:return: The updated batch with \"monday_item_id\" filled as needed.",
                        "function_body": "    def batch_create_or_update_items(self, batch, project_id, create=True):\n        \"\"\"\n        \ud83d\udd01 Batch create or update multiple main items (PO items).\n        :param batch: List of dicts -> each has {\"db_item\": ..., \"column_values\": {...}, \"monday_item_id\": ...}\n        :param project_id: The project ID (for logging or grouping)\n        :param create: True -> create new items. False -> update existing.\n        :return: The updated batch with \"monday_item_id\" filled as needed.\n        \"\"\"\n        self.logger.info(\n            f\"\u2699\ufe0f Processing a batch of {len(batch)} items for project_id='{project_id}', create={create}...\"\n        )\n\n        # Helper function to process one sub-batch\n        def create_sub_batch(sub_batch):\n            \"\"\"Create items in Monday from a sub-batch.\"\"\"\n            return self.create_items_batch(sub_batch, project_id)\n\n        if create:"
                    },
                    {
                        "name": "batch_create_or_update_subitems",
                        "args": [
                            "self",
                            "subitems_batch",
                            "parent_item_id",
                            "create"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item",
                            "create_subitem"
                        ],
                        "docstring": "\ud83d\udd01 Batch create or update multiple subitems under a given parent_item_id.\n:param subitems_batch: List of dicts -> each has:\n    {\n      \"db_sub_item\": ...,nnb\n      \"column_values\": {...},\n      \"monday_subitem_id\": maybe_id,\n      \"parent_id\": parent_item_id\n    }\n:param parent_item_id: Parent item ID\n:param create: If True, create new subitems. Otherwise, update existing ones.\n:return: Updated batch with new subitem IDs if created",
                        "function_body": "    def batch_create_or_update_subitems(self, subitems_batch, parent_item_id, create=True):\n        \"\"\"\n        \ud83d\udd01 Batch create or update multiple subitems under a given parent_item_id.\n        :param subitems_batch: List of dicts -> each has:\n            {\n              \"db_sub_item\": ...,nnb\n              \"column_values\": {...},\n              \"monday_subitem_id\": maybe_id,\n              \"parent_id\": parent_item_id\n            }\n        :param parent_item_id: Parent item ID\n        :param create: If True, create new subitems. Otherwise, update existing ones.\n        :return: Updated batch with new subitem IDs if created\n        \"\"\"\n        self.logger.info(f\"\u2699\ufe0f Processing a batch of {len(subitems_batch)} subitems for parent_item_id='{parent_item_id}', create={create}...\")\n        updated_batch = []\n\n        for si in subitems_batch:\n            db_sub_item = si.get(\"db_sub_item\")\n            column_values = si[\"column_values\"]\n            column_values_json = json.dumps(column_values)\n\n            if create:\n                # Create subitem\n                subitem_name = db_sub_item.get(\"name\", db_sub_item.get(\"vendor\", \"Subitem\"))\n                try:\n                    self.logger.debug(f\"\ud83d\udc76 Creating subitem '{subitem_name}' under parent {parent_item_id}...\")\n                    create_response = self.create_subitem(parent_item_id, subitem_name, column_values_json)\n                    new_id = create_response[\"data\"][\"create_subitem\"][\"id\"]\n                    si[\"monday_item_id\"] = new_id\n                    updated_batch.append(si)\n                except Exception as e:\n                    self.logger.exception(f\"\u274c Error creating subitem for {db_sub_item}: {e}\")\n                    raise\n            else:\n                # Update existing subitem\n                sub_id = si[\"monday_item_id\"]\n                try:\n                    self.logger.debug(f\"\ud83d\udd04 Updating subitem '{sub_id}' with new column values...\")\n                    self.update_item(sub_id, column_values_json, type=\"subitem\")\n                    updated_batch.append(si)\n                except Exception as e:\n                    self.logger.exception(f\"\u274c Error updating subitem {sub_id}: {e}\")\n                    raise\n\n        return updated_batch"
                    },
                    {
                        "name": "create_items_batch",
                        "args": [
                            "self",
                            "batch",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "\ud83c\udf89 Bulk-create multiple items in a single GraphQL request.\nEach item in 'batch' should have a dict: { 'db_item': ..., 'column_values': {...}, 'monday_item_id': None }\n:param batch: Items to create\n:param project_id: Project identifier for logging\n:return: The batch updated with 'monday_item_id' for each newly created item.",
                        "function_body": "    def create_items_batch(self, batch, project_id):\n        \"\"\"\n        \ud83c\udf89 Bulk-create multiple items in a single GraphQL request.\n        Each item in 'batch' should have a dict: { 'db_item': ..., 'column_values': {...}, 'monday_item_id': None }\n        :param batch: Items to create\n        :param project_id: Project identifier for logging\n        :return: The batch updated with 'monday_item_id' for each newly created item.\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd28 Bulk-creating {len(batch)} items for project_id='{project_id}' in one request...\")\n\n        mutation_parts = []\n        for i, itm in enumerate(batch):\n            column_values = itm[\"column_values\"]\n            column_values_json = json.dumps(column_values)\n\n            # Use 'name' if present, otherwise fallback\n            item_name = column_values.get(\"name\", \"Unnamed Item\")\n            safe_item_name = json.dumps(item_name)\n\n            mutation_parts.append(\n                f'create{i}: create_item('\n                f'board_id: {self.PO_BOARD_ID}, '\n                f'item_name: {safe_item_name}, '\n                f'column_values: {json.dumps(column_values_json)}) '\n                '{ id }'\n            )\n\n        mutation_body = \" \".join(mutation_parts)\n        query = f'mutation {{ {mutation_body} }}'\n\n        response = self._make_request(query)\n\n        # Parse response and assign IDs\n        for i, itm in enumerate(batch):\n            create_key = f\"create{i}\"\n            created_item = response.get(\"data\", {}).get(create_key)\n            if created_item and \"id\" in created_item:\n                itm[\"monday_item_id\"] = created_item[\"id\"]\n                self.logger.debug(f\"\u2705 Created item index {i} with new ID {itm['monday_item_id']}\")\n            else:\n                self.logger.warning(f\"\u26a0\ufe0f No ID returned for item index {i} in batch.\")\n\n        return batch"
                    },
                    {
                        "name": "find_or_create_item_in_monday",
                        "args": [
                            "self",
                            "item",
                            "column_values"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_item",
                            "po_column_values_formatter",
                            "fetch_item_by_po_and_project",
                            "update_item"
                        ],
                        "docstring": "\ud83d\udd0e Finds an item by project_id & PO. If it exists, returns it.\nOtherwise, creates a new item.\n:param item: dict with keys [\"project_id\", \"PO\", \"name\", \"group_id\", ...]\n:param column_values: JSON/dict of column values\n:return: The updated item with \"item_pulse_id\" assigned",
                        "function_body": "    def find_or_create_item_in_monday(self, item, column_values):\n        \"\"\"\n        \ud83d\udd0e Finds an item by project_id & PO. If it exists, returns it.\n        Otherwise, creates a new item.\n        :param item: dict with keys [\"project_id\", \"PO\", \"name\", \"group_id\", ...]\n        :param column_values: JSON/dict of column values\n        :return: The updated item with \"item_pulse_id\" assigned\n        \"\"\"\n        self.logger.info(f\"\ud83d\udd0e Checking if item with project_id='{item['project_id']}' and PO='{item['PO']}' exists...\")\n        response = self.fetch_item_by_po_and_project(item[\"project_id\"], item[\"PO\"])\n        response_item = response[\"data\"][\"items_page_by_column_values\"][\"items\"]\n\n        if len(response_item) == 1:"
                    },
                    {
                        "name": "find_or_create_sub_item_in_monday",
                        "args": [
                            "self",
                            "sub_item",
                            "parent_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "subitem_column_values_formatter",
                            "update_item",
                            "fetch_subitem_by_po_receipt_line",
                            "create_subitem",
                            "fetch_item_by_ID"
                        ],
                        "docstring": "\ud83d\udd0e Finds or creates a subitem in Monday corresponding to external data (invoice lines, hours, etc.).\n:param sub_item: dict with keys like [\"line_number\", \"date\", \"due date\", \"po_number\", \"vendor\", etc.]\n:param parent_item: dict with at least [\"item_pulse_id\", \"status\", \"name\", ...]\n:return: The updated sub_item with \"pulse_id\" assigned if created or found",
                        "function_body": "    def find_or_create_sub_item_in_monday(self, sub_item, parent_item):\n        \"\"\"\n        \ud83d\udd0e Finds or creates a subitem in Monday corresponding to external data (invoice lines, hours, etc.).\n        :param sub_item: dict with keys like [\"line_number\", \"date\", \"due date\", \"po_number\", \"vendor\", etc.]\n        :param parent_item: dict with at least [\"item_pulse_id\", \"status\", \"name\", ...]\n        :return: The updated sub_item with \"pulse_id\" assigned if created or found\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "parse_tax_number",
                        "args": [
                            "self",
                            "tax_str"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83e\uddfe Removes hyphens (e.g., for SSN '123-45-6789' or EIN '12-3456789') and attempts to parse as int.\nReturns None if parsing fails or if the string is empty.",
                        "function_body": "    def parse_tax_number(self, tax_str: str):\n        \"\"\"\n        \ud83e\uddfe Removes hyphens (e.g., for SSN '123-45-6789' or EIN '12-3456789') and attempts to parse as int.\n        Returns None if parsing fails or if the string is empty.\n        \"\"\"\n        if not tax_str:\n            self.logger.debug(\"No tax_str provided. Returning None.\")\n            return None\n\n        cleaned = tax_str.replace('-', '')\n        try:"
                    },
                    {
                        "name": "extract_monday_contact_fields",
                        "args": [
                            "self",
                            "contact_item"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\uddc2\ufe0f Converts a Monday contact_item (including its column_values) into a structured dict of fields.",
                        "function_body": "    def extract_monday_contact_fields(self, contact_item: dict) -> dict:\n        \"\"\"\n        \ud83d\uddc2\ufe0f Converts a Monday contact_item (including its column_values) into a structured dict of fields.\n        \"\"\"\n        self.logger.debug(f\"\ud83d\udce6 Extracting contact fields from item ID={contact_item.get('id')}...\")\n        column_values = contact_item.get(\"column_values\", [])\n\n        def parse_column_value(cv):\n            raw_text = cv.get(\"text\") or \"\"\n            raw_value = cv.get(\"value\")\n            if raw_value:\n                try:\n                    data = json.loads(raw_value)\n                    if isinstance(data, dict) and data.get(\"url\"):\n                        return data[\"url\"]\n                except (ValueError, TypeError):\n                    pass\n            return raw_text\n\n        parsed_values = {}\n        for cv in column_values:\n            col_id = cv[\"id\"]\n            parsed_values[col_id] = parse_column_value(cv)\n\n        return {"
                    },
                    {
                        "name": "create_contact_in_monday",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_item_by_ID",
                            "create_contact"
                        ],
                        "docstring": "\u2795 Create a contact in Monday and immediately fetch its full item data.\n:param name: Name of the contact\n:return: The newly created contact item",
                        "function_body": "    def create_contact_in_monday(self, name: str) -> dict:\n        \"\"\"\n        \u2795 Create a contact in Monday and immediately fetch its full item data.\n        :param name: Name of the contact\n        :return: The newly created contact item\n        \"\"\"\n        self.logger.info(f\"\u2795 Creating new Monday contact with name='{name}'...\")\n        create_resp = self.create_contact(name)\n        new_id = create_resp[\"data\"][\"create_item\"][\"id\"]\n        self.logger.info(f\"\u2705 Contact created with pulse_id={new_id}. Fetching the new item's data...\")\n        created_item = self.fetch_item_by_ID(new_id)\n        return created_item"
                    },
                    {
                        "name": "sync_db_contact_to_monday",
                        "args": [
                            "self",
                            "db_contact"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item"
                        ],
                        "docstring": "\ud83d\udd04 Syncs local DB contact fields to an existing Monday contact.\n:param db_contact: DB contact object with attributes matching your columns",
                        "function_body": "    def sync_db_contact_to_monday(self, db_contact):\n        \"\"\"\n        \ud83d\udd04 Syncs local DB contact fields to an existing Monday contact.\n        :param db_contact: DB contact object with attributes matching your columns\n        \"\"\"\n        if not db_contact.pulse_id:\n            self.logger.warning(f\"\u26a0\ufe0f DB Contact id={db_contact.id} has no pulse_id. Use 'find_or_create_contact_in_monday' first.\")\n            return\n\n        self.logger.info(f\"\ud83d\udd04 Updating Monday contact (pulse_id={db_contact.pulse_id}) with DB fields...\")\n        column_values = {\n            self.monday_util.CONTACT_PHONE: db_contact.phone or \"\",\n            self.monday_util.CONTACT_EMAIL: db_contact.email or \"\",\n            self.monday_util.CONTACT_ADDRESS_LINE_1: db_contact.address_line_1 or \"\",\n            self.monday_util.CONTACT_ADDRESS_LINE_2: db_contact.address_line_2 or \"\",\n            self.monday_util.CONTACT_CITY: db_contact.city or \"\",\n            self.monday_util.CONTACT_STATE: db_contact.state or \"\",\n            self.monday_util.CONTACT_COUNTRY: db_contact.country or \"\",\n            self.monday_util.CONTACT_REGION: db_contact.region or \"\",\n            self.monday_util.CONTACT_ZIP: db_contact.zip_code or \"\",\n            self.monday_util.CONTACT_TAX_TYPE: db_contact.tax_type or \"\",\n            self.monday_util.CONTACT_TAX_NUMBER: str(db_contact.tax_number) if db_contact.tax_number else \"\",\n            self.monday_util.CONTACT_TAX_FORM_LINK: db_contact.tax_form_link or \"\",\n            self.monday_util.CONTACT_PAYMENT_DETAILS: db_contact.payment_details or \"\",\n            self.monday_util.CONTACT_VENDOR_STATUS: db_contact.vendor_status or \"\",\n        }\n\n        try:"
                    },
                    {
                        "name": "update_monday_tax_form_link",
                        "args": [
                            "self",
                            "pulse_id",
                            "new_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_item"
                        ],
                        "docstring": "\u270f\ufe0f Update the tax_form_link column for a Monday contact, setting an appropriate link text label.",
                        "function_body": "    def update_monday_tax_form_link(self, pulse_id, new_link):\n        \"\"\"\n        \u270f\ufe0f Update the tax_form_link column for a Monday contact, setting an appropriate link text label.\n        \"\"\"\n        if not pulse_id:\n            self.logger.warning(\"\u26a0\ufe0f No pulse_id provided to update Monday link. Aborting update.\")\n            return\n\n        link_lower = new_link.lower()\n        if \"w9\" in link_lower:\n            link_text = \"W-9\"\n        elif \"w8-ben-e\" in link_lower:\n            link_text = \"W-8BEN-E\"\n        elif \"w8-ben\" in link_lower:\n            link_text = \"W-8BEN\"\n        else:\n            link_text = \"Tax Form\"\n\n        link_value = {\"url\": new_link, \"text\": link_text}\n        column_values = json.dumps({self.monday_util.CONTACT_TAX_FORM_LINK: link_value})\n\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "MAX_RETRIES",
                "value": "3"
            },
            {
                "name": "RETRY_BACKOFF_FACTOR",
                "value": "2"
            },
            {
                "name": "monday_api",
                "value": "MondayAPI()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_database_util.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayDatabaseUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "create_or_update_main_item_in_db",
                        "args": [
                            "self",
                            "item_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_purchase_order",
                            "search_purchase_orders",
                            "update_purchase_order"
                        ],
                        "docstring": "Example usage of DatabaseOperations for a main item (PurchaseOrder).",
                        "function_body": "    def create_or_update_main_item_in_db(self, item_data):\n        \"\"\"\n        Example usage of DatabaseOperations for a main item (PurchaseOrder).\n        \"\"\"\n        pulse_id = item_data.get(\"pulse_id\")\n        if not pulse_id:\n            self.logger.warning(\"No pulse_id specified in item_data. Cannot create or update.\")\n            return \"Fail\"\n\n        # Search by pulse_id:\n        existing_pos = self.db_ops.search_purchase_orders([\"pulse_id\"], [pulse_id])\n        if existing_pos:"
                    },
                    {
                        "name": "create_or_update_sub_item_in_db",
                        "args": [
                            "self",
                            "item_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item",
                            "search_detail_items",
                            "create_detail_item"
                        ],
                        "docstring": "Example usage of DatabaseOperations for a subitem (DetailItem).",
                        "function_body": "    def create_or_update_sub_item_in_db(self, item_data):\n        \"\"\"\n        Example usage of DatabaseOperations for a subitem (DetailItem).\n        \"\"\"\n        pulse_id = item_data.get(\"pulse_id\")\n        if not pulse_id:\n            self.logger.warning(\"No pulse_id specified in subitem_data. Cannot create or update.\")\n            return {\"status\": \"Fail\"}\n\n        # Search by pulse_id:\n        existing_sub = self.db_ops.search_detail_items([\"pulse_id\"], [pulse_id])\n        if existing_sub:"
                    },
                    {
                        "name": "get_purchase_order_surrogate_id_by_pulse_id",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders"
                        ],
                        "docstring": "Now uses db_ops.search_purchase_orders to find the PO by pulse_id.",
                        "function_body": "    def get_purchase_order_surrogate_id_by_pulse_id(self, pulse_id):\n        \"\"\"\n        Now uses db_ops.search_purchase_orders to find the PO by pulse_id.\n        \"\"\"\n        found = self.db_ops.search_purchase_orders([\"pulse_id\"], [pulse_id])\n        if not found:\n            return None\n        if isinstance(found, list):\n            found = found[0]\n        return found[\"id\"]  # The PK of PurchaseOrder"
                    },
                    {
                        "name": "get_purchase_order_type_by_pulse_id",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders"
                        ],
                        "docstring": null,
                        "function_body": "    def get_purchase_order_type_by_pulse_id(self, pulse_id):\n        found = self.db_ops.search_purchase_orders([\"pulse_id\"], [pulse_id])\n        if not found:\n            return None\n        if isinstance(found, list):\n            found = found[0]\n        return found.get(\"po_type\")"
                    },
                    {
                        "name": "get_detail_item_by_pulse_id",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items"
                        ],
                        "docstring": null,
                        "function_body": "    def get_detail_item_by_pulse_id(self, pulse_id):\n        found = self.db_ops.search_detail_items([\"pulse_id\"], [pulse_id])\n        if isinstance(found, list) and len(found) > 0:\n            return found[0]\n        return found"
                    },
                    {
                        "name": "update_db_with_sub_item_change",
                        "args": [
                            "self",
                            "change_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item",
                            "search_detail_items"
                        ],
                        "docstring": "Applies a prepared change to a DetailItem.",
                        "function_body": "    def update_db_with_sub_item_change(self, change_item):\n        \"\"\"\n        Applies a prepared change to a DetailItem.\n        \"\"\"\n        pulse_id = change_item.get(\"pulse_id\")\n        db_field = change_item.get(\"db_field\")\n        new_value = change_item.get(\"new_value\")\n\n        if not pulse_id or not db_field:\n            self.logger.error(\"Incomplete change_item data provided.\")\n            return \"Fail\"\n\n        # find the subitem by pulse_id\n        found_sub = self.db_ops.search_detail_items([\"pulse_id\"], [pulse_id])\n        if not found_sub:\n            self.logger.info(f\"No DetailItem found with pulse_id {pulse_id}.\")\n            return \"Not Found\"\n        if isinstance(found_sub, list):\n            found_sub = found_sub[0]\n\n        detail_id = found_sub[\"id\"]\n        updated = self.db_ops.update_detail_item(detail_id, **{db_field: new_value})\n        if updated:\n            self.logger.info(f\"Updated DetailItem {pulse_id}: set {db_field} to {new_value}\")\n            return \"Success\"\n        return \"Fail\""
                    },
                    {
                        "name": "delete_purchase_order_in_db",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "get_db_session",
                            "search_purchase_orders"
                        ],
                        "docstring": "Example: Search the PO by pulse_id, then if found, delete it.",
                        "function_body": "    def delete_purchase_order_in_db(self, pulse_id):\n        \"\"\"\n        Example: Search the PO by pulse_id, then if found, delete it.\n        \"\"\"\n        found_po = self.db_ops.search_purchase_orders([\"pulse_id\"], [pulse_id])\n        if not found_po:\n            self.logger.error(f\"PurchaseOrder with pulse_id {pulse_id} does not exist.\")\n            return False\n        if isinstance(found_po, list):\n            found_po = found_po[0]\n\n        # If you still want to do a direct session delete, you can.\n        # Otherwise, you could add a 'delete_record' method in DatabaseOperations.\n        # For example:\n        from database.db_util import get_db_session\n        from database.models import PurchaseOrder\n        with get_db_session() as session:"
                    },
                    {
                        "name": "delete_detail_item_in_db",
                        "args": [
                            "self",
                            "pulse_id"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items",
                            "get_db_session"
                        ],
                        "docstring": "Example: Search the DetailItem by pulse_id, then delete it if found.",
                        "function_body": "    def delete_detail_item_in_db(self, pulse_id):\n        \"\"\"\n        Example: Search the DetailItem by pulse_id, then delete it if found.\n        \"\"\"\n        found_sub = self.db_ops.search_detail_items([\"pulse_id\"], [pulse_id])\n        if not found_sub:\n            self.logger.error(f\"DetailItem with pulse_id {pulse_id} does not exist.\")\n            return False\n        if isinstance(found_sub, list):\n            found_sub = found_sub[0]\n\n        from database.db_util import get_db_session\n        from database.models import DetailItem\n        with get_db_session() as session:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_database_util",
                "value": "MondayDatabaseUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_service.py",
        "functions": [],
        "classes": [
            {
                "name": "MondayService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n\n        self.database_util = DatabaseOperations()\n\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "_make_request",
                        "args": [
                            "self",
                            "query",
                            "variables"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Internal method to make GraphQL requests to the Monday.com API.\n\nArgs:\n    query (str): The GraphQL query or mutation.\n    variables (dict, optional): Variables for the GraphQL query.\n\nReturns:\n    dict: The JSON response from the API.",
                        "function_body": "    def _make_request(self, query: str, variables: dict = None):\n        \"\"\"\n        Internal method to make GraphQL requests to the Monday.com API.\n\n        Args:\n            query (str): The GraphQL query or mutation.\n            variables (dict, optional): Variables for the GraphQL query.\n\n        Returns:\n            dict: The JSON response from the API.\n        \"\"\"\n        headers = {\"Authorization\": self.api_token}\n        response = requests.post(\n            self.api_url,\n            json={'query': query, 'variables': variables},\n            headers=headers\n        )\n        response.raise_for_status()\n        return response.json()"
                    },
                    {
                        "name": "update_po_status",
                        "args": [
                            "self",
                            "pulse_id",
                            "status"
                        ],
                        "decorators": [],
                        "calls": [
                            "_make_request"
                        ],
                        "docstring": "Update the status of a Purchase Order (PO) in Monday.com.\n\nArgs:\n    pulse_id (int): The ID of the PO item in Monday.com.\n    status (str): The new status label to set.",
                        "function_body": "    def update_po_status(self, pulse_id: int, status: str):\n        \"\"\"\n        Update the status of a Purchase Order (PO) in Monday.com.\n\n        Args:\n            pulse_id (int): The ID of the PO item in Monday.com.\n            status (str): The new status label to set.\n        \"\"\"\n        query = '''\n        mutation ($board_id: Int!, $item_id: Int!, $column_id: String!, $value: JSON!) {\n            change_column_value(\n                board_id: $board_id,\n                item_id: $item_id,\n                column_id: $column_id,\n                value: $value\n            ) {\n                id\n            }\n        }\n        '''\n        variables = {\n            'board_id': int(self.board_id),\n            'item_id': pulse_id,\n            'column_id': self.monday_util.PO_STATUS_COLUMN_ID,\n            'value': json.dumps({'label': status})\n        }\n        try:"
                    },
                    {
                        "name": "match_or_create_contact",
                        "args": [
                            "self",
                            "vendor_name",
                            "po_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_item",
                            "link_contact_to_po"
                        ],
                        "docstring": "Match an existing contact or create a new one for a vendor, then link it to the PO.\n\nArgs:\n    vendor_name (str): The name of the vendor.\n    po_number (str): The PO number to associate with the contact.\n\nReturns:\n    int: The contact ID in Monday.com.",
                        "function_body": "    def match_or_create_contact(self, vendor_name: str, po_number: str) -> int:\n        \"\"\"\n        Match an existing contact or create a new one for a vendor, then link it to the PO.\n\n        Args:\n            vendor_name (str): The name of the vendor.\n            po_number (str): The PO number to associate with the contact.\n\n        Returns:\n            int: The contact ID in Monday.com.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "get_po_number_from_item",
                        "args": [
                            "self",
                            "item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Retrieve the PO number from a specific item in Monday.com.\n\nArgs:\n    item_id (int): The ID of the item to query.\n\nReturns:\n    str: The PO number if found, else None.",
                        "function_body": "    def get_po_number_from_item(self, item_id: int) -> Any | None:\n        \"\"\"\n        Retrieve the PO number from a specific item in Monday.com.\n\n        Args:\n            item_id (int): The ID of the item to query.\n\n        Returns:\n            str: The PO number if found, else None.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "sync_main_items_from_monday_board",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_or_update_main_item_in_db",
                            "fetch_all_items"
                        ],
                        "docstring": "Synchronize all main items (POs) from the Monday.com board to the local database.",
                        "function_body": "    def sync_main_items_from_monday_board(self):\n        \"\"\"\n        Synchronize all main items (POs) from the Monday.com board to the local database.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "sync_sub_items_from_monday_board",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "fetch_all_sub_items",
                            "create_or_update_sub_item_in_db"
                        ],
                        "docstring": "Synchronize all sub-items from the Monday.com board to the local database.\nEach sub-item is associated with a parent item (PO). This function fetches all sub-items,\nprepares them for the database, and updates the database accordingly.",
                        "function_body": "    def sync_sub_items_from_monday_board(self):\n        \"\"\"\n        Synchronize all sub-items from the Monday.com board to the local database.\n        Each sub-item is associated with a parent item (PO). This function fetches all sub-items,\n        prepares them for the database, and updates the database accordingly.\n        \"\"\"\n        try:\n            self.logger.info(f\"Fetching sub-items from board {self.subitem_board_id}...\")\n            all_subitems = self.monday_api.fetch_all_sub_items()\n            self.logger.info(f\"Total sub-items fetched from board {self.subitem_board_id}: {len(all_subitems)}\")\n        except Exception as e:\n            self.logger.error(f\"Error fetching sub-items from Monday.com: {e}\")\n            return\n\n        try:\n            orphan_count = 0\n            for subitem in all_subitems:\n                creation_item = self.db_util.prep_sub_item_event_for_db_creation(subitem)\n                if not creation_item:\n                    orphan_count += 1\n                    self.logger.debug(f\"Skipping sub-item with pulse_id {subitem.get('id')} due to missing parent.\")\n                    continue  # Skip orphan sub-items\n\n                result = self.db_util.create_or_update_sub_item_in_db(creation_item)\n\n                if not result:\n                    self.logger.error(f\"Failed to sync sub-item with pulse_id: {creation_item.get('pulse_id')}\")\n                    continue  # Skip to the next sub-item\n\n                if result.get(\"status\") == \"Orphan\":\n                    orphan_count += 1\n                    self.logger.debug(\n                        f\"Skipped orphan with pulse_id: {creation_item.get('pulse_id')}, \"\n                    )\n                elif result.get(\"status\") == \"Created\":\n                    self.logger.info(\n                        f\"Successfully created sub-item with pulse_id: {creation_item.get('pulse_id')}\")\n                elif result.get(\"status\") == \"Updated\":\n                    self.logger.info(\n                        f\"Successfully updated sub-item with pulse_id: {creation_item.get('pulse_id')}\"\n                    )\n                else:\n                    self.logger.error(\n                        f\"Failed to sync sub-item with pulse_id: {creation_item.get('pulse_id')}. \"\n                        f\"Error: {result.get('error')}\"\n                    )\n        except Exception as e:\n            self.logger.exception(f\"Unexpected error while syncing sub-items to DB: {e}\")\n        self.logger.info(\"Sub-items synchronization completed successfully.\")\n        self.logger.info(f\"Skipped {orphan_count} orphans out of {len(all_subitems)} sub-items\")"
                    },
                    {
                        "name": "sync_contacts_from_monday_board",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [
                            "parse_tax_number",
                            "create_contact",
                            "fetch_all_contacts",
                            "extract_monday_contact_fields",
                            "update_contact"
                        ],
                        "docstring": "Synchronize all contacts from the Monday.com board to the local database.",
                        "function_body": "    def sync_contacts_from_monday_board(self):\n        \"\"\"\n        Synchronize all contacts from the Monday.com board to the local database.\n        \"\"\"\n        try:\n            self.logger.info(f\"Fetching contacts from board {self.contact_board_id}...\")\n            all_contacts = self.monday_api.fetch_all_contacts()\n            self.logger.info(f\"Total contacts fetched from board {self.contact_board_id}: {len(all_contacts)}\")\n        except Exception as e:\n            self.logger.error(f\"Error fetching contacts from Monday.com: {e}\")\n            return\n\n        try:\n            for contact in all_contacts:\n                monday_fields = self.monday_api.extract_monday_contact_fields(contact)\n\n                # Parse tax_number if any\n                tax_number_int = None\n\n                if monday_fields[\"tax_number_str\"]:\n                    tax_number_int = self.database_util.parse_tax_number(monday_fields[\"tax_number_str\"])\n\n                # Only accept vendor_status if it's in the allowed set\n                vendor_status = monday_fields[\"vendor_status\"]\n\n                if vendor_status not in [\"PENDING\", \"TO VERIFY\", \"APPROVED\", \"ISSUE\"]:\n                    vendor_status = \"PENDING\"\n\n                # Now do the DB update \u2014 use contact_id, since db_contact is a dict\n                try:\n                    existing_contact = self.database_util.find_contact_by_name(contact_name=contact[\"name\"])\n\n                    if not existing_contact:\n                        db_contact = self.database_util.create_contact(\n                            name=contact[\"name\"],\n                            pulse_id=monday_fields[\"pulse_id\"],\n                            phone=monday_fields[\"phone\"],\n                            email=monday_fields[\"email\"],\n                            address_line_1=monday_fields[\"address_line_1\"],\n                            address_line_2=monday_fields[\"address_line_2\"],\n                            city=monday_fields[\"city\"],\n                            zip=monday_fields[\"zip_code\"],\n                            region=monday_fields[\"region\"],\n                            country=monday_fields[\"country\"],\n                            tax_type=monday_fields[\"tax_type\"],\n                            tax_number=tax_number_int,\n                            payment_details=monday_fields[\"payment_details\"],\n                            vendor_status=vendor_status,\n                            tax_form_link=monday_fields[\"tax_form_link\"]\n                        )\n                    else:\n                        db_contact = self.database_util.update_contact(\n                            contact_id=existing_contact[\"id\"],\n                            name=contact[\"name\"],\n                            pulse_id=monday_fields[\"pulse_id\"],\n                            phone=monday_fields[\"phone\"],\n                            email=monday_fields[\"email\"],\n                            address_line_1=monday_fields[\"address_line_1\"],\n                            address_line_2=monday_fields[\"address_line_2\"],\n                            city=monday_fields[\"city\"],\n                            zip=monday_fields[\"zip_code\"],\n                            region=monday_fields[\"region\"],\n                            country=monday_fields[\"country\"],\n                            tax_type=monday_fields[\"tax_type\"],\n                            tax_number=tax_number_int,\n                            payment_details=monday_fields[\"payment_details\"],\n                            vendor_status=vendor_status,\n                            tax_form_link=monday_fields[\"tax_form_link\"]\n                        )\n                    self.logger.info(f\"Synced {contact['name']}\")\n                except Exception as e:\n                    self.logger.error(f\"Error adding contact to DB: {e}\")\n        except Exception as e:\n            self.logger.error(f\"Error syncing contacts to DB: {e}\")\n        self.logger.info(\"Contacts synchronization completed successfully.\")"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_service",
                "value": "MondayService()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_monday/monday_webhook_handler.py",
        "functions": [
            {
                "name": "po_status_change",
                "args": [],
                "decorators": [
                    "monday_blueprint.route('/po_status_change')"
                ],
                "calls": [
                    "process_po_status_change",
                    "verify_challenge"
                ],
                "docstring": "Endpoint to handle PO status change events from Monday.com.",
                "function_body": "def po_status_change():\n    \"\"\"\n    Endpoint to handle PO status change events from Monday.com.\n    \"\"\"\n    logger.debug(\"PO status change event received\")\n    event = request.get_json()\n    if not event:\n        return jsonify({\"error\": \"Invalid event data\"}), 400\n\n    # Handle the challenge verification\n    challenge_response = monday_webhook_handler.verify_challenge(event)\n    if challenge_response:"
            },
            {
                "name": "subitem_change",
                "args": [],
                "decorators": [
                    "monday_blueprint.route('/subitem_change')"
                ],
                "calls": [
                    "verify_challenge",
                    "process_sub_item_change"
                ],
                "docstring": "Endpoint to handle SubItem change events from Monday.com.",
                "function_body": "def subitem_change():\n    \"\"\"\n    Endpoint to handle SubItem change events from Monday.com.\n    \"\"\"\n    logger.debug(\"SubItem change event received\")\n    event = request.get_json()\n    if not event:\n        return jsonify({\"error\": \"Invalid event data\"}), 400\n\n    # Handle the challenge verification\n    challenge_response = monday_webhook_handler.verify_challenge(event)\n    if challenge_response:"
            },
            {
                "name": "subitem_delete",
                "args": [],
                "decorators": [
                    "monday_blueprint.route('/subitem_delete')"
                ],
                "calls": [
                    "process_sub_item_delete",
                    "verify_challenge"
                ],
                "docstring": "Endpoint to handle SubItem deletion events from Monday.com.",
                "function_body": "def subitem_delete():\n    \"\"\"\n    Endpoint to handle SubItem deletion events from Monday.com.\n    \"\"\"\n    logger.debug(\"SubItem delete event received\")\n    event = request.get_json()\n\n    if not event:\n        return jsonify({\"error\": \"Invalid event data\"}), 400\n\n    # Handle the challenge verification\n    challenge_response = monday_webhook_handler.verify_challenge(event)\n    if challenge_response:"
            }
        ],
        "classes": [
            {
                "name": "MondayWebhookHandler",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "verify_challenge",
                        "args": [
                            "event"
                        ],
                        "decorators": [
                            "staticmethod"
                        ],
                        "calls": [],
                        "docstring": "Verify if the event contains a challenge and respond accordingly.\n\nArgs:\n    event (dict): The event data received from Monday.com.\n\nReturns:\n    Response object if challenge is present, otherwise None.",
                        "function_body": "    def verify_challenge(event):\n        \"\"\"\n        Verify if the event contains a challenge and respond accordingly.\n\n        Args:\n            event (dict): The event data received from Monday.com.\n\n        Returns:\n            Response object if challenge is present, otherwise None.\n        \"\"\"\n        challenge = event.get('challenge')\n        if challenge:\n            return jsonify({'challenge': challenge}), 200\n        return None"
                    },
                    {
                        "name": "process_po_status_change",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Process purchase order (PO) status change events from Monday.com.\n\nArgs:\n    event_data (dict): The event data containing PO status change information.\n\nReturns:\n    JSON response indicating success or error.",
                        "function_body": "    def process_po_status_change(self, event_data):\n        \"\"\"\n        Process purchase order (PO) status change events from Monday.com.\n\n        Args:\n            event_data (dict): The event data containing PO status change information.\n\n        Returns:\n            JSON response indicating success or error.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "process_sub_item_change",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "create_or_update_sub_item_in_db",
                            "create_or_update_main_item_in_db",
                            "get_purchase_order_surrogate_id_by_pulse_id",
                            "fetch_item_by_ID",
                            "update_db_with_sub_item_change"
                        ],
                        "docstring": "Process SubItem change events from Monday.com and update the local DetailItem table.\n\nArgs:\n    event_data (dict): The event data containing SubItem change information.\n\nReturns:\n    JSON response indicating success or error.",
                        "function_body": "    def process_sub_item_change(self, event_data):\n        \"\"\"\n        Process SubItem change events from Monday.com and update the local DetailItem table.\n\n        Args:\n            event_data (dict): The event data containing SubItem change information.\n\n        Returns:\n            JSON response indicating success or error.\n        \"\"\"\n        try:"
                    },
                    {
                        "name": "process_sub_item_delete",
                        "args": [
                            "self",
                            "event_data"
                        ],
                        "decorators": [],
                        "calls": [
                            "delete_detail_item_in_db"
                        ],
                        "docstring": "Process SubItem deletion events from Monday.com and remove the item from the local database.\n\nArgs:\n    event_data (dict): The event data containing SubItem deletion information.\n\nReturns:\n    JSON response indicating success or error.",
                        "function_body": "    def process_sub_item_delete(self, event_data):\n        \"\"\"\n        Process SubItem deletion events from Monday.com and remove the item from the local database.\n\n        Args:\n            event_data (dict): The event data containing SubItem deletion information.\n\n        Returns:\n            JSON response indicating success or error.\n        \"\"\"\n        return jsonify({\"message\": \"SubItem deleted successfully\"}), 200\n        try:"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "monday_blueprint",
                "value": "Blueprint('files_monday', __name__)"
            },
            {
                "name": "monday_webhook_handler",
                "value": "MondayWebhookHandler()"
            },
            {
                "name": "logger",
                "value": "logging.getLogger('monday_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/webhook_main.py",
        "functions": [
            {
                "name": "account_tax_view",
                "args": [],
                "decorators": [
                    "app.route('/account_tax_view')"
                ],
                "calls": [],
                "docstring": "Shows an Excel-like table to edit accountCodes + TaxAccounts together.\nAccepts optional ?sort=account_code or ?sort=tax_code",
                "function_body": "def account_tax_view():\n    \"\"\"\n    Shows an Excel-like table to edit accountCodes + TaxAccounts together.\n    Accepts optional ?sort=account_code or ?sort=tax_code\n    \"\"\"\n    sort = request.args.get(\"sort\")\n    # 3) Use our new method to fetch joined data\n    records = db_view_util.get_all_account_with_tax(sort_by=sort)\n    return render_template(\"map_codes_view.html\", records=records, sort=sort)"
            },
            {
                "name": "bulk_update_account_tax",
                "args": [],
                "decorators": [
                    "app.route('/bulk_update_account_tax')"
                ],
                "calls": [
                    "bulk_update_account_tax"
                ],
                "docstring": "Accepts JSON data from the front-end with a list of updated rows.\nCalls the new method in DatabaseViewUtil to commit changes to DB.",
                "function_body": "def bulk_update_account_tax():\n    \"\"\"\n    Accepts JSON data from the front-end with a list of updated rows.\n    Calls the new method in DatabaseViewUtil to commit changes to DB.\n    \"\"\"\n    data = request.get_json()\n    if not data or not isinstance(data, list):\n        return jsonify({\"status\": \"error\", \"message\": \"Invalid input data\"}), 400\n\n    try:"
            },
            {
                "name": "index",
                "args": [],
                "decorators": [
                    "app.route('/health')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def index():\n    return jsonify({\"message\": \"Webhook listener is running.\"}), 200"
            },
            {
                "name": "get_po_data",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "app.route('/po/<string:po_id>')"
                ],
                "calls": [
                    "fetch_item_by_po_and_project"
                ],
                "docstring": null,
                "function_body": "def get_po_data(po_id):\n    # Split the PO ID into project ID and PO number\n    try:\n        project_id, po_number = po_id.split('_')\n        logger.info(project_id, po_number)\n    except ValueError:\n        return {\"error\": \"Invalid PO ID format. Expected format: '2416_04'\"}, 400\n\n    # Call your function with the extracted values\n    result = monday_api.fetch_item_by_po_and_project(project_id, po_number)\n    try:\n        json_result = jsonify(result)\n    except Exception as e:\n        logger.error(e)\n        raise\n    return  json_result"
            },
            {
                "name": "po_html",
                "args": [
                    "project_ID"
                ],
                "decorators": [
                    "app.route('/po_html/<string:project_ID>')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def po_html(project_ID):\n    logger.info(project_ID)\n    result = po_log_database_util.fetch_po_by_id(project_ID)  # Now returns PO data with detail items\n    json_result = result.get_json()  # Extract the JSON data (as a dict/list)\n\n    return render_template('po_template.html', data=json_result)"
            },
            {
                "name": "control_panel",
                "args": [],
                "decorators": [
                    "app.route('/control_panel')"
                ],
                "calls": [],
                "docstring": "Renders the Control Panel HTML page.",
                "function_body": "def control_panel():\n    \"\"\"\n    Renders the Control Panel HTML page.\n    \"\"\"\n    return render_template(\"control_panel.html\")"
            },
            {
                "name": "toggle_temp_file",
                "args": [],
                "decorators": [
                    "app.route('/toggle_temp_file')"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def toggle_temp_file():\n    current_value = dropbox_service.USE_TEMP_FILE\n    new_value = not current_value\n    dropbox_service.USE_TEMP_FILE = new_value\n    logger.info(f\"USE_TEMP_FILE toggled from {current_value} to {new_value}\")\n    return redirect(url_for(\"control_panel\"))"
            },
            {
                "name": "trigger_function",
                "args": [],
                "decorators": [
                    "app.route('/trigger_function')"
                ],
                "calls": [
                    "scan_project_receipts"
                ],
                "docstring": "Triggers the requested function in the Orchestrator based odn form input.",
                "function_body": "def trigger_function():\n    \"\"\"\n    Triggers the requested function in the Orchestrator based odn form input.\n    \"\"\"\n    logger = logging.getLogger(\"admin_logger\")\n    function_name = request.form.get(\"function_name\", \"\")\n    project_number = request.form.get(\"project_number\", \"\")  # This is optional\n\n    try:\n        if function_name == \"schedule_monday_main_items_sync\":\n            orchestrator.sync_monday_main_items()\n            logger.info(\"Scheduled monday_main_items_sync\")\n        elif function_name == \"schedule_monday_sub_items_sync\":\n            orchestrator.sync_monday_sub_items()\n            logger.info(\"Scheduled monday_sub_items_sync\")\n        elif function_name == \"scan_project_receipts\":\n            # Make sure the user actually gave us a project_number\n            if not project_number:\n                logger.warning(\"No project number provided for scanning receipts.\")\n            else:\n                orchestrator.scan_project_receipts(project_number)\n        elif function_name == \"scan_project_invoice\":\n            # Make sure the user actually gave us a project_number\n            if not project_number:\n                logger.warning(\"No project number provided for scanning receipts.\")\n            else:\n                orchestrator.scan_project_invoices(project_number)\n        elif function_name == \"schedule_monday_contact_sync\":\n            orchestrator.sync_monday_contacts()\n            logger.info(\"Scheduled monday_contact_sync\")\n        elif function_name == \"sync_spend_money_items\":\n            orchestrator.sync_spend_money_items()\n            logger.info(\"Called sync_spend_money_items\")\n        elif function_name == \"sync_contacts\":\n            orchestrator.sync_contacts()\n            logger.info(\"Called sync_contacts\")\n        elif function_name == \"sync_xero_bills\":\n            orchestrator.sync_xero_bills()\n            logger.info(\"Called sync_xero_bills\")\n        else:\n            logger.error(f\"Unknown function requested: {function_name}\")\n    except Exception as e:\n        logger.error(f\"Error triggering function {function_name}: {e}\")\n\n    # Redirect back to the control panel (or wherever you'd like)\n    return redirect(url_for(\"control_panel\"))"
            },
            {
                "name": "map_codes_view",
                "args": [],
                "decorators": [
                    "app.route('/map_codes_view')"
                ],
                "calls": [],
                "docstring": "New approach: Renders a template with tabs for each map_code,\neach containing the two-panel (Account left / Tax right) layout,\nlocal storage logic, pagination, etc.",
                "function_body": "def map_codes_view():\n    \"\"\"\n    New approach: Renders a template with tabs for each map_code,\n    each containing the two-panel (Account left / Tax right) layout,\n    local storage logic, pagination, etc.\n    \"\"\"\n    return render_template(\"map_codes_view.html\")"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "app",
                "value": "Flask(__name__)"
            },
            {
                "name": "orchestrator",
                "value": "Orchestrator()"
            },
            {
                "name": "logger",
                "value": "logging.getLogger(__name__)"
            },
            {
                "name": "db_view_util",
                "value": "DatabaseViewUtil()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/main.py",
        "functions": [
            {
                "name": "run_flask_app",
                "args": [],
                "decorators": [],
                "calls": [
                    "setup_logging"
                ],
                "docstring": "Function to run the Flask app.",
                "function_body": "def run_flask_app():\n    \"\"\"Function to run the Flask app.\"\"\"\n    setup_logging()  # This sets up the 7 loggers + file + console\n    logger = logging.getLogger(\"webhook_main\")\n    logger.info(\"Starting Flask server for webhooks...\")\n\n    # Enable template auto-reloading\n    app.config['TEMPLATES_AUTO_RELOAD'] = config.APP_DEBUG\n\n    # Optionally set debugging mode for easier development\n    app.debug = config.APP_DEBUG\n\n    # Initialize and start the server\n    server = make_server('0.0.0.0', Config.WEBHOOK_MAIN_PORT, app)\n    try:"
            },
            {
                "name": "main",
                "args": [],
                "decorators": [],
                "calls": [
                    "initialize_database"
                ],
                "docstring": null,
                "function_body": "def main():\n    # Setup logging and get the configured logger\n    logger = logging.getLogger(\"admin_logger\")\n\n    # Initialize the database\n    config = Config()\n\n    db_settings = config.get_database_settings(config.USE_LOCAL)\n    initialize_database(db_settings['url'])\n    logger.info(\"Database initialized.\")\n\n    # Initialize the orchestrator\n    orchestrator = Orchestrator()\n    logger.info(\"Orchestrator initialized.\")\n\n    # Start background tasks such as PO Log checking and state coordination\n    orchestrator.start_background_tasks()\n\n    # Start webhook server in a thread\n    flask_thread = threading.Thread(target=run_flask_app)\n    flask_thread.start()\n\n    # Keep the main thread alive\n    try:"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "config",
                "value": "Config()"
            },
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_webhook/logging_setup.py",
        "functions": [
            {
                "name": "setup_logging",
                "args": [],
                "decorators": [],
                "calls": [],
                "docstring": "Create loggers for each module: budget, dropbox, invoice, monday, po_log, xero, database.\nEach logger writes to a separate file in ./logs, plus a StreamHandler for the console.",
                "function_body": "def setup_logging():\n    \"\"\"\n    Create loggers for each module: budget, dropbox, invoice, monday, po_log, xero, database.\n    Each logger writes to a separate file in ./logs, plus a StreamHandler for the console.\n    \"\"\"\n    # Ensure the logs folder exists\n    os.makedirs(\"./logs\", exist_ok=True)\n    folder_name = \"server_webhook\"\n\n    basepath = \"./\" + folder_name + \"/logs/\"\n    # Common log format\n    log_format = \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\"\n    formatter = logging.Formatter(log_format)\n\n    # StreamHandler for console (all logs)\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    \n    # ---------------------------------------------------------\n    #  Logger for admin\n    # ---------------------------------------------------------\n    admin_logger = logging.getLogger(\"admin_logger\")\n    admin_logger.setLevel(logging.DEBUG)\n    file_handler_admin = logging.FileHandler(basepath + \"admin.log\")\n    file_handler_admin.setFormatter(formatter)\n    admin_logger.addHandler(file_handler_admin)\n    admin_logger.addHandler(console_handler)\n    admin_logger.propagate = False\n    \n    # ---------------------------------------------------------\n    #  Logger for budget\n    # ---------------------------------------------------------\n    budget_logger = logging.getLogger(\"budget_logger\")\n    budget_logger.setLevel(logging.DEBUG)\n    file_handler_budget = logging.FileHandler(basepath + \"budget.log\")\n    file_handler_budget.setFormatter(formatter)\n    budget_logger.addHandler(file_handler_budget)\n    budget_logger.addHandler(console_handler)\n    budget_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for dropbox\n    # ---------------------------------------------------------\n    dropbox_logger = logging.getLogger(\"dropbox_logger\")\n    dropbox_logger.setLevel(logging.DEBUG)\n    file_handler_dropbox = logging.FileHandler(basepath + \"dropbox.log\")\n    file_handler_dropbox.setFormatter(formatter)\n    dropbox_logger.addHandler(file_handler_dropbox)\n    dropbox_logger.addHandler(console_handler)\n    dropbox_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for invoice\n    # ---------------------------------------------------------\n    invoice_logger = logging.getLogger(\"invoice_logger\")\n    invoice_logger.setLevel(logging.DEBUG)\n    file_handler_invoice = logging.FileHandler(basepath + \"invoice.log\")\n    file_handler_invoice.setFormatter(formatter)\n    invoice_logger.addHandler(file_handler_invoice)\n    invoice_logger.addHandler(console_handler)\n    invoice_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for monday\n    # ---------------------------------------------------------\n    monday_logger = logging.getLogger(\"monday_logger\")\n    monday_logger.setLevel(logging.DEBUG)\n    file_handler_monday = logging.FileHandler(basepath + \"monday.log\")\n    file_handler_monday.setFormatter(formatter)\n    monday_logger.addHandler(file_handler_monday)\n    monday_logger.addHandler(console_handler)\n    monday_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for po_log\n    # ---------------------------------------------------------\n    po_log_logger = logging.getLogger(\"po_log_logger\")\n    po_log_logger.setLevel(logging.DEBUG)\n    file_handler_po = logging.FileHandler(basepath + \"po_log.log\")\n    file_handler_po.setFormatter(formatter)\n    po_log_logger.addHandler(file_handler_po)\n    po_log_logger.addHandler(console_handler)\n    po_log_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for xero\n    # ---------------------------------------------------------\n    xero_logger = logging.getLogger(\"xero_logger\")\n    xero_logger.setLevel(logging.DEBUG)\n    file_handler_xero = logging.FileHandler(basepath + \"xero.log\")\n    file_handler_xero.setFormatter(formatter)\n    xero_logger.addHandler(file_handler_xero)\n    xero_logger.addHandler(console_handler)\n    xero_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for database\n    # ---------------------------------------------------------\n    db_logger = logging.getLogger(\"database_logger\")\n    db_logger.setLevel(logging.DEBUG)\n    file_handler_db = logging.FileHandler(basepath + \"database.log\")\n    file_handler_db.setFormatter(formatter)\n    db_logger.addHandler(file_handler_db)\n    db_logger.addHandler(console_handler)\n    db_logger.propagate = False\n\n    # Optional: set root logger if you want\n    logging.basicConfig(level=logging.INFO)"
            }
        ],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/database_trigger_service.py",
        "functions": [],
        "classes": [
            {
                "name": "DatabaseTriggerService",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        self.logger = logging.getLogger(\"database_logger\")"
                    },
                    {
                        "name": "bill_line_item_trigger_on_create",
                        "args": [
                            "self",
                            "bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def bill_line_item_trigger_on_create(self, bill_line_item_id: int):\n        return handle_xero_bill_line_item_create(bill_line_item_id)"
                    },
                    {
                        "name": "bill_line_item_trigger_on_update",
                        "args": [
                            "self",
                            "bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def bill_line_item_trigger_on_update(self, bill_line_item_id: int):\n        return handle_xero_bill_line_item_update(bill_line_item_id)"
                    },
                    {
                        "name": "bill_line_item_trigger_on_delete",
                        "args": [
                            "self",
                            "bill_line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def bill_line_item_trigger_on_delete(self, bill_line_item_id: int):\n        return handle_xero_bill_line_item_delete(bill_line_item_id)"
                    },
                    {
                        "name": "spend_money_trigger_on_create",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def spend_money_trigger_on_create(self, spend_money_id: int):\n        return handle_spend_money_create(spend_money_id)"
                    },
                    {
                        "name": "spend_money_trigger_on_update",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def spend_money_trigger_on_update(self, spend_money_id: int):\n        return handle_spend_money_update(spend_money_id)"
                    },
                    {
                        "name": "spend_money_trigger_on_delete",
                        "args": [
                            "self",
                            "spend_money_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def spend_money_trigger_on_delete(self, spend_money_id: int):\n        return handle_spend_money_delete(spend_money_id)"
                    },
                    {
                        "name": "create_xero_bill_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def create_xero_bill_trigger(self, bill_id: int):\n        return handle_xero_bill_create(bill_id)"
                    },
                    {
                        "name": "update_xero_bill_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def update_xero_bill_trigger(self, bill_id: int):\n        return handle_xero_bill_update(bill_id)"
                    },
                    {
                        "name": "delete_xero_bill_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def delete_xero_bill_trigger(self, bill_id: int):\n        return handle_xero_bill_delete(bill_id)"
                    },
                    {
                        "name": "create_xero_bill_line_items_trigger",
                        "args": [
                            "self",
                            "bill_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def create_xero_bill_line_items_trigger(self, bill_id: int):\n        return handle_xero_bill_line_item_create(bill_id)"
                    },
                    {
                        "name": "update_xero_bill_line_item_trigger",
                        "args": [
                            "self",
                            "line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def update_xero_bill_line_item_trigger(self, line_item_id: int):\n        return handle_xero_bill_line_item_update(line_item_id)"
                    },
                    {
                        "name": "delete_xero_bill_line_item_trigger",
                        "args": [
                            "self",
                            "line_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def delete_xero_bill_line_item_trigger(self, line_item_id: int):\n        return handle_xero_bill_line_item_delete(line_item_id)"
                    },
                    {
                        "name": "project_trigger_on_create",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def project_trigger_on_create(self, project_id: int):\n        return handle_project_create(project_id)"
                    },
                    {
                        "name": "project_trigger_on_update",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def project_trigger_on_update(self, project_id: int):\n        return handle_project_update(project_id)"
                    },
                    {
                        "name": "project_trigger_on_delete",
                        "args": [
                            "self",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def project_trigger_on_delete(self, project_id: int):\n        return handle_project_delete(project_id)"
                    },
                    {
                        "name": "purchase_order_trigger_on_create",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def purchase_order_trigger_on_create(self, po_id: int):\n        return handle_purchase_order_create(po_id)"
                    },
                    {
                        "name": "purchase_order_trigger_on_update",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def purchase_order_trigger_on_update(self, po_id: int):\n        return handle_purchase_order_update(po_id)"
                    },
                    {
                        "name": "purchase_order_trigger_on_delete",
                        "args": [
                            "self",
                            "po_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def purchase_order_trigger_on_delete(self, po_id: int):\n        return handle_purchase_order_delete(po_id)"
                    },
                    {
                        "name": "detail_item_trigger_on_create",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def detail_item_trigger_on_create(self, detail_item_id: int):\n        return handle_detail_item_create(detail_item_id)"
                    },
                    {
                        "name": "detail_item_trigger_on_update",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def detail_item_trigger_on_update(self, detail_item_id: int):\n        return handle_detail_item_update(detail_item_id)"
                    },
                    {
                        "name": "detail_item_on_delete",
                        "args": [
                            "self",
                            "detail_item_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def detail_item_on_delete(self, detail_item_id: int):\n        return handle_detail_item_delete(detail_item_id)"
                    },
                    {
                        "name": "invoice_trigger_on_create_or_update",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def invoice_trigger_on_create_or_update(self, invoice_id: int):\n        return handle_invoice_create_or_update(invoice_id)"
                    },
                    {
                        "name": "invoice_trigger_on_delete",
                        "args": [
                            "self",
                            "invoice_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def invoice_trigger_on_delete(self, invoice_id: int):\n        return handle_invoice_delete(invoice_id)"
                    },
                    {
                        "name": "receipt_trigger_on_create",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def receipt_trigger_on_create(self, receipt_id: int):\n        return handle_receipt_create(receipt_id)"
                    },
                    {
                        "name": "receipt_trigger_on_update",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def receipt_trigger_on_update(self, receipt_id: int):\n        return handle_receipt_update(receipt_id)"
                    },
                    {
                        "name": "receipt_trigger_on_delete",
                        "args": [
                            "self",
                            "receipt_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def receipt_trigger_on_delete(self, receipt_id: int):\n        return handle_receipt_delete(receipt_id)"
                    },
                    {
                        "name": "contact_trigger_on_create",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def contact_trigger_on_create(self, contact_id: int):\n        return handle_contact_create(contact_id)"
                    },
                    {
                        "name": "contact_trigger_on_update",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def contact_trigger_on_update(self, contact_id: int):\n        return handle_contact_update(contact_id)"
                    },
                    {
                        "name": "contact_trigger_on_delete",
                        "args": [
                            "self",
                            "contact_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def contact_trigger_on_delete(self, contact_id: int):\n        return handle_contact_delete(contact_id)"
                    },
                    {
                        "name": "tax_account_trigger_on_create",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def tax_account_trigger_on_create(self, tax_account_id: int):\n        return handle_tax_account_create(tax_account_id)"
                    },
                    {
                        "name": "tax_account_trigger_on_update",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def tax_account_trigger_on_update(self, tax_account_id: int):\n        return handle_tax_account_update(tax_account_id)"
                    },
                    {
                        "name": "tax_account_trigger_on_delete",
                        "args": [
                            "self",
                            "tax_account_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def tax_account_trigger_on_delete(self, tax_account_id: int):\n        return handle_tax_account_delete(tax_account_id)"
                    },
                    {
                        "name": "account_code_trigger_on_create",
                        "args": [
                            "self",
                            "account_code_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def account_code_trigger_on_create(self, account_code_id: int):\n        return handle_account_code_create(account_code_id)"
                    },
                    {
                        "name": "account_code_trigger_on_update",
                        "args": [
                            "self",
                            "account_code_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def account_code_trigger_on_update(self, account_code_id: int):\n        return handle_account_code_update(account_code_id)"
                    },
                    {
                        "name": "account_code_trigger_on_delete",
                        "args": [
                            "self",
                            "account_code_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def account_code_trigger_on_delete(self, account_code_id: int):\n        return handle_account_code_delete(account_code_id)"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "database_trigger_service",
                "value": "DatabaseTriggerService()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/celery_server.py",
        "functions": [
            {
                "name": "announce_tasks",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "celery_app.on_after_finalize.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def announce_tasks(sender, **kwargs):\n    logger.info(\"Celery tasks have been finalized. Ready to go!\")"
            },
            {
                "name": "init_db",
                "args": [],
                "decorators": [
                    "worker_init.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def init_db(**kwargs):\n    logger.info(\"Initializing DB inside Celery worker...\")"
            },
            {
                "name": "signal_worker_init",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "worker_init.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def signal_worker_init(sender=None, **kwargs):\n    logger.info(\"\ud83d\udc77\u200d\u2640\ufe0f Celery Worker is starting up... Warm up the engines!\")"
            },
            {
                "name": "signal_worker_ready",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "worker_ready.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def signal_worker_ready(sender=None, **kwargs):\n    logger.info(\"\ud83d\ude80 Celery Worker is READY and waiting for tasks! Buckle up, folks.\")"
            },
            {
                "name": "signal_worker_shutdown",
                "args": [
                    "sender"
                ],
                "decorators": [
                    "worker_shutdown.connect"
                ],
                "calls": [],
                "docstring": null,
                "function_body": "def signal_worker_shutdown(sender=None, **kwargs):\n    logger.warning(\"\ud83d\uded1 Celery Worker is shutting down. Everyone, please exit in an orderly fashion.\")"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            },
            {
                "name": "celery_app",
                "value": "Celery('celery_app', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/celery_tasks.py",
        "functions": [
            {
                "name": "process_invoice_trigger",
                "args": [
                    "invoice_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "invoice_trigger_on_create_or_update"
                ],
                "docstring": "The Celery task for handling invoice creates/updates.",
                "function_body": "def process_invoice_trigger(invoice_id: int):\n    \"\"\"\n    The Celery task for handling invoice creates/updates.\n    \"\"\"\n    logger.info(f\"\ud83d\ude80 Starting process_invoice_trigger shared task. invoice_id={invoice_id}.\")\n    try:"
            },
            {
                "name": "process_invoice_delete",
                "args": [
                    "invoice_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "invoice_trigger_on_delete"
                ],
                "docstring": "The Celery task for handling invoice deletes.",
                "function_body": "def process_invoice_delete(invoice_id: int):\n    \"\"\"\n    The Celery task for handling invoice deletes.\n    \"\"\"\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling invoice deletion for invoice_id={invoice_id}.\")\n    try:"
            },
            {
                "name": "process_detail_item_update",
                "args": [
                    "detail_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "detail_item_trigger_on_update"
                ],
                "docstring": "The Celery task for detail items that just turned RTP (or updated).",
                "function_body": "def process_detail_item_update(detail_item_id: int):\n    \"\"\"\n    The Celery task for detail items that just turned RTP (or updated).\n    \"\"\"\n    logger.info(f\"\ud83c\udf00 Handling updated detail item for detail_item_id={detail_item_id}\")\n    try:"
            },
            {
                "name": "process_detail_item_create",
                "args": [
                    "detail_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "detail_item_trigger_on_create"
                ],
                "docstring": "The Celery task for newly created detail items.",
                "function_body": "def process_detail_item_create(detail_item_id: int):\n    \"\"\"\n    The Celery task for newly created detail items.\n    \"\"\"\n    logger.info(f\"\ud83c\udf00 Handling created detail item for detail_item_id={detail_item_id}\")\n    try:"
            },
            {
                "name": "process_detail_item_delete",
                "args": [
                    "detail_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "detail_item_on_delete"
                ],
                "docstring": "The Celery task for deleted detail items.",
                "function_body": "def process_detail_item_delete(detail_item_id: int):\n    \"\"\"\n    The Celery task for deleted detail items.\n    \"\"\"\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted detail item for detail_item_id={detail_item_id}\")\n    try:"
            },
            {
                "name": "process_purchase_order_create",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "purchase_order_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_purchase_order_create(po_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_purchase_order_create shared task. po_id={po_id}.\")\n    try:"
            },
            {
                "name": "process_purchase_order_update",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "purchase_order_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_purchase_order_update(po_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated PurchaseOrder id={po_id}.\")\n    try:"
            },
            {
                "name": "process_purchase_order_delete",
                "args": [
                    "po_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "purchase_order_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_purchase_order_delete(po_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted PurchaseOrder id={po_id}.\")\n    try:"
            },
            {
                "name": "process_contact_create",
                "args": [
                    "contact_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "contact_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_contact_create(contact_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_contact_create shared task. contact_id={contact_id}.\")\n    try:"
            },
            {
                "name": "process_contact_update",
                "args": [
                    "contact_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "contact_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_contact_update(contact_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated Contact id={contact_id}.\")\n    try:"
            },
            {
                "name": "process_contact_delete",
                "args": [
                    "contact_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "contact_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_contact_delete(contact_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted Contact id={contact_id}.\")\n    try:"
            },
            {
                "name": "process_bill_line_item_create",
                "args": [
                    "bill_line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "bill_line_item_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_bill_line_item_create(bill_line_item_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_bill_line_item_create shared task. bill_line_item_id={bill_line_item_id}.\")\n    try:"
            },
            {
                "name": "process_bill_line_item_update",
                "args": [
                    "bill_line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "bill_line_item_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_bill_line_item_update(bill_line_item_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated BillLineItem id={bill_line_item_id}.\")\n    try:"
            },
            {
                "name": "process_bill_line_item_delete",
                "args": [
                    "bill_line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "bill_line_item_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_bill_line_item_delete(bill_line_item_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted BillLineItem id={bill_line_item_id}.\")\n    try:"
            },
            {
                "name": "process_bank_transaction_create",
                "args": [
                    "bank_tx_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database"
                ],
                "docstring": null,
                "function_body": "def process_bank_transaction_create(bank_tx_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_bank_transaction_create shared task. bank_tx_id={bank_tx_id}.\")\n    try:"
            },
            {
                "name": "process_bank_transaction_update",
                "args": [
                    "bank_tx_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database"
                ],
                "docstring": null,
                "function_body": "def process_bank_transaction_update(bank_tx_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated BankTransaction id={bank_tx_id}.\")\n    try:"
            },
            {
                "name": "process_bank_transaction_delete",
                "args": [
                    "bank_tx_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database"
                ],
                "docstring": null,
                "function_body": "def process_bank_transaction_delete(bank_tx_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted BankTransaction id={bank_tx_id}.\")\n    try:"
            },
            {
                "name": "process_account_code_create",
                "args": [
                    "account_code_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "account_code_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_account_code_create(account_code_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_account_code_create shared task. account_code_id={account_code_id}.\")\n    try:"
            },
            {
                "name": "process_account_code_update",
                "args": [
                    "account_code_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "account_code_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_account_code_update(account_code_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated AccountCode id={account_code_id}.\")\n    try:"
            },
            {
                "name": "process_account_code_delete",
                "args": [
                    "account_code_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "account_code_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_account_code_delete(account_code_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted AccountCode id={account_code_id}.\")\n    try:"
            },
            {
                "name": "process_receipt_create",
                "args": [
                    "receipt_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "receipt_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_receipt_create(receipt_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_receipt_create shared task. receipt_id={receipt_id}.\")\n    try:"
            },
            {
                "name": "process_receipt_update",
                "args": [
                    "receipt_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "receipt_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_receipt_update(receipt_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated Receipt id={receipt_id}.\")\n    try:"
            },
            {
                "name": "process_receipt_delete",
                "args": [
                    "receipt_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "receipt_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_receipt_delete(receipt_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted Receipt id={receipt_id}.\")\n    try:"
            },
            {
                "name": "process_spend_money_create",
                "args": [
                    "spend_money_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "spend_money_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_spend_money_create(spend_money_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_spend_money_create shared task. spend_money_id={spend_money_id}.\")\n    try:"
            },
            {
                "name": "process_spend_money_update",
                "args": [
                    "spend_money_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "spend_money_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_spend_money_update(spend_money_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated SpendMoney id={spend_money_id}.\")\n    try:"
            },
            {
                "name": "process_spend_money_delete",
                "args": [
                    "spend_money_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "spend_money_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_spend_money_delete(spend_money_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted SpendMoney id={spend_money_id}.\")\n    try:"
            },
            {
                "name": "process_tax_account_create",
                "args": [
                    "tax_account_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "tax_account_trigger_on_create"
                ],
                "docstring": null,
                "function_body": "def process_tax_account_create(tax_account_id: int):\n    logger.info(f\"\ud83d\ude80 Starting process_tax_account_create shared task. tax_account_id={tax_account_id}.\")\n    try:"
            },
            {
                "name": "process_tax_account_update",
                "args": [
                    "tax_account_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "tax_account_trigger_on_update"
                ],
                "docstring": null,
                "function_body": "def process_tax_account_update(tax_account_id: int):\n    logger.info(f\"\ud83d\udd04 Handling updated TaxAccount id={tax_account_id}.\")\n    try:"
            },
            {
                "name": "process_tax_account_delete",
                "args": [
                    "tax_account_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "tax_account_trigger_on_delete"
                ],
                "docstring": null,
                "function_body": "def process_tax_account_delete(tax_account_id: int):\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted TaxAccount id={tax_account_id}.\")\n    try:"
            },
            {
                "name": "process_xero_bill_update",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "update_xero_bill_trigger",
                    "initialize_database"
                ],
                "docstring": "The Celery task for handling updated XeroBills.",
                "function_body": "def process_xero_bill_update(bill_id: int):\n    \"\"\"\n    The Celery task for handling updated XeroBills.\n    \"\"\"\n    logger.info(f\"\ud83d\ude80 Starting update_xero_bill shared task. bill_id={bill_id}.\")\n    try:"
            },
            {
                "name": "process_xero_bill_create",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "create_xero_bill_trigger"
                ],
                "docstring": "The Celery task for handling newly created XeroBills.",
                "function_body": "def process_xero_bill_create(bill_id: str):\n    \"\"\"\n    The Celery task for handling newly created XeroBills.\n    \"\"\"\n    logger.info(f\"\ud83c\udf00 NEW TASK - CREATE - XERO BILL - STARTED \ud83c\udf00 {bill_id}.\")\n    try:"
            },
            {
                "name": "create_xero_bill_line_items",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "create_xero_bill_line_items_trigger",
                    "initialize_database"
                ],
                "docstring": "The Celery task for handling newly inserted line items for a XeroBill.",
                "function_body": "def create_xero_bill_line_items(bill_id: int):\n    \"\"\"\n    The Celery task for handling newly inserted line items for a XeroBill.\n    \"\"\"\n    logger.info(f\"\ud83c\udf00 Handling created line items for bill_id={bill_id}\")\n    try:"
            },
            {
                "name": "update_xero_bill_line_item",
                "args": [
                    "line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "update_xero_bill_line_item_trigger"
                ],
                "docstring": "The Celery task for handling updated line items for a XeroBill.",
                "function_body": "def update_xero_bill_line_item(line_item_id: int):\n    \"\"\"\n    The Celery task for handling updated line items for a XeroBill.\n    \"\"\"\n    logger.info(f\"\ud83c\udf00 Handling updated line item for line_item_id={line_item_id}\")\n    try:"
            },
            {
                "name": "process_xero_bill_delete",
                "args": [
                    "bill_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "delete_xero_bill_trigger"
                ],
                "docstring": "The Celery task for handling deleted XeroBills.",
                "function_body": "def process_xero_bill_delete(bill_id: int):\n    \"\"\"\n    The Celery task for handling deleted XeroBills.\n    \"\"\"\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted XeroBill bill_id={bill_id}.\")\n    try:"
            },
            {
                "name": "delete_xero_bill_line_item",
                "args": [
                    "line_item_id"
                ],
                "decorators": [
                    "shared_task"
                ],
                "calls": [
                    "initialize_database",
                    "delete_xero_bill_line_item_trigger"
                ],
                "docstring": "The Celery task for handling deleted line items for a XeroBill.",
                "function_body": "def delete_xero_bill_line_item(line_item_id: int):\n    \"\"\"\n    The Celery task for handling deleted line items for a XeroBill.\n    \"\"\"\n    logger.info(f\"\ud83d\uddd1\ufe0f Handling deleted line item for line_item_id={line_item_id}\")\n    try:"
            }
        ],
        "classes": [],
        "variables": [
            {
                "name": "logger",
                "value": "logging.getLogger('admin_logger')"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/server_celery/logging_setup.py",
        "functions": [
            {
                "name": "setup_logging",
                "args": [],
                "decorators": [],
                "calls": [],
                "docstring": "Create loggers for each module: budget, dropbox, invoice, monday, po_log, xero, database.\nEach logger writes to a separate file in ./logs, plus a StreamHandler for the console.",
                "function_body": "def setup_logging():\n    \"\"\"\n    Create loggers for each module: budget, dropbox, invoice, monday, po_log, xero, database.\n    Each logger writes to a separate file in ./logs, plus a StreamHandler for the console.\n    \"\"\"\n    # Ensure the logs folder exists\n    os.makedirs(\"./logs\", exist_ok=True)\n    folder_name = \"server_celery\"\n\n    basepath = \"./\" + folder_name + \"/logs/\"\n    # Common log format\n    log_format = \"%(asctime)s [%(levelname)s] %(name)s: %(message)s\"\n\n    formatter = logging.Formatter(log_format)\n\n    # StreamHandler for console (all logs)\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n\n    # ---------------------------------------------------------\n    #  Logger for admin\n    # ---------------------------------------------------------\n    admin_logger = logging.getLogger(\"admin_logger\")\n    admin_logger.setLevel(logging.DEBUG)\n    file_handler_admin = logging.FileHandler(\"./logs/admin.log\")\n    file_handler_admin.setFormatter(formatter)\n    admin_logger.addHandler(file_handler_admin)\n    admin_logger.addHandler(console_handler)\n    admin_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for budget\n    # ---------------------------------------------------------\n    budget_logger = logging.getLogger(\"budget_logger\")\n    budget_logger.setLevel(logging.DEBUG)\n    file_handler_budget = logging.FileHandler(\"./logs/budget.log\")\n    file_handler_budget.setFormatter(formatter)\n    budget_logger.addHandler(file_handler_budget)\n    budget_logger.addHandler(console_handler)\n    budget_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for dropbox\n    # ---------------------------------------------------------\n    dropbox_logger = logging.getLogger(\"dropbox_logger\")\n    dropbox_logger.setLevel(logging.DEBUG)\n    file_handler_dropbox = logging.FileHandler(\"./logs/dropbox.log\")\n    file_handler_dropbox.setFormatter(formatter)\n    dropbox_logger.addHandler(file_handler_dropbox)\n    dropbox_logger.addHandler(console_handler)\n    dropbox_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for invoice\n    # ---------------------------------------------------------\n    invoice_logger = logging.getLogger(\"invoice_logger\")\n    invoice_logger.setLevel(logging.DEBUG)\n    file_handler_invoice = logging.FileHandler(\"./logs/invoice.log\")\n    file_handler_invoice.setFormatter(formatter)\n    invoice_logger.addHandler(file_handler_invoice)\n    invoice_logger.addHandler(console_handler)\n    invoice_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for monday\n    # ---------------------------------------------------------\n    monday_logger = logging.getLogger(\"monday_logger\")\n    monday_logger.setLevel(logging.DEBUG)\n    file_handler_monday = logging.FileHandler(\"./logs/monday.log\")\n    file_handler_monday.setFormatter(formatter)\n    monday_logger.addHandler(file_handler_monday)\n    monday_logger.addHandler(console_handler)\n    monday_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for po_log\n    # ---------------------------------------------------------\n    po_log_logger = logging.getLogger(\"po_log_logger\")\n    po_log_logger.setLevel(logging.DEBUG)\n    file_handler_po = logging.FileHandler(\"./logs/po_log.log\")\n    file_handler_po.setFormatter(formatter)\n    po_log_logger.addHandler(file_handler_po)\n    po_log_logger.addHandler(console_handler)\n    po_log_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for xero\n    # ---------------------------------------------------------\n    xero_logger = logging.getLogger(\"xero_logger\")\n    xero_logger.setLevel(logging.DEBUG)\n    file_handler_xero = logging.FileHandler(\"./logs/xero.log\")\n    file_handler_xero.setFormatter(formatter)\n    xero_logger.addHandler(file_handler_xero)\n    xero_logger.addHandler(console_handler)\n    xero_logger.propagate = False\n\n    # ---------------------------------------------------------\n    #  Logger for database\n    # ---------------------------------------------------------\n    db_logger = logging.getLogger(\"database_logger\")\n    db_logger.setLevel(logging.DEBUG)\n    file_handler_db = logging.FileHandler(\"./logs/database.log\")\n    file_handler_db.setFormatter(formatter)\n    db_logger.addHandler(file_handler_db)\n    db_logger.addHandler(console_handler)\n    db_logger.propagate = False\n\n    # Optional: set root logger if you want\n    logging.basicConfig(level=logging.INFO)"
            }
        ],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_po_log/__init__.py",
        "functions": [],
        "classes": [],
        "variables": []
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_po_log/po_log_processor.py",
        "functions": [],
        "classes": [
            {
                "name": "POLogProcessor",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "_extract_project_number",
                        "args": [
                            "self",
                            "file_path"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _extract_project_number(self, file_path: str) -> str:\n        filename = os.path.basename(file_path)\n        self.logger.debug(f\"\ud83d\udd0d Searching for project ID in filename: '{filename}'\")\n        pattern = r\"^PO_LOG_(\\d{4})[-_]\\d{4}-\\d{2}-\\d{2}_\\d{2}-\\d{2}-\\d{2}\\.txt$\"\n        match = re.match(pattern, filename)\n        if match:"
                    },
                    {
                        "name": "_map_payment_type",
                        "args": [
                            "self",
                            "raw_type"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _map_payment_type(self, raw_type: str) -> str:\n        self.logger.debug(f\"\ud83d\udd27 Mapping payment type for raw_type='{raw_type}'\")\n        if raw_type == \"CRD\":"
                    },
                    {
                        "name": "_determine_status_and_due_date",
                        "args": [
                            "self",
                            "pay_id",
                            "payment_type",
                            "transaction_date"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Determines the status and due_date based on the rules:\n  - If status = \"PAID\" and payment type = CC or PC => status=PAID,  due_date=transaction_date\n  - If status = \"RTP\"  and payment type = INV     => status=RTP,   due_date=current_date\n  - If status = \"NET0\" and payment type = INV     => status=RTP,   due_date=transaction_date\n  - If status = \"NET(some number)\" and payment type = INV\n         => status=RTP, due_date=transaction_date + that number of days\n  - If status = \"PAID\" and payment type = INV     => status=PAID,  due_date=current_date\n  - If none of the above and payment type = INV   => status=PENDING, due_date=transaction_date + 30 days\n  - Otherwise, default to status=PENDING, due_date=transaction_date",
                        "function_body": "    def _determine_status_and_due_date(self, pay_id: str, payment_type: str, transaction_date: datetime) -> (str, datetime):\n        \"\"\"\n        Determines the status and due_date based on the rules:\n          - If status = \"PAID\" and payment type = CC or PC => status=PAID,  due_date=transaction_date\n          - If status = \"RTP\"  and payment type = INV     => status=RTP,   due_date=current_date\n          - If status = \"NET0\" and payment type = INV     => status=RTP,   due_date=transaction_date\n          - If status = \"NET(some number)\" and payment type = INV\n                 => status=RTP, due_date=transaction_date + that number of days\n          - If status = \"PAID\" and payment type = INV     => status=PAID,  due_date=current_date\n          - If none of the above and payment type = INV   => status=PENDING, due_date=transaction_date + 30 days\n          - Otherwise, default to status=PENDING, due_date=transaction_date\n        \"\"\"\n        pay_id_upper = (pay_id or \"\").strip().upper()\n        current_date = datetime.today()\n\n        # 1) \"PAID\" + CC/PC\n        if payment_type in [\"CC\", \"PC\"]:\n            return \"SUBMITTED\", transaction_date\n\n        # 2) \"RTP\" + INV\n        if pay_id_upper == \"RTP\" and payment_type == \"INV\":\n            return \"RTP\", current_date\n\n        # 3) \"NET0\" + INV\n        if pay_id_upper == \"NET0\" and payment_type == \"INV\":\n            return \"RTP\", transaction_date\n\n        # 4) \"NET(some number)\" + INV\n        net_match = re.match(r\"^NET(\\d+)$\", pay_id_upper)\n        if net_match and payment_type == \"INV\":\n            net_days = int(net_match.group(1))\n            return \"RTP\", transaction_date + timedelta(days=net_days)\n\n        # 5) \"PAID\" + INV\n        if pay_id_upper == \"PAID\" and payment_type == \"INV\":\n            return \"PAID\", current_date\n\n        # 6) None of the above + INV => PENDING + 30 days\n        if payment_type == \"INV\":\n            return \"PENDING\", transaction_date + timedelta(days=30)\n\n        # If not one of the above conditions, just default\n        return \"PENDING\", transaction_date"
                    },
                    {
                        "name": "_parse_date",
                        "args": [
                            "self",
                            "date_str"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _parse_date(self, date_str: str) -> datetime:\n        self.logger.debug(f\"\u23f0 Parsing date from '{date_str}'\")\n        try:"
                    },
                    {
                        "name": "_clean_numeric",
                        "args": [
                            "self",
                            "num_str"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _clean_numeric(self, num_str: str) -> float:\n        self.logger.debug(f\"\ud83d\udcb2 Cleaning numeric value '{num_str}'\")\n        try:"
                    },
                    {
                        "name": "_parse_factors",
                        "args": [
                            "self",
                            "factors",
                            "subtotal"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def _parse_factors(self, factors: str, subtotal: float):\n        self.logger.debug(f\"\ud83d\udd27 Parsing factors: '{factors}' with subtotal='{subtotal}' \")\n        clean_factors = re.sub(r'\\s+', ' ', factors.replace(',', ''))\n\n        # Updated regex to allow negative numbers\n        main_pattern = r'(-?\\d+(?:\\.\\d+)?)\\s*\\w*\\s*x\\s*(-?\\d+(?:\\.\\d+)?)'\n        match = re.search(main_pattern, clean_factors, flags=re.IGNORECASE)\n\n        quantity = 1.0\n        rate = float(subtotal)\n        ot = 0.0\n\n        if match:\n            try:\n                quantity = float(match.group(1))\n                rate = float(match.group(2))\n                self.logger.debug(f\"\u2714\ufe0f Found quantity='{quantity}' and rate='{rate}' from factors.\")\n            except ValueError as e:\n                error_msg = f\"\u2757\ufe0f Error parsing factors '{factors}': {e}\"\n                self.logger.error(error_msg)\n                raise e\n        else:\n            error_msg = f\"\u2757\ufe0f Factors '{factors}' do not match the expected pattern.\"\n            self.logger.error(error_msg)\n\n        # Additional parsing for OT if needed\n        plus_pattern = r'\\+\\s*\\$?(-?\\d+(?:\\.\\d+)?)\\s*(?:OT|Misc)?'\n        plus_match = re.search(plus_pattern, clean_factors, flags=re.IGNORECASE)\n        if plus_match:\n            try:\n                ot = float(plus_match.group(1))\n                self.logger.debug(f\"\u2714\ufe0f Found OT='{ot}' from factors.\")\n            except ValueError as e:\n                self.logger.warning(f\"\u2757\ufe0f Error parsing OT from factors '{factors}': {e}\")\n\n        return quantity, rate, ot"
                    },
                    {
                        "name": "_read_and_store_entries",
                        "args": [
                            "self",
                            "file_path",
                            "project_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "_parse_date",
                            "_determine_status_and_due_date",
                            "_map_payment_type",
                            "_clean_numeric"
                        ],
                        "docstring": null,
                        "function_body": "    def _read_and_store_entries(self, file_path: str, project_number: str):\n        self.logger.info(f\"\ud83d\udcc2 Reading file: '{file_path}' for project_number='{project_number}'\")\n\n        main_items = []\n        contacts = []\n        raw_entries = []\n        manual_ids_by_po = defaultdict(set)\n        po_map = {}\n        main_item_has_description = {}\n\n        expected_columns = 11\n\n        with open(file_path, 'r', newline='', encoding='utf-8') as txtfile:\n            reader = csv.reader(txtfile, delimiter='\\t')\n            headers = next(reader, None)\n            self.logger.debug(f\"\ud83d\uddc2 Headers found: {headers}\")\n\n            for row_number, row in enumerate(reader, start=2):\n                self.logger.debug(f\"\ud83d\udcdc Processing row {row_number}: {row}\")\n                if not any(row):\n                    self.logger.debug(\"\ud83d\udeab Empty row skipped.\")\n                    continue\n                if row[0].strip().upper() == \"DATE\":\n                    self.logger.debug(\"\ud83d\udeab Header-like row encountered, skipping.\")\n                    continue\n\n                if len(row) < expected_columns:\n                    self.logger.debug(\n                        f\"\ud83d\udd27 Row {row_number} has fewer than {expected_columns} columns. Padding with empty strings.\")\n                    row += [''] * (expected_columns - len(row))\n                elif len(row) > expected_columns:\n                    self.logger.debug(\n                        f\"\u26a0\ufe0f Row {row_number} has more than {expected_columns} columns. Truncating extras.\")\n                    row = row[:expected_columns]\n\n                try:\n                    transaction_date_str = row[0].strip()\n                    raw_type = row[1].strip()\n                    pay_id = row[2].strip()\n                    account = row[3].strip().lstrip(\"0\")\n                    item_id = row[4].strip()\n                    vendor = row[5].strip()\n                    description = row[6].strip()\n                    po_number = row[7].strip()\n                    factors = row[8].strip()\n                    subtotal_str = row[9].strip()\n                    fringes_str = row[10].strip()\n                except IndexError as e:\n                    self.logger.warning(f\"\u2757\ufe0f Malformed line at row {row_number}: {row}, error: {e}\")\n                    continue\n\n                if not transaction_date_str:\n                    self.logger.warning(f\"\u2757\ufe0f Missing transaction date at row {row_number}: {row}\")\n                    continue\n                if not raw_type:\n                    self.logger.warning(f\"\u2757\ufe0f Missing raw type at row {row_number}: {row}\")\n                    continue\n                if not po_number and raw_type != 'PC':\n                    self.logger.warning(f\"\u2757\ufe0f No PO number found at row {row_number}: {row}\")\n                    continue\n\n                subtotal = self._clean_numeric(subtotal_str)\n                fringes = self._clean_numeric(fringes_str) if fringes_str else 0.0\n                payment_type = self._map_payment_type(raw_type)\n\n                if payment_type == \"PC\":\n                    po_number = \"1\"\n                else:\n                    po_number = po_number.lstrip(\"0\")\n\n                try:\n                    transaction_date = self._parse_date(transaction_date_str)\n                except Exception as e:\n                    self.logger.warning(f\"\u2757\ufe0f Invalid date at row {row_number}: {transaction_date_str}, error: {e}\")\n                    transaction_date = datetime.today()\n\n                status, due_date = self._determine_status_and_due_date(pay_id, payment_type, transaction_date)\n\n                # Determine contact name\n                if payment_type == \"PC\":\n                    contact_name = \"PETTY CASH\"\n                    vendor_type = \"PC\"\n                elif payment_type == \"CC\":\n                    contact_name = f\"Credit Card {pay_id}\"\n                    vendor_type = \"CC\"\n                else:\n                    contact_name = vendor if vendor else \"UNKNOWN CONTACT\"\n                    vendor_type = \"Vendor\"\n\n                po_key = (project_number, po_number)\n                if po_key not in po_map:\n                    main_item_desc = description if description else ''\n                    main_item = {\n                        'project_number': project_number,\n                        'contact_name': contact_name,\n                        'po_number': po_number,\n                        'status': status,\n                        'po_type': payment_type,\n                        'description': main_item_desc,\n                        'amount': 0.0\n                    }\n                    po_map[po_key] = len(main_items)\n                    main_items.append(main_item)\n                    main_item_has_description[po_key] = bool(main_item_desc)\n\n                    contacts.append({\n                        \"name\": contact_name,\n                        \"project_number\": project_number,\n                        \"po_number\": po_number,\n                        \"vendor_type\": vendor_type\n                    })\n                    self.logger.debug(f\"\ud83d\udce6 Created main item for PO='{po_number}' with contact='{contact_name}'.\")\n\n                try:\n                    transaction_date = self._parse_date(transaction_date_str)\n                except Exception as e:\n                    self.logger.warning(f\"\u2757\ufe0f Invalid date at row {row_number}: {transaction_date_str}, error: {e}\")\n                    transaction_date = datetime.today()\n\n                if payment_type.lower() not in [\"cc\", \"pc\", \"crd\"]:\n                    due_date = transaction_date + timedelta(days=30)\n                else:\n                    due_date = transaction_date\n\n                if payment_type == \"PC\":\n                    parts = pay_id.split('_')\n                    if len(parts) >= 3:\n                        envelope_str = parts[-1].strip()\n                        try:\n                            envelope_number = int(envelope_str.lstrip('0') or '0')\n                        except ValueError:\n                            self.logger.warning(f\"\u2757\ufe0f Invalid envelope number '{envelope_str}' at row {row_number}\")\n                            envelope_number = 0\n                    else:\n                        envelope_number = 0\n                else:\n                    envelope_number = 0\n\n                entry = {\n                    'project_number': project_number,\n                    'po_number': po_number,\n                    'vendor': vendor,\n                    'date': transaction_date,\n                    'due_date': due_date,\n                    'factors': factors,\n                    'subtotal': subtotal,\n                    'description': description,\n                    'status': status,\n                    'account': account,\n                    'payment_type': payment_type,\n                    'fringes': fringes,\n                    'item_id_raw': item_id,\n                    'envelope_number': envelope_number,\n                    'pay_id': pay_id\n                }\n                raw_entries.append(entry)\n                self.logger.debug(f\"\ud83d\udcdd Added raw entry: {entry}\")\n\n                if item_id and item_id.strip():\n                    stripped_id = item_id.lstrip('0') or '1'\n                    if payment_type == \"PC\":\n                        try:\n                            numeric_id = int(stripped_id)\n                        except ValueError:\n                            numeric_id = 1\n                        detail_item_id_key = envelope_number\n                    else:\n                        try:\n                            numeric_id = int(stripped_id)\n                        except ValueError:\n                            numeric_id = 1\n                        detail_item_id_key = str(numeric_id)\n                    manual_ids_by_po[(po_number, envelope_number)].add(detail_item_id_key)\n                    self.logger.debug(f\"\ud83d\udd17 Tracked manual ID='{detail_item_id_key}' for PO='{po_number}'.\")\n\n                if not main_item_has_description[po_key] and description:\n                    mi_index = po_map[po_key]\n                    main_items[mi_index]['description'] = description\n                    main_item_has_description[po_key] = True\n                    self.logger.debug(f\"\u270f\ufe0f Updated main item description for PO='{po_number}'.\")\n\n        self.logger.info(\n            f\"\ud83d\udcd1 Finished reading entries. Found {len(main_items)} main items, {len(raw_entries)} raw entries.\")\n        return main_items, contacts, raw_entries, manual_ids_by_po"
                    },
                    {
                        "name": "_assign_item_ids",
                        "args": [
                            "self",
                            "raw_entries",
                            "manual_ids_by_po"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "Logic Changes:\n1) Retain PC logic (petty cash). If item_id_raw is missing for PC, we set line_number=1.\n2) For non-PC:\n   - If item_id_raw is empty -> detail_item_id=\"1\"\n   - If item_id_raw is present -> detail_item_id=<parsed numeric>\n   - We **auto-increment** line_number for each repeated (po_number, detail_item_id).",
                        "function_body": "    def _assign_item_ids(self, raw_entries, manual_ids_by_po):\n        \"\"\"\n        Logic Changes:\n        1) Retain PC logic (petty cash). If item_id_raw is missing for PC, we set line_number=1.\n        2) For non-PC:\n           - If item_id_raw is empty -> detail_item_id=\"1\"\n           - If item_id_raw is present -> detail_item_id=<parsed numeric>\n           - We **auto-increment** line_number for each repeated (po_number, detail_item_id).\n        \"\"\"\n        self.logger.debug(\"\ud83d\udd16 Assigning detail_item_id and line_number to entries...\")\n        assigned_item_ids = defaultdict(set)\n\n        # Store manually provided IDs, if any\n        for key_for_ids, manual_ids in manual_ids_by_po.items():\n            for mid in manual_ids:\n                assigned_item_ids[key_for_ids].add(mid)\n                self.logger.debug(f\"\ud83d\udd17 Manual ID='{mid}' recorded for key='{key_for_ids}'\")\n\n        # We auto-increment line_number for repeated detail_item_ids in non-PC transactions\n        line_number_counters = defaultdict(int)\n\n        for entry in raw_entries:"
                    },
                    {
                        "name": "parse_showbiz_po_log",
                        "args": [
                            "self",
                            "file_path"
                        ],
                        "decorators": [],
                        "calls": [
                            "_assign_item_ids",
                            "_parse_factors",
                            "_extract_project_number",
                            "_read_and_store_entries"
                        ],
                        "docstring": null,
                        "function_body": "    def parse_showbiz_po_log(self, file_path: str):\n        self.logger.info(f\"\ud83d\ude80 Starting parse_showbiz_po_log for file: {file_path}\")\n        project_number = self._extract_project_number(file_path)\n\n        main_items, contacts, raw_entries, manual_ids_by_po = self._read_and_store_entries(file_path, project_number)\n        self._assign_item_ids(raw_entries, manual_ids_by_po)\n\n        detail_items = []\n        self.logger.debug(\"\ud83d\udd04 Creating detail_items from raw_entries...\")\n        for entry in raw_entries:\n            quantity, rate, ot = self._parse_factors(entry['factors'], entry['subtotal'])\n            detail_item = {\n                'project_number': entry['project_number'],\n                'po_number': entry['po_number'],\n                'detail_item_id': entry['detail_item_id'],\n                'line_number': entry['line_number'],\n                'vendor': entry['vendor'],\n                'date': entry['date'].strftime('%Y-%m-%d'),\n                'due date': entry['due_date'].strftime('%Y-%m-%d'),\n                'quantity': quantity,\n                'rate': rate,\n                'description': entry['description'],\n                'state': entry['status'],\n                'account': entry['account'],\n                'payment_type': entry['payment_type'],\n                'total': entry['subtotal'],\n                'OT': ot,\n                'fringes': entry['fringes'],\n            }\n            detail_items.append(detail_item)\n            self.logger.debug(f\"\ud83d\udcbe Created detail_item: {detail_item}\")\n\n        # Sum amounts for main items\n        self.logger.debug(\"\ud83d\udd22 Summing up amounts for main items...\")\n        for m in main_items:\n            rel_details = [\n                d for d in detail_items\n                if d['po_number'] == m['po_number'] and d['project_number'] == m['project_number']\n            ]\n            total_amount = sum(d['total'] for d in rel_details)\n            m['amount'] = total_amount\n            self.logger.debug(f\"\ud83d\udcc8 PO='{m['po_number']}' total amount='{total_amount}'\")\n\n        self.logger.info(\n            f\"\ud83c\udf89 Parsed {len(main_items)} main items, {len(detail_items)} detail items, and {len(contacts)} contacts for project {project_number}.\"\n        )\n        if self.TEST_MODE:\n            self.logger.debug(f\"\ud83d\uddd2 Main Items: {main_items}\")\n            self.logger.debug(f\"\ud83d\uddd2 Detail Items: {detail_items}\")\n            self.logger.debug(f\"\ud83d\uddd2 Contacts: {contacts}\")\n\n        self.logger.info(\"\u2705 Parsing completed successfully! \ud83c\udfc1\")\n        return main_items, detail_items, contacts"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "po_log_processor",
                "value": "POLogProcessor()"
            }
        ]
    },
    {
        "file_path": "/Users/haske107/PycharmProjects/Dropbox Listener/files_po_log/po_log_database_util.py",
        "functions": [],
        "classes": [
            {
                "name": "PoLogDatabaseUtil",
                "methods": [
                    {
                        "name": "__init__",
                        "args": [
                            "self"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": null,
                        "function_body": "    def __init__(self):\n        if not hasattr(self, '_initialized'):"
                    },
                    {
                        "name": "get_contact_surrogate_ids",
                        "args": [
                            "self",
                            "contacts_list"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_contacts"
                        ],
                        "docstring": "\ud83d\uddc2 Example usage showing searching the Contact model with DatabaseOperations.",
                        "function_body": "    def get_contact_surrogate_ids(self, contacts_list):\n        \"\"\"\n        \ud83d\uddc2 Example usage showing searching the Contact model with DatabaseOperations.\n        \"\"\"\n        new_contact_list = []\n        for contact in contacts_list:\n            try:\n                # Instead of manual queries, we can do:\n                found = self.db_ops.search_contacts([\"name\"], [contact.get(\"name\")])\n                if found:\n                    self.logger.debug(f\"\ud83e\udd1d Found in database: {contact.get('name')}\")\n                    if isinstance(found, list):\n                        found = found[0]\n                    new_contact_list.append({\n                        \"name\": contact.get(\"name\"),\n                        \"po_number\": contact.get(\"po_number\"),\n                        \"contact_surrogate_id\": \"Unknown (You could store or map ID here)\"\n                    })\n                else:\n                    self.logger.debug(f\"\ud83d\ude45 Not in database: {contact.get('name')}\")\n            except Exception as e:\n                self.logger.error(f\"\ud83d\udca5 Error processing contact '{contact.get('name', 'Unknown')}': {e}\", exc_info=True)\n\n        return new_contact_list"
                    },
                    {
                        "name": "link_contact_to_po",
                        "args": [
                            "self",
                            "contacts",
                            "project_id"
                        ],
                        "decorators": [],
                        "calls": [],
                        "docstring": "\ud83d\udd17 Example method to show linking logic. This might now be replaced by\ndirect usage of create/update from DatabaseOperations if you prefer.",
                        "function_body": "    def link_contact_to_po(self, contacts, project_id):\n        \"\"\"\n        \ud83d\udd17 Example method to show linking logic. This might now be replaced by\n        direct usage of create/update from DatabaseOperations if you prefer.\n        \"\"\"\n        self.logger.info(\"\ud83d\udd17 link_contact_to_po is not fully migrated; use db_ops if needed.\")"
                    },
                    {
                        "name": "find_or_create_contact_item_in_db",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_contacts",
                            "update_contact",
                            "create_contact"
                        ],
                        "docstring": "\ud83c\udfd7 Example wrapper around db_ops for contact creation.",
                        "function_body": "    def find_or_create_contact_item_in_db(self, item):\n        \"\"\"\n        \ud83c\udfd7 Example wrapper around db_ops for contact creation.\n        \"\"\"\n        # We'll do a search by name or tax_id, etc.\n        name = item.get(\"contact_name\")\n        tax_id = item.get(\"tax_id\")\n\n        found = None\n        if tax_id:\n            found = self.db_ops.search_contacts([\"tax_ID\"], [tax_id])\n        if not found and name:\n            found = self.db_ops.search_contacts([\"name\"], [name])\n\n        if found and not isinstance(found, list):"
                    },
                    {
                        "name": "create_or_update_main_item_in_db",
                        "args": [
                            "self",
                            "item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_purchase_order",
                            "search_purchase_orders",
                            "create_purchase_order"
                        ],
                        "docstring": "\ud83c\udfd7 Create or update a PurchaseOrder.",
                        "function_body": "    def create_or_update_main_item_in_db(self, item):\n        \"\"\"\n        \ud83c\udfd7 Create or update a PurchaseOrder.\n        \"\"\"\n        # Search to see if it already exists:\n        existing_po = self.db_ops.search_purchase_orders(\n            [\"project_id\", \"po_number\"],\n            [item[\"project_id\"], item[\"po_number\"]]\n        )\n        if existing_po:\n            # If it's a list, get the first\n            if isinstance(existing_po, list):\n                existing_po = existing_po[0]\n            po_id = existing_po[\"id\"]  # The PK in your DB (assuming 'id')\n            updated = self.db_ops.update_purchase_order(po_id, **{\n                \"contact_id\": item.get(\"contact_surrogate_id\"),\n                \"description\": item.get(\"description\"),\n                \"pulse_id\": item.get(\"pulse_id\"),\n                \"po_type\": item.get(\"po_type\"),\n                \"state\": item.get(\"status\"),\n                \"folder_link\": item.get(\"folder_link\"),\n                \"tax_form_link\": item.get(\"tax_form_link\")\n            })\n            if updated:\n                item[\"po_surrogate_id\"] = updated[\"id\"]\n        else:\n            # Create a new PO\n            created = self.db_ops.create_purchase_order(\n                project_id=item[\"project_id\"],\n                po_number=item[\"po_number\"],\n                contact_id=item.get(\"contact_surrogate_id\"),\n                description=item.get(\"description\"),\n                pulse_id=item.get(\"pulse_id\"),\n                po_type=item.get(\"po_type\"),\n                state=item.get(\"status\"),\n                folder_link=item.get(\"folder_link\"),\n                tax_form_link=item.get(\"tax_form_link\")\n            )\n            if created:\n                item[\"po_surrogate_id\"] = created[\"id\"]\n        return item"
                    },
                    {
                        "name": "create_or_update_sub_item_in_db",
                        "args": [
                            "self",
                            "sub_item"
                        ],
                        "decorators": [],
                        "calls": [
                            "update_detail_item",
                            "search_detail_items",
                            "create_detail_item"
                        ],
                        "docstring": "\ud83c\udfd7 Create or update a DetailItem.",
                        "function_body": "    def create_or_update_sub_item_in_db(self, sub_item):\n        \"\"\"\n        \ud83c\udfd7 Create or update a DetailItem.\n        \"\"\"\n        # Search\n        existing_detail = self.db_ops.search_detail_items(\n            [\"project_id\", \"po_number\", \"detail_number\", \"line_number\"],\n            [\n                sub_item[\"project_id\"],\n                sub_item[\"po_number\"],\n                sub_item[\"detail_item_id\"],\n                sub_item[\"line_number\"]\n            ]\n        )\n        if existing_detail:\n            if isinstance(existing_detail, list):\n                existing_detail = existing_detail[0]\n            detail_id = existing_detail[\"id\"]\n            self.db_ops.update_detail_item(detail_id, **{\n                \"parent_surrogate_id\": sub_item.get(\"po_surrogate_id\"),\n                \"vendor\": sub_item.get(\"vendor\"),\n                \"payment_type\": sub_item.get(\"payment_type\"),\n                \"description\": sub_item.get(\"description\"),\n                \"pulse_id\": sub_item.get(\"pulse_id\"),\n                \"parent_pulse_id\": sub_item.get(\"parent_pulse_id\"),\n                \"state\": \"RTP\" if sub_item.get(\"parent_status\") == \"RTP\" else \"PENDING\",\n                \"rate\": sub_item.get(\"rate\"),\n                \"quantity\": sub_item.get(\"quantity\"),\n                \"ot\": sub_item.get(\"OT\"),\n                \"fringes\": sub_item.get(\"fringes\"),\n                \"transaction_date\": sub_item.get(\"date\"),\n                \"due_date\": None,  # or compute it\n                \"account_number\": sub_item.get(\"account\")\n            })\n        else:\n            self.db_ops.create_detail_item(\n                project_id=sub_item[\"project_id\"],\n                po_number=sub_item[\"po_number\"],\n                detail_number=sub_item[\"detail_item_id\"],\n                line_number=sub_item[\"line_number\"],\n                parent_surrogate_id=sub_item.get(\"po_surrogate_id\"),\n                vendor=sub_item.get(\"vendor\"),\n                payment_type=sub_item.get(\"payment_type\"),\n                description=sub_item.get(\"description\"),\n                pulse_id=sub_item.get(\"pulse_id\"),\n                parent_pulse_id=sub_item.get(\"parent_pulse_id\"),\n                state=\"RTP\" if sub_item.get(\"parent_status\") == \"RTP\" else \"PENDING\",\n                rate=sub_item.get(\"rate\"),\n                quantity=sub_item.get(\"quantity\"),\n                ot=sub_item.get(\"OT\"),\n                fringes=sub_item.get(\"fringes\"),\n                transaction_date=sub_item.get(\"date\"),\n                due_date=None,  # or compute it\n                account_number=sub_item.get(\"account\")\n            )\n        return sub_item"
                    },
                    {
                        "name": "get_contact_by_name",
                        "args": [
                            "self",
                            "name"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_contacts"
                        ],
                        "docstring": "\ud83d\uddc2 Simplified retrieval via db_ops.search_contacts",
                        "function_body": "    def get_contact_by_name(self, name: str):\n        \"\"\"\n        \ud83d\uddc2 Simplified retrieval via db_ops.search_contacts\n        \"\"\"\n        results = self.db_ops.search_contacts([\"name\"], [name])\n        if not results:\n            self.logger.info(f\"\u26a0\ufe0f No contact found with name: {name}\")\n            return None\n        if isinstance(results, list):\n            return results[0]\n        return results"
                    },
                    {
                        "name": "get_subitems",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "detail_number",
                            "line_number"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_detail_items"
                        ],
                        "docstring": "\ud83d\udcda Example retrieval using db_ops.search_detail_items with possible filters.",
                        "function_body": "    def get_subitems(self, project_id, po_number=None, detail_number=None, line_number=None):\n        \"\"\"\n        \ud83d\udcda Example retrieval using db_ops.search_detail_items with possible filters.\n        \"\"\"\n        # Build dynamic filters\n        column_names = []\n        values = []\n        if project_id is not None:\n            column_names.append(\"project_id\")\n            values.append(project_id)\n        if po_number is not None:\n            column_names.append(\"po_number\")\n            values.append(po_number)\n        if detail_number is not None:\n            column_names.append(\"detail_number\")\n            values.append(detail_number)\n        if line_number is not None:\n            column_names.append(\"line_number\")\n            values.append(line_number)\n\n        # Use the search\n        subitems = self.db_ops.search_detail_items(column_names, values)\n        if not subitems:\n            return []\n        if isinstance(subitems, dict):\n            return [subitems]\n        return subitems"
                    },
                    {
                        "name": "get_purchase_orders",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "po_type"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders"
                        ],
                        "docstring": "Retrieve POs with optional filters. For example, pass in po_type=\"INV\".",
                        "function_body": "    def get_purchase_orders(self, project_id=None, po_number=None, po_type=None):\n        \"\"\"\n        Retrieve POs with optional filters. For example, pass in po_type=\"INV\".\n        \"\"\"\n        column_names = []\n        values = []\n        if project_id is not None:\n            column_names.append(\"project_id\")\n            values.append(project_id)\n        if po_number is not None:\n            column_names.append(\"po_number\")\n            values.append(po_number)\n        if po_type is not None:\n            column_names.append(\"po_type\")\n            values.append(po_type)\n\n        results = self.db_ops.search_purchase_orders(column_names, values)\n        if not results:\n            return []\n        if isinstance(results, dict):\n            return [results]\n        return results"
                    },
                    {
                        "name": "update_po_folder_link",
                        "args": [
                            "self",
                            "project_id",
                            "po_number",
                            "folder_link"
                        ],
                        "decorators": [],
                        "calls": [
                            "search_purchase_orders",
                            "update_purchase_order"
                        ],
                        "docstring": "\ud83d\uddc4 Example: find the PO and update the folder_link",
                        "function_body": "    def update_po_folder_link(self, project_id, po_number, folder_link):\n        \"\"\"\n        \ud83d\uddc4 Example: find the PO and update the folder_link\n        \"\"\"\n        pos = self.db_ops.search_purchase_orders([\"project_id\", \"po_number\"], [project_id, po_number])\n        if not pos:\n            self.logger.warning(f\"\u26a0\ufe0f No PO found for {project_id}_{po_number}, cannot update folder_link.\")\n            return False\n\n        if isinstance(pos, list):\n            # Take the first result\n            pos = pos[0]\n        updated = self.db_ops.update_purchase_order(pos[\"id\"], folder_link=folder_link)\n        return True if updated else False"
                    }
                ],
                "decorators": []
            }
        ],
        "variables": [
            {
                "name": "po_log_database_util",
                "value": "PoLogDatabaseUtil()"
            }
        ]
    }
]